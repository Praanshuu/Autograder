<!DOCTYPE html><html><head><meta charset='utf-8'><title>practice5_6_q7 Embeddings</title></head><body>
<div style="margin: 8px 0; display:flex; gap:12px; align-items:center; flex-wrap: wrap;">
  <label><b>Search Roll No:</b></label>
  <input id="searchBox" type="text" placeholder="e.g., B25DS024" style="padding:6px 8px; width:220px;">
  <button id="searchBtn" style="padding:6px 12px; cursor:pointer;">Search</button>
  <span style="color:#666;">(Click Search to highlight matches on the plot)</span>
</div>
<div>                        <script type="text/javascript">window.PlotlyConfig = {MathJaxConfig: 'local'};</script>
        <script charset="utf-8" src="https://cdn.plot.ly/plotly-3.0.1.min.js" integrity="sha256-oy6Be7Eh6eiQFs5M7oXuPxxm9qbJXEtTpfSI93dW16Q=" crossorigin="anonymous"></script>                <div id="plot_practice5_6_q7" class="plotly-graph-div" style="height:100%; width:100%;"></div>            <script type="text/javascript">                window.PLOTLYENV=window.PLOTLYENV || {};                                if (document.getElementById("plot_practice5_6_q7")) {                    Plotly.newPlot(                        "plot_practice5_6_q7",                        [{"customdata":[["total=1\u003cbr\u003edef max_depth(list_r):\u003cbr\u003e    global total\u003cbr\u003e    for i in range(len(list_r)):\u003cbr\u003e        \u003cbr\u003e        if isinstance(list_r[i], list):\u003cbr\u003e            total+=1\u003cbr\u003e            max_depth(list_r[i])\u003cbr\u003e        else:\u003cbr\u003e            pass\u003cbr\u003e    return total\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    depth = 1\u003cbr\u003e    count = 1\u003cbr\u003e    for i in range(0,len(lst)):\u003cbr\u003e        if type(lst[i]) == list:\u003cbr\u003e            count = 1 + max_depth(lst[i])\u003cbr\u003e            if count &gt; depth:\u003cbr\u003e                depth = count\u003cbr\u003e    return depth\u003cbr\u003e\"\"\"it goes inside the list..if it encounters a list it calls the function again..then it counts the depth..it compares the\u003cbr\u003e    depth of diffrent list and return maximum depth\"\"\"","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    count=1\u003cbr\u003e    maxlen=0\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            p = max_depth(i)\u003cbr\u003e            if p &gt; maxlen:\u003cbr\u003e                maxlen = p\u003cbr\u003e    count += maxlen\u003cbr\u003e    return count\u003cbr\u003e'''Returns the maximum depth of nesting in a list. \u003cbr\u003e    It counts how many levels of lists are nested inside the input list.'''","analysis.embedding.code_embedding"],["def max_depth(lst):         \u003cbr\u003e    if type(lst) != list:   \u003cbr\u003e        return 0\u003cbr\u003e\u003cbr\u003e    depth = 1\u003cbr\u003e\u003cbr\u003e    for item in lst:        \u003cbr\u003e        if type(item) == list:\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e\u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"Return the maximum nesting depth of lists. A flat list(including an empty list)has depth 1. If there are nested lists inside, the depthincreases.\"\"\"\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max(max_depth(item) for item in lst)\u003cbr\u003etest_list = [1, [2, [3, [4]]]]\u003cbr\u003eresult = max_depth(test_list)\u003cbr\u003eprint(\"Max depth is:\", result)","analysis.embedding.code_embedding"],["\"\"\"\u003cbr\u003eReturn the maximum nesting depth of lists. A flat list\u003cbr\u003e(including an empty list)\u003cbr\u003ehas depth 1. If there are nested lists inside, the depth\u003cbr\u003eincreases.\"\"\"\u003cbr\u003e\u003cbr\u003e\u003cbr\u003ecount = 1\u003cbr\u003edef max_depth(lst): \u003cbr\u003e    global count\u003cbr\u003e    m = count\u003cbr\u003e    for i in range(len(lst)):\u003cbr\u003e        t = type(lst[i])  #type is list\u003cbr\u003e        if t is list:\u003cbr\u003e            m += max_depth(lst[i])  # i use recursion\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst)!=list:\u003cbr\u003e        return 0\u003cbr\u003e    elif lst==[]:\u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        a=1\u003cbr\u003e        for i in lst:\u003cbr\u003e            if type(i)==list:\u003cbr\u003e                a=a+1\u003cbr\u003e                max_depth(lst)\u003cbr\u003e        return a","analysis.embedding.code_embedding"],["c=1\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    global c\u003cbr\u003e    for x in lst:\u003cbr\u003e        if(type(x)==list):\u003cbr\u003e            c+=1\u003cbr\u003e            return max_depth(x)\u003cbr\u003e    return c\u003cbr\u003e            \u003cbr\u003e        ","analysis.embedding.code_embedding"],["def depth(n):\u003cbr\u003e    max = 1\u003cbr\u003e    count = 1\u003cbr\u003e    for i in n :\u003cbr\u003e        if (type(i) == list):\u003cbr\u003e            count = depth(i) + 1\u003cbr\u003e            if (count&gt;max):\u003cbr\u003e                max = count\u003cbr\u003e    return max","analysis.embedding.code_embedding"],["\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003eReturn the maximum nesting depth of lists. A flat list\u003cbr\u003e(including an empty list)\u003cbr\u003ehas depth 1. If there are nested lists inside, the depth\u003cbr\u003eincreases.\u003cbr\u003e\"\"\"\u003cbr\u003e    def depth(p):\u003cbr\u003e        # If not a list, depth = 0\u003cbr\u003e        if type(p) is not list:\u003cbr\u003e            return 0\u003cbr\u003e\u003cbr\u003e        \u003cbr\u003e        d = 1\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    lst = str(lst)\u003cbr\u003e    count = 0\u003cbr\u003e    i =0\u003cbr\u003e    while lst[i] != ']':\u003cbr\u003e        if lst[i] == '[':\u003cbr\u003e            count+=1 # counts number of ] character in the string\u003cbr\u003e        i = i+1\u003cbr\u003e    return count","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"Return the maximum nesting depth of lists.\"\"\"\u003cbr\u003e\u003cbr\u003e    depths = [1]\u003cbr\u003e\u003cbr\u003e    for x in lst:\u003cbr\u003e        if type(x) == list:\u003cbr\u003e            depths.append(1 + max_depth(x))     #Reccursive Call\u003cbr\u003e\u003cbr\u003e    return max(depths)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e# print(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003e# print(max_depth([1, 2, 3]))\u003cbr\u003e# print(max_depth([]))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["lst = [1, [2, [3, [4]]]]\u003cbr\u003e\u003cbr\u003edef depth(x):\u003cbr\u003e    if not isinstance(x, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not x:\u003cbr\u003e        return 1\u003cbr\u003e    m = 1\u003cbr\u003e    for i in x:\u003cbr\u003e        if isinstance(i, list):\u003cbr\u003e            m = max(m, 1 + depth(i))\u003cbr\u003e    return m\u003cbr\u003e\u003cbr\u003eprint(depth(lst))","analysis.embedding.code_embedding"],["e = 1\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:  \u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max(max_depth(item) for item in lst)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))   \u003cbr\u003eprint(max_depth([1, 2, 3]))            \u003cbr\u003eprint(max_depth([]))                   \u003cbr\u003eprint(max_depth([[[]]]))               \u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"Return the maximum nesting depth of lists. A flat list (including\u003cbr\u003e       has depth 1. If there are nested lists inside, the depth increase\"\"\"\u003cbr\u003e    count=1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item)==list:\u003cbr\u003e            count=max(count,1+max_depth(item))  #recursive step\u003cbr\u003e    return count\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([]))\u003cbr\u003eprint(max_depth([2,3,[4,5,[6,7]]]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    dpth=0\u003cbr\u003e    count=0\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            count=max_depth(i)+1\u003cbr\u003e    if count==0:\u003cbr\u003e        return 1\u003cbr\u003e    return count\u003cbr\u003e   \u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max(max_depth(item) for item in lst)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    depth = 1\u003cbr\u003e    count = 1\u003cbr\u003e    for i in range(0,len(lst)):\u003cbr\u003e        if type(lst[i]) == list:\u003cbr\u003e            count = 1 + max_depth(lst[i])#doing the function again if the required condition is true\u003cbr\u003e            if count &gt; depth:\u003cbr\u003e                depth = count\u003cbr\u003e    return depth","analysis.embedding.code_embedding"],["\"\"\"calculates depth of list\"\"\"\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    if isinstance(lst,list):\u003cbr\u003e        x=1+max((max_depth(item) for item in lst),default=0)\u003cbr\u003e        return x\u003cbr\u003e    else:\u003cbr\u003e        return 0","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1\u003cbr\u003e    depths = []\u003cbr\u003e    for item in lst:\u003cbr\u003e        depths.append(max_depth(item))\u003cbr\u003e    return 1 + max(depths)\u003cbr\u003e\u003cbr\u003e#test cases\u003cbr\u003eprint (max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint (max_depth([1, 2, 3]))\u003cbr\u003eprint (max_depth([]))\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst,list):\u003cbr\u003e        return 0\u003cbr\u003e    if len(lst)==0:\u003cbr\u003e        return 1\u003cbr\u003e    return 1+ max(max_depth(i) for i in lst)\u003cbr\u003e    \u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["lst = [1, [2, [3, [4]]]]\u003cbr\u003e\u003cbr\u003edef depth(x):\u003cbr\u003e    if not isinstance(x, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not x:\u003cbr\u003e        return 1\u003cbr\u003e    m = 1\u003cbr\u003e    for i in x:\u003cbr\u003e        if isinstance(i, list):\u003cbr\u003e            m = max(m, 1 + depth(i))\u003cbr\u003e    return m\u003cbr\u003e\u003cbr\u003eprint(depth(lst))","analysis.embedding.code_embedding"],["def max_depth(list):\u003cbr\u003e    if not list: \u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in list:\u003cbr\u003e        if type(item) is list:\u003cbr\u003e            sub_depth = 1 + max_depth(item)  \u003cbr\u003e            depth = max(depth, sub_depth)\u003cbr\u003e       \u003cbr\u003e       \u003cbr\u003e        return depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e   ","analysis.embedding.code_embedding"],["# Maximum Depth of Nested Lists\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max(max_depth(item) for item in lst)\u003cbr\u003e    \u003cbr\u003e\u003cbr\u003e ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    def is_list(i):\u003cbr\u003e        return type(i)==list\u003cbr\u003e    deep=[]\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item)==list:\u003cbr\u003e            deep.append(max_deep(item))\u003cbr\u003e    if deep:\u003cbr\u003e        return 1+max(deep)\u003cbr\u003e    else:\u003cbr\u003e        return 1","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) != list:\u003cbr\u003e        return 0\u003cbr\u003e\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            d = 1 + max_depth(item)\u003cbr\u003e            if d &gt; depth:\u003cbr\u003e                depth = d\u003cbr\u003e    return depth","analysis.embedding.code_embedding"],["\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases. #print(max_depth([1, [2, [3, [4]]]]))       \u003cbr\u003e    \"\"\"\u003cbr\u003e    M = []\u003cbr\u003e    depth = 1\u003cbr\u003e    def islist(lst,depth,M):    \u003cbr\u003e        for i in lst:\u003cbr\u003e            if type(i) == list:\u003cbr\u003e                depth2 = depth + 1\u003cbr\u003e                M.append(depth2)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    c=1\u003cbr\u003e    for n in lst:\u003cbr\u003e        if type(n) == list:\u003cbr\u003e            c=c+max_depth(n)\u003cbr\u003e    return c\u003cbr\u003e\u003cbr\u003eprint(max_depth([1,[2,[3]]]))\u003cbr\u003e#print(maxdepth([1, [2, [3, [4]]]])) # 4","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003eReturn the maximum nesting depth of lists. A flat list\u003cbr\u003e(including an empty list)\u003cbr\u003ehas depth 1. If there are nested lists inside, the depth\u003cbr\u003eincreases.\u003cbr\u003e\"\"\"\u003cbr\u003e\u003cbr\u003e    s=type(lst)\u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1\u003cbr\u003e    inner_depths = []\u003cbr\u003e    for x in lst:\u003cbr\u003e        if type(x) == list:\u003cbr\u003e            inner_depths.append(max_depth(x))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    depth=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            depth=max(depth,1+max_depth(i))\u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["#B25MT019_q7\u003cbr\u003edef max_depth(l):\u003cbr\u003e    count=0# count the number of open square bracket\u003cbr\u003e    ls=str(l)\u003cbr\u003e    count=ls.count(\"[\")\u003cbr\u003e    print(count)\u003cbr\u003emax_depth([1,[2,[3,[4]]]])","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list) has depth 1.\u003cbr\u003e    If there are nested lists inside, the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if not lst: \u003cbr\u003e        return 1\u003cbr\u003e    d = 1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i) is list:\u003cbr\u003e            sd = 1 + max_depth(i) #incrementing sub depth if there's a list in a list \u003cbr\u003e            d = max(d, sd) #making the output max out of depth and sub depth\u003cbr\u003e            \u003cbr\u003e    return d\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(*n):\u003cbr\u003e    k=str(n)#converting into the n into string\u003cbr\u003e    a_tuple=tuple(k)\u003cbr\u003e    count=0\u003cbr\u003e    for i in a_tuple:\u003cbr\u003e           if i==\"[\":#for the depth equal to this no.of \"[\"\u003cbr\u003e               count=count+1\u003cbr\u003e                     \u003cbr\u003e    return(count)                 \u003cbr\u003eprint(max_depth([1,3,[[2,[34,5]]]]))                 \u003cbr\u003e                    \u003cbr\u003e            ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e  i = 0\u003cbr\u003e  count = 1\u003cbr\u003e  while i&lt;len(lst):\u003cbr\u003e      if type(lst[i]) != list:\u003cbr\u003e          i = i + 1\u003cbr\u003e      else:\u003cbr\u003e          count +=1\u003cbr\u003e          lst = lst[i]\u003cbr\u003e          i = 0\u003cbr\u003e  return count\u003cbr\u003e          ","analysis.embedding.code_embedding"],["\u003cbr\u003e\u003cbr\u003edef max_depth(lst: list) -&gt; int:\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list) has depth 1. If there are nested lists inside,\u003cbr\u003e    the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    # The depth is 1 if the list is flat (contains no other lists).\u003cbr\u003e    if not any(isinstance(item, list) for item in lst):\u003cbr\u003e        return 1\u003cbr\u003e    \u003cbr\u003e    # If there are nested lists, the depth is 1 + the max depth of any sub-list.\u003cbr\u003e    max_child_depth = 0\u003cbr\u003e    for item in lst:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst:list):\u003cbr\u003e    a=1\u003cbr\u003e    if type(lst)==list:\u003cbr\u003e        for n in lst:\u003cbr\u003e            if type(n)==list:\u003cbr\u003e                a=a+max_depth(n)\u003cbr\u003e        else:\u003cbr\u003e            return 0\u003cbr\u003e    return a","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) != list:   # not a list → depth 0\u003cbr\u003e        return 0\u003cbr\u003e    \u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e    return depth\u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([1]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list) has depth 1. If there are nested\u003cbr\u003e    lists inside, the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if not isinstance(lst, list):   # not a list → depth 0\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:  # empty list\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list) has depth 1. If there are nested\u003cbr\u003e    lists inside, the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if not isinstance(lst, list):   # not a list → depth 0\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:  # empty list\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0)","analysis.embedding.code_embedding"],["def max_depth(lst): \u003cbr\u003e    depth = 1\u003cbr\u003e    i=0\u003cbr\u003e    while i&lt;len(lst):\u003cbr\u003e        if type(lst[0]) == int:\u003cbr\u003e            lst.remove(lst[0])\u003cbr\u003e        elif type(lst[0]) == list:\u003cbr\u003e            depth=depth+1\u003cbr\u003e            lst = lst[0]\u003cbr\u003e        i=0\u003cbr\u003e    return depth\u003cbr\u003e    \u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([ ]))","analysis.embedding.code_embedding"],["c=1\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    global c\u003cbr\u003e    m=c\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            m+=max_depth(i)\u003cbr\u003e        else:\u003cbr\u003e            continue\u003cbr\u003e    return m\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003eprint(max_depth([]))      ","analysis.embedding.code_embedding"],["\u003cbr\u003eimport ast\u003cbr\u003e\u003cbr\u003euser_input = input(\"Enter a list (e.g., [1, [2, [3, [4]]]]): \")\u003cbr\u003e\u003cbr\u003elst = ast.literal_eval(user_input)\u003cbr\u003e\u003cbr\u003edef calculate_depth(sublist):\u003cbr\u003e    if not isinstance(sublist, list):\u003cbr\u003e        return 0\u003cbr\u003e    elif not sublist:\u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        max_sub_depth = 0\u003cbr\u003e        for item in sublist:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(list1):\u003cbr\u003e    if not list1:\u003cbr\u003e        return 1\u003cbr\u003e    \u003cbr\u003e    m = 0\u003cbr\u003e    \u003cbr\u003e    for item in list1:\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            nd = max_depth(item)\u003cbr\u003e            m = max(m, nd)\u003cbr\u003e    \u003cbr\u003e    return 1 + m","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    depths = []\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i) == list:   # go deeper only for sublists\u003cbr\u003e            depths.append(max_depth(i))\u003cbr\u003e    \u003cbr\u003e    if depths:   # if there are sublists\u003cbr\u003e        return 1 + max(depths)\u003cbr\u003e    else:        # if there are no sublists, then there is just one outer list\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\"\"\"\u003cbr\u003eReturn the maximum nesting depth of lists. A flat list\u003cbr\u003e(including an empty list)\u003cbr\u003ehas depth 1. If there are nested lists inside, the depth\u003cbr\u003eincreases.\u003cbr\u003e\"\"\"\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    s=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            s+=max_depth(i)\u003cbr\u003e    return s\u003cbr\u003e'''lst=eval(input('Input:'))\u003cbr\u003eprint(max_depth(lst))'''\u003cbr\u003e        ","analysis.embedding.code_embedding"],["\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists.\u003cbr\u003e    A flat list (including an empty list) has depth 1.\u003cbr\u003e    If there are nested lists inside, the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if not isinstance(lst, list):  # not a list → depth 0\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:  # empty list → depth 1\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max(max_depth(item) for item in lst)\u003cbr\u003e\u003cbr\u003e#testcase    \u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))  # 4\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["#########################################################################\u003cbr\u003e#NAME: Kammuri Lok Prakash Chowdary\u003cbr\u003e#ID NO: B25EC020\u003cbr\u003e#Discipline: Electronics and Communication Engineering\u003cbr\u003e#institute Name: Indian Institute of Technology Bhilai\u003cbr\u003e#######################################################################################\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    sum1=1\u003cbr\u003e    if type(lst)==list:\u003cbr\u003e        while type(lst[len(lst)-1])==list:\u003cbr\u003e            sum1+=1\u003cbr\u003e            if lst[len(lst)-1]==[]:\u003cbr\u003e                break \u003cbr\u003e            else:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    s=list(str(lst))\u003cbr\u003e    count=0\u003cbr\u003e    m=[]\u003cbr\u003e    for i in s:\u003cbr\u003e        if i==\"[\":\u003cbr\u003e            count+=1\u003cbr\u003e        if i == ']':\u003cbr\u003e            m.append(count)\u003cbr\u003e            count=count-1\u003cbr\u003e    return max(m)","analysis.embedding.code_embedding"],["count=1\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    global count\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            count+=1\u003cbr\u003e            max_depth(i)\u003cbr\u003e    return count","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    a=str(lst)\u003cbr\u003e    b=list(a)\u003cbr\u003e    dep=0\u003cbr\u003e    maximum_dep=0\u003cbr\u003e    for x in b:\u003cbr\u003e        if x =='[':\u003cbr\u003e            dep+=1\u003cbr\u003e            maximum_dep =max(maximum_dep,dep)\u003cbr\u003e        elif x ==']':\u003cbr\u003e            dep -=1\u003cbr\u003e    return maximum_dep\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e\tif not isinstance(lst, list):\u003cbr\u003e\t\treturn 0\u003cbr\u003e\tif not lst:\u003cbr\u003e\t\treturn 1\u003cbr\u003e\treturn 1 + max(max_depth(item) for item in lst)\u003cbr\u003e\u003cbr\u003e# test cases\u003cbr\u003eprint(max_depth([1, [2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if list == []:\u003cbr\u003e        return 1\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst :\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max(max_depth(i) for i in lst)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    c=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            c=c+max_depth(i)\u003cbr\u003e    return c\u003cbr\u003e'''lst=eval(input('Enter a list'))\u003cbr\u003eprint(max_depth(lst))'''\u003cbr\u003e    \u003cbr\u003e\"\"\"\u003cbr\u003eReturn the maximum nesting depth of lists. A flat list (including\u003cbr\u003ehas depth 1. If there are nested lists inside, the depth increase\u003cbr\u003e\"\"\"\u003cbr\u003epass ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max(max_depth(x) for x in lst)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e# testing\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))  # 4\u003cbr\u003eprint(max_depth([1, 2, 3]))           # 1\u003cbr\u003eprint(max_depth([]))                  # 1","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if not lst: # If the list is empty, then depth will be 1\u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) is list:\u003cbr\u003e            # If the element itself is a list\u003cbr\u003e            # Calculate the depth of that sublist\u003cbr\u003e            c = 1 + max_depth(item)  # Finding the maximum depth\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    l = list(str(lst))\u003cbr\u003e    depth = 0\u003cbr\u003e    max_depth = 0\u003cbr\u003e    for x in l:\u003cbr\u003e        if x =='[':\u003cbr\u003e            depth +=1\u003cbr\u003e            max_depth = max(max_depth,depth)\u003cbr\u003e        elif x ==']':\u003cbr\u003e            depth -=1   \u003cbr\u003e    return max_depth\u003cbr\u003e    pass\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))","analysis.embedding.code_embedding"],["c = 1\u003cbr\u003e\u003cbr\u003edef check_for_list(j):\u003cbr\u003e    global c\u003cbr\u003e    if type(j) == list:\u003cbr\u003e        c = c + 1\u003cbr\u003e        for elem in j:\u003cbr\u003e            check_for_list(elem) #used recursion to keep checking for depths\u003cbr\u003e        return True\u003cbr\u003e    else:\u003cbr\u003e        return False\u003cbr\u003e    pass\u003cbr\u003e\u003cbr\u003edef max_depth(list):\u003cbr\u003e    global c\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    for i in range(len(lst)):\u003cbr\u003e        if type(lst[i])==list:\u003cbr\u003e            return 1+max_depth(lst[i])  \u003cbr\u003e    return 1\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e    return depth\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) == list:\u003cbr\u003e        m=(max_depth(i) for i in lst)\u003cbr\u003e        return max([*m,0])+1\u003cbr\u003e    else:\u003cbr\u003e        return 0\u003cbr\u003e\u003cbr\u003e#Test Cases:\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]])) # 4\u003cbr\u003eprint(max_depth([1, 2, 3])) # 1\u003cbr\u003eprint(max_depth([])) # 1","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003eReturn the maximum nesting depth of lists. A flat list\u003cbr\u003e(including an empty list)\u003cbr\u003ehas depth 1. If there are nested lists inside, the depth\u003cbr\u003eincreases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    cnt=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            cnt = max(cnt, 1 + max_depth(i))\u003cbr\u003e        \u003cbr\u003e    return cnt\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst)!=list:\u003cbr\u003e        return 0\u003cbr\u003e    if lst==[ ]:\u003cbr\u003e        return 1\u003cbr\u003e    depth=[max_depth(num) for num in lst if type(num)==list]\u003cbr\u003e    if len(depth)==0:\u003cbr\u003e       return 1\u003cbr\u003e    else:\u003cbr\u003e      return 1+max(depth)\u003cbr\u003e      \u003cbr\u003e      \u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([ ]))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["count = 1\u003cbr\u003edef max_depth(lst): \u003cbr\u003e    global count\u003cbr\u003e    x = count\u003cbr\u003e    a = len(lst)\u003cbr\u003e    for i in range(a):\u003cbr\u003e        t = type(lst[i])  #type is list\u003cbr\u003e        if t is list:\u003cbr\u003e            x += max_depth(lst[i])  # i use recursion\u003cbr\u003e        else:\u003cbr\u003e            continue\u003cbr\u003e    return x","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    Sum=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if isinstance(i,list)==True:\u003cbr\u003e            Sum=Sum+max_depth(i)\u003cbr\u003e    return Sum\u003cbr\u003e        \u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003e    \u003cbr\u003e    ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    c = 1\u003cbr\u003e    for s in lst:\u003cbr\u003e        if isinstance(s, (list)):\u003cbr\u003e            c = c + max_depth(s)\u003cbr\u003e    return(c)\u003cbr\u003e\u003cbr\u003e\"\"\"\u003cbr\u003efirst i assigned c = 1 so the lst itself is counted as a list\u003cbr\u003ethen each element in the list goes into a for loop if it is a list then c is increased by 1\u003cbr\u003eand it goes in recursion.\u003cbr\u003e\"\"\"","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e\tn=lst\u003cbr\u003e\tl=len(n)\u003cbr\u003e\tc=1\u003cbr\u003e\ti=0\u003cbr\u003e\twhile i&lt;l:\u003cbr\u003e\t\tif type(n[i])==list:\u003cbr\u003e\t\t\tc=c+1\u003cbr\u003e\t\t\tn=n[i]\u003cbr\u003e\t\t\tl=len(n)\u003cbr\u003e\t\telse:\u003cbr\u003e\t\t\ti=i+1\u003cbr\u003e\treturn c\u003cbr\u003emax_depth([1,[2,[3,[4]]]])","analysis.embedding.code_embedding"],["#lst=eval(input('Enter a list: '))\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    c=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i) == list:\u003cbr\u003e            c=c+max_depth(i)\u003cbr\u003e    return c\u003cbr\u003e\u003cbr\u003e#print(max_depth(lst))\u003cbr\u003e            ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) != list:\u003cbr\u003e        return 0\u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1\u003cbr\u003e    max_d = 0\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            d = max_depth(item)\u003cbr\u003e            if d &gt; max_d:\u003cbr\u003e                max_d = d\u003cbr\u003e    return max_d + 1","analysis.embedding.code_embedding"],["lst=[1, 2, [3, [4]]]\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    totaldepth=1\u003cbr\u003e    def layer(item):\u003cbr\u003e        nonlocal totaldepth\u003cbr\u003e        if type(item)==list:\u003cbr\u003e            totaldepth+=1\u003cbr\u003e            for i in item:\u003cbr\u003e                \u003cbr\u003e                layer(i)\u003cbr\u003e    for j in lst:\u003cbr\u003e        layer(j)\u003cbr\u003e    return totaldepth\u003cbr\u003eprint(max_depth(lst))\u003cbr\u003e        ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst)!=list:\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    max_d=0\u003cbr\u003e    for item in lst:\u003cbr\u003e        d=max_depth(item)\u003cbr\u003e        if d&gt;max_d:\u003cbr\u003e            max_d=d\u003cbr\u003e    return 1+max_d\u003cbr\u003e\u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))  #4\u003cbr\u003eprint(max_depth([1,2,3]))  #1\u003cbr\u003eprint(max_depth([]))   #1\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    count=1\u003cbr\u003e    for l in lst:\u003cbr\u003e        if isinstance(l,(int,float)):\u003cbr\u003e            continue\u003cbr\u003e        elif isinstance(l,list):\u003cbr\u003e            count+= max_depth(l)\u003cbr\u003e    return count\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) == list:\u003cbr\u003e        depth = 1\u003cbr\u003e        for item in lst:\u003cbr\u003e            if type(item) == list:\u003cbr\u003e                d = 1 + max_depth(item)\u003cbr\u003e                if d &gt; depth:\u003cbr\u003e                    depth = d\u003cbr\u003e        return depth\u003cbr\u003e    else:\u003cbr\u003e        return 0\u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    count=1 #counting the list that is taken as input \u003cbr\u003e    for i in lst:\u003cbr\u003e        if(isinstance(i,list)): #checks if the element is list or not\u003cbr\u003e            count+=max_depth(i)\u003cbr\u003e        \u003cbr\u003e    return count\u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([]))            ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e   a=str(lst)\u003cbr\u003e   b=0\u003cbr\u003e   for i in a:\u003cbr\u003e      if i==\"]\":\u003cbr\u003e          b+=1\u003cbr\u003e   return  b","analysis.embedding.code_embedding"],["def max_depth(*l):\u003cbr\u003e    count=0\u003cbr\u003e    for x in l:\u003cbr\u003e        if type(x)==list or type(x)== tuple :\u003cbr\u003e            count =1+max_depth(*x)\u003cbr\u003e            \u003cbr\u003e    \u003cbr\u003e    return count\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]])) # 4\u003cbr\u003eprint(max_depth([1, 2, 3])) # 1\u003cbr\u003eprint(max_depth([])) # 1\u003cbr\u003e            \u003cbr\u003e    ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list): \u003cbr\u003e        return 0\u003cbr\u003e    if lst==[]:  \u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0)\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]])) # 4\u003cbr\u003eprint(max_depth([1, 2, 3])) # 1\u003cbr\u003eprint(max_depth([])) # 1","analysis.embedding.code_embedding"],["#########################################################################################\u003cbr\u003e#KOYYA SUMANTH BABU\u003cbr\u003e#B25EC022\u003cbr\u003e#ELECTRONICS AND COMMUNICATION ENGINEERING\u003cbr\u003e#INDIAN INSTITUTE OF TECHNOLOGY BHILAI\u003cbr\u003e########################################################################################\u003cbr\u003e\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0  \u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0)\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    depth = 1   # base depth\u003cbr\u003e    for i in lst:\u003cbr\u003e        if isinstance(i, list):\u003cbr\u003e            p = max_depth(i) + 1\u003cbr\u003e            if p &gt; depth:\u003cbr\u003e                depth = p\u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e# Test cases\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]])) \u003cbr\u003eprint(max_depth([1, 2, 3]))           \u003cbr\u003eprint(max_depth([]))                  ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list) has depth 1. If there are nested\u003cbr\u003e    lists inside, the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0  # Not a list, no depth\u003cbr\u003e\u003cbr\u003e    # Base depth is 1 for the current list\u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0)\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) != list:\u003cbr\u003e        return 0   \u003cbr\u003e    \u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1   \u003cbr\u003e    \u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if type(item) == list), default=0)\u003cbr\u003e\u003cbr\u003e# print(max_depth([2, [3], [4]]))\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    count=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if isinstance(i,(int,float)):\u003cbr\u003e            continue\u003cbr\u003e        elif isinstance(i,(list,tuple)):\u003cbr\u003e            count+=max_depth(i)\u003cbr\u003e    return count","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    depth =1\u003cbr\u003e    a = [1]\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i) == list:\u003cbr\u003e            a.append(max_depth(i)+1)\u003cbr\u003e        else:\u003cbr\u003e            continue\u003cbr\u003e    a.sort()\u003cbr\u003e    return a[-1]\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e#this function return the maximum nesting depth of lists. A flat list (including an empty list) has depth 1. If there are nested lists inside, the depth increases.\u003cbr\u003e    current_max_depth = 1\u003cbr\u003e\u003cbr\u003e    for item in lst:\u003cbr\u003e        if isinstance(item, list):\u003cbr\u003e            new_depth = 1 + max_depth(item)\u003cbr\u003e            if new_depth &gt; current_max_depth:\u003cbr\u003e                current_max_depth = new_depth\u003cbr\u003e                \u003cbr\u003e    return current_max_depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e                    ","analysis.embedding.code_embedding"],["def nested_depth_counter(obj):\u003cbr\u003e    nested = 1\u003cbr\u003e    for i in obj:\u003cbr\u003e        if type(i)==int:\u003cbr\u003e            continue\u003cbr\u003e        else:\u003cbr\u003e            x = nested_depth_counter(i)\u003cbr\u003e            nested += x\u003cbr\u003e\u003cbr\u003e    return nested\u003cbr\u003e\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list (including\u003cbr\u003e    has depth 1. If there are nested  lists inside, the depth increase,\u003cbr\u003e    Nested lists increase the depth by 1 for each nesting.\u003cbr\u003e    \"\"\"\u003cbr\u003e    #isinstance(obj,type) will return true if the obj is an instance of the class or type (typ)\u003cbr\u003e    if not isinstance(lst,list):#return 0 if input is not a list\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:#empty list is still have depth of 1\u003cbr\u003e        return 1\u003cbr\u003e    return 1+max((max_depth(item) for item in lst if isinstance(item,list)),default=0)\u003cbr\u003e#the return statement calculates the max depth by recursively calling itself again, we add the one to account for the outer list.","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    sub_depth = 0\u003cbr\u003e\u003cbr\u003e    for i in lst:\u003cbr\u003e        if str(type(i)) == \"&lt;class 'list'&gt;\":\u003cbr\u003e            sub_depth = max(sub_depth, max_depth(i))\u003cbr\u003e\u003cbr\u003e    return sub_depth + 1","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if lst == [] :\u003cbr\u003e        return 1\u003cbr\u003e    high_depth = 1  # Initialize maximum depth to 1 for a flat list\u003cbr\u003e\u003cbr\u003e    for item in lst:\u003cbr\u003e        if isinstance(item, list):\u003cbr\u003e            # If an item is a list, recursively calculate its depth\u003cbr\u003e            # and update high_depth if it's greater than the current high_depth\u003cbr\u003e            high_depth = max(high_depth, 1 + max_depth(item))#again the process continues with item as isinstance\u003cbr\u003e    return high_depth\u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003e    \u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list): \u003cbr\u003e        return 0\u003cbr\u003e    if not lst:  \u003cbr\u003e        return 1\u003cbr\u003e    \u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:  \u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max(max_depth(item) for item in lst)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))   \u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(list1):\u003cbr\u003e    if not list1:\u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for number in list1:\u003cbr\u003e        if type(number) is list: \u003cbr\u003e            depth = max(depth, 1 + max_depth(number))\u003cbr\u003e    return depth","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e   if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e   if not lst:\u003cbr\u003e       return 1\u003cbr\u003e   depth = [max_depth(item) for item in lst if isinstance(item, list)]\u003cbr\u003e   if not depth:\u003cbr\u003e       return 1\u003cbr\u003e   else:\u003cbr\u003e       return 1 + max(depth)\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def maxdepth(*lst):\u003cbr\u003e    depth = 0\u003cbr\u003e    for k in lst:\u003cbr\u003e        if type(k)==list:\u003cbr\u003e              depth= maxdepth(*k)+1\u003cbr\u003e    return depth  \u003cbr\u003eprint(maxdepth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(maxdepth([1, 2, 3])) \u003cbr\u003eprint(maxdepth([1,[3]],))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if type(lst) != list:\u003cbr\u003e        return 0  \u003cbr\u003e\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1  \u003cbr\u003e\u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if type(item) == list), default=0)\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    max_nest=1\u003cbr\u003e    \u003cbr\u003e    for n in lst:\u003cbr\u003e        depth=1\u003cbr\u003e        \u003cbr\u003e        if type(n)==list:\u003cbr\u003e            depth+=max_depth(n)\u003cbr\u003e        \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    count =0\u003cbr\u003e    depth = 0\u003cbr\u003e    s = str(lst)\u003cbr\u003e    for i in s:\u003cbr\u003e        if i == \"[\":\u003cbr\u003e            count = count +1\u003cbr\u003e            if count&gt;depth :\u003cbr\u003e                depth = count\u003cbr\u003e        elif  i == \"]\":\u003cbr\u003e            count = count -1\u003cbr\u003e    return depth\u003cbr\u003e            \u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if isinstance(item, list):\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e# Test Cases\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))  \u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003eprint(max_depth([]))\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) != list:\u003cbr\u003e        return 0\u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1\u003cbr\u003e    max_d = 0\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            d = max_depth(item)\u003cbr\u003e            if d &gt; max_d:\u003cbr\u003e                max_d = d\u003cbr\u003e    return max_d + 1\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003eprint(max_depth([1, [2, 3], 4]))\u003cbr\u003eprint(max_depth([1, [2, [3, 4]], 5]))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\u003cbr\u003e\u003cbr\u003edef max_depth(lst: list) -&gt; int:\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list) has depth 1. If there are nested lists inside,\u003cbr\u003e    the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    # The depth is 1 if the list is flat (contains no other lists).\u003cbr\u003e    if not any(isinstance(item, list) for item in lst):\u003cbr\u003e        return 1\u003cbr\u003e    \u003cbr\u003e    # If there are nested lists, the depth is 1 + the max depth of any sub-list.\u003cbr\u003e    max_child_depth = 0\u003cbr\u003e    for item in lst:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    max1 = 1\u003cbr\u003e    for a in lst:\u003cbr\u003e        if isinstance(a,list):\u003cbr\u003e            max1 += max_depth(a)\u003cbr\u003e    return max1","analysis.embedding.code_embedding"],["def max_depth(lst: list) -&gt; int:\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum depth of nested lists.\u003cbr\u003e    Example:\u003cbr\u003e      [1, [2, [3]]] → depth 3\u003cbr\u003e    \"\"\"\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    return 1 + max((max_depth(i) for i in lst if isinstance(i, list)), default=0)\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(* 1 ) :\u003cbr\u003e    count=0\u003cbr\u003e    for i in 1:\u003cbr\u003e        if type(i)==list or type(i)==tuple:\u003cbr\u003e            count =1+max_depth(*i)\u003cbr\u003e        return count    \u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))    \u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    count=0\u003cbr\u003e    depth=0\u003cbr\u003e    a=str(lst)\u003cbr\u003e    for i in a:\u003cbr\u003e        if i ==\"[\" :\u003cbr\u003e            count +=1\u003cbr\u003e            if count&gt;depth:\u003cbr\u003e                depth=count\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not lst: \u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for x in lst:\u003cbr\u003e        if type(x) is list:\u003cbr\u003e            s_depth = 1 + max_depth(x)  \u003cbr\u003e            depth = max(depth, s_depth)\u003cbr\u003e            \u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003eprint(max_depth([]))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def nested_depth_counter(obj):\u003cbr\u003e    nested = 1\u003cbr\u003e    for i in obj:\u003cbr\u003e        if type(i)==int:\u003cbr\u003e            continue\u003cbr\u003e        else:\u003cbr\u003e            x = nested_depth_counter(i)\u003cbr\u003e            nested += x\u003cbr\u003e\u003cbr\u003e    return nested\u003cbr\u003e\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. \u003cbr\u003e    A flat list (including an empty list) has depth 1. \u003cbr\u003e    If there are nested lists inside, the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if not isinstance(lst, list):   # If it's not a list, no depth\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:  # Empty list has depth 1\u003cbr\u003e        return 1\u003cbr\u003e    \u003cbr\u003e    # 1 for current list + maximum depth of any nested list\u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0)\u003cbr\u003e\u003cbr\u003eprint (max depth([1, 2, 3,]))","analysis.embedding.code_embedding"],["def max_depth(lst,):\u003cbr\u003e    global c\u003cbr\u003e    for i in lst:\u003cbr\u003e        try:\u003cbr\u003e            x=3+i\u003cbr\u003e        except:\u003cbr\u003e            c+=1\u003cbr\u003e            max_depth(i)\u003cbr\u003e    return c\u003cbr\u003ec=1\u003cbr\u003eprint(max_depth([1, 2, 3,[]]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return maximum nesting depth of lists.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max((max_depth(i) for i in lst), default=0)","analysis.embedding.code_embedding"],["a = eval(input(\"Enter a list : \"))\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    b = str(lst)\u003cbr\u003e    c = b.count(\"[\")\u003cbr\u003e    return c\u003cbr\u003e\u003cbr\u003eprint(max_depth(a))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0 \u003cbr\u003e    if not lst:\u003cbr\u003e        return 1  \u003cbr\u003e    return 1 + max(max_depth(item) for item in lst)","analysis.embedding.code_embedding"],["def max_depth(*lst):\u003cbr\u003e    count=0\u003cbr\u003e    if(len([lst])==0):           \u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        for i in lst:\u003cbr\u003e            if(isinstance(i,list)):    #As By using type() there is an error I searched for an alternative for type() and got to use this\u003cbr\u003e                count=1+max_depth(*i)       \u003cbr\u003e        return count\u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([]))\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst,list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    return max(max_depth(item) for item in lst) + 1\u003cbr\u003e        \u003cbr\u003e        \u003cbr\u003e# max_depth([1, [2, [3, [4]]]])\u003cbr\u003e# max_depth([1, 2, 3])     \u003cbr\u003e# max_depth([])                 \u003cbr\u003e# max_depth([[[]]])            \u003cbr\u003e# max_depth(5)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if lst==[]:\u003cbr\u003e        return 1\u003cbr\u003e\u003cbr\u003e    depth = 1   \u003cbr\u003e\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item)==list:      \u003cbr\u003e            m=max_depth(item) + 1 \u003cbr\u003e            if m &gt; depth:           \u003cbr\u003e                depth=m\u003cbr\u003e\u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    s=list(str(lst))\u003cbr\u003e    count=0\u003cbr\u003e    m=[]\u003cbr\u003e    for i in s:\u003cbr\u003e        if i==\"[\":\u003cbr\u003e            count+=1\u003cbr\u003e        if i == ']':\u003cbr\u003e            m.append(count)\u003cbr\u003e            count=count-1\u003cbr\u003e    return max(m)","analysis.embedding.code_embedding"],["def max_depth(lst):         #define a function for maximum depth\u003cbr\u003e    if type(lst) != list:   #condition according to question\u003cbr\u003e        return 0\u003cbr\u003e\u003cbr\u003e    depth = 1\u003cbr\u003e\u003cbr\u003e    for item in lst:        #for loop\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e\u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\"\"\"\u003cbr\u003eReturn the maximum nesting depth of lists. A flat list\u003cbr\u003e(including an empty list)\u003cbr\u003ehas depth 1. If there are nested lists inside, the depth\u003cbr\u003eincreases.\u003cbr\u003e\"\"\"\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    if type(lst)!=list:\u003cbr\u003e        return 0\u003cbr\u003e    s_depths=[max_depth(item) for item in lst if isinstance(item,list)]\u003cbr\u003e    if not s_depths:\u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        return 1+max(s_depths)\u003cbr\u003e   \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    depth = calculate_depth(lst, 0)\u003cbr\u003e    return (depth)\u003cbr\u003e\u003cbr\u003edef calculate_depth(element,result):#calculate the number of elements of the provided list\u003cbr\u003e    if type(element)==int or type(element)==float:\u003cbr\u003e        return result\u003cbr\u003e    elif type(element)==tuple or type(element)==list:\u003cbr\u003e        if element==[]:\u003cbr\u003e            return result+1\u003cbr\u003e        max_depth = result\u003cbr\u003e        for i in element:\u003cbr\u003e            temp = calculate_depth(i,result+1)\u003cbr\u003e            if temp &gt; max_depth:\u003cbr\u003e                max_depth = temp\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst:list):\u003cbr\u003e    ct=1\u003cbr\u003e    if type(lst)==list:     #checking if list \u003cbr\u003e        for i in lst:            #iterating list \u003cbr\u003e            if type(i)==list:           #checking again \u003cbr\u003e                ct=ct+max_depth(i)         #using reccursion to check if there are more nested lists \u003cbr\u003e    else:\u003cbr\u003e        return 0                      # returning 0 if not a list \u003cbr\u003e    return ct\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\"\"\"\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max((max_depth(x) for x in lst if isinstance(x, list)), default=0)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e#  print(max_depth([1,2,3,4]))        \u003cbr\u003e#  print(max_depth([1,2,3,4,6,[45,6]]))\u003cbr\u003e# print(max_depth([1, [2, [3, [4]]]])) # 4\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list (including\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth increase\u003cbr\u003e    \"\"\"\u003cbr\u003e    if type(lst) is not list:\u003cbr\u003e        return 0\u003cbr\u003e    depth = 1\u003cbr\u003e    for element in lst:\u003cbr\u003e        if type(element) is list:\u003cbr\u003e            depth = max(depth, 1 + max_depth(element))\u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list) has depth 1. If there are nested \u003cbr\u003e    lists inside, the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0  # not a list, no depth\u003cbr\u003e    \u003cbr\u003e    if not lst:  \u003cbr\u003e        return 1  # empty list → depth 1\u003cbr\u003e    \u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    depth=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            depth+=max_depth(i)\u003cbr\u003e    return depth\u003cbr\u003ea=max_depth([1, [2, [3, [4]]]]) # 4\u003cbr\u003eb=max_depth([1, 2, 3]) # 1\u003cbr\u003ec=max_depth([]) # 1","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    '''\u003cbr\u003e    first i converted the list into a string including all the brackets and comas. then i assigned the variables which i needed to use, then i checked for condecutive opening brackets ignoring numbers and comas. using them, i calculated the depth of nested lists\u003cbr\u003e    '''\u003cbr\u003e    z=0\u003cbr\u003e    c=0\u003cbr\u003e    i=0\u003cbr\u003e    y=str(lst)\u003cbr\u003e    while(i&lt;len(y)):\u003cbr\u003e        while(y[i]!=\"]\"):\u003cbr\u003e            if(y[i]==\"[\"):\u003cbr\u003e                c+=1\u003cbr\u003e            i+=1\u003cbr\u003e        else:\u003cbr\u003e            if(c&gt;z):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \u003cbr\u003e    if not isinstance(lst, list):  \u003cbr\u003e        return 0\u003cbr\u003e    \u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    \u003cbr\u003e    return 1 + max(max_depth(item) for item in lst)\u003cbr\u003e\u003cbr\u003emax_depth ([1, [2, [3, [5, 7, [6, ]]]]])","analysis.embedding.code_embedding"],["count = 1\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    global count\u003cbr\u003e    for i in lst:\u003cbr\u003e        if isinstance(i,(list)):\u003cbr\u003e            count += 1\u003cbr\u003e            max_depth(i)\u003cbr\u003e    return count\u003cbr\u003e\u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003ecount = 1\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003ecount = 1\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    depth = 1\u003cbr\u003e    for i in lst:\u003cbr\u003e        try:\u003cbr\u003e            p = max_depth(i) + 1\u003cbr\u003e            if p &gt; depth:\u003cbr\u003e                depth = p\u003cbr\u003e        except:\u003cbr\u003e            pass\u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not lst: \u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for x in lst:\u003cbr\u003e        if type(x) is list:\u003cbr\u003e            s_depth = 1 + max_depth(x)  \u003cbr\u003e            depth = max(depth, s_depth)\u003cbr\u003e            \u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003eprint(max_depth([]))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    max_nested=1 # defined for counting number of nested lists and updating this variable using recursion.\u003cbr\u003e    \u003cbr\u003e    for element in lst: # for each element in list, checks if element is list then counts depth.\u003cbr\u003e        depth=1\u003cbr\u003e        \u003cbr\u003e        if type(element)==list:\u003cbr\u003e            depth+=max_depth(element)\u003cbr\u003e        \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["# Mandeep Rewar - B25DS021\u003cbr\u003e# Problem 7 - maximum nesting depth of lists\u003cbr\u003efrom typing import Any\u003cbr\u003e\u003cbr\u003edef max_list_depth(obj: Any) -&gt; int:\u003cbr\u003e    \"\"\"Return maximum nesting depth of lists inside `obj`.\u003cbr\u003e\u003cbr\u003e    Examples\u003cbr\u003e    --------\u003cbr\u003e    &gt;&gt;&gt; max_list_depth([1, [2, [3]]])\u003cbr\u003e    3\u003cbr\u003e    &gt;&gt;&gt; max_list_depth(5)\u003cbr\u003e    0\u003cbr\u003e    \"\"\"\u003cbr\u003e    if not isinstance(obj, list):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst,list):\u003cbr\u003e        return 0\u003cbr\u003e    if lst == []:              # If list empty, depth is one\u003cbr\u003e        return 1\u003cbr\u003e    count = 1               # I start count from one\u003cbr\u003e    for i in range(len(lst)):\u003cbr\u003e        if isinstance(lst[i],list):\u003cbr\u003e            count=max(count,1+max_depth(lst[i]))\u003cbr\u003e    return count","analysis.embedding.code_embedding"],["c = 0\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    if(type(lst) == list and lst!=[]): #getting inside the nested lists one by one thus counting the maximum depth\u003cbr\u003e        for i in (lst):\u003cbr\u003e            global c\u003cbr\u003e        c = c + 1\u003cbr\u003e        max_depth(i)\u003cbr\u003e        return c\u003cbr\u003e    else:\u003cbr\u003e        return 1   \u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003ec = 0\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003ec = 0\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e    return depth\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(*lst):\u003cbr\u003e    depth = 0\u003cbr\u003e    for p in lst:\u003cbr\u003e        if type(p)==list:\u003cbr\u003e            \u003cbr\u003e            depth= max_depth(*p)+1\u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e \u003cbr\u003e \u003cbr\u003e \u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]])) # 4\u003cbr\u003eprint(max_depth([1, 2, 3])) # 1\u003cbr\u003eprint(max_depth([])) # 1    ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    count=0\u003cbr\u003e    for item in lst:\u003cbr\u003e        if(type(item)==list):\u003cbr\u003e            count+=1\u003cbr\u003e            count+=max_depth(item)\u003cbr\u003e            return count\u003cbr\u003e    else:\u003cbr\u003e        return 1","analysis.embedding.code_embedding"],["def max_depth(*lst):\u003cbr\u003e    depth = 0\u003cbr\u003e    for x in lst:\u003cbr\u003e        if type(x)==list:\u003cbr\u003e              depth= max_depth(*x)+1\u003cbr\u003e    return depth  \u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(max_depth([1, 2, 3])) \u003cbr\u003eprint(max_depth([1,[3]],))","analysis.embedding.code_embedding"],["def max_even_sum_len(N):\u003cbr\u003e   \"\"\"For a sequence 1, 2, ..., N, find the maximum length\u003cbr\u003e   of a contiguous subsequence that has an even sum.\"\"\"\u003cbr\u003e   a=N*(N+1)\u002f2\u003cbr\u003e   if a%2==0:\u003cbr\u003e       print(f\"{N}({list(range(1,N+1))})\")\u003cbr\u003e   else:\u003cbr\u003e       print(f\"{N-1}({list(range(1,N))})\")\u003cbr\u003emax_even_sum_len(8)       ","analysis.embedding.code_embedding"],["import ast\u003cbr\u003ex = ast.literal_eval(input ('enter list : '))#converts string to list\u003cbr\u003e\u003cbr\u003edef max_depth(x):\u003cbr\u003e    if type(x) != list:\u003cbr\u003e        return 0\u003cbr\u003e    \u003cbr\u003e    s = 1\u003cbr\u003e    maxdepthofinsidelist = 0\u003cbr\u003e    for i in x :\u003cbr\u003e        depth = max_depth(i)\u003cbr\u003e        if depth &gt; maxdepthofinsidelist :\u003cbr\u003e            maxdepthofinsidelist = depth\u003cbr\u003e        \u003cbr\u003e    s = s+ maxdepthofinsidelist\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    check=0\u003cbr\u003e    n=1\u003cbr\u003e    while(check==0):\u003cbr\u003e        for i in range(len(lst)):\u003cbr\u003e            if(type(lst[i])==list):\u003cbr\u003e                a=lst[i]\u003cbr\u003e                for j in range(len(a)):\u003cbr\u003e                    lst.append(a[j])\u003cbr\u003e                lst.remove(lst[i])\u003cbr\u003e                n += 1\u003cbr\u003e        check=1\u003cbr\u003e        for k in range (len(lst)):\u003cbr\u003e            if(type(lst[k])==list):\u003cbr\u003e                check=0\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst)!=list:\u003cbr\u003e        return 0\u003cbr\u003e    if lst==[]:\u003cbr\u003e        return 1\u003cbr\u003e    max_sub_depth=0\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item)==list:\u003cbr\u003e            depth=max_depth(item)\u003cbr\u003e            if depth&gt;max_sub_depth:\u003cbr\u003e                max_sub_depth=depth\u003cbr\u003e    return max_sub_depth+1\u003cbr\u003emax_depth([1, 2, 3])\u003cbr\u003emax_depth([])\u003cbr\u003emax_depth([1, [2, [3,[4]]]]) ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        return 1 + max(max_depth(item) for item in lst if isinstance(item, list))\u003cbr\u003e\u003cbr\u003e# Test cases\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))  \u003cbr\u003eprint(max_depth([1, 2, 3]))           \u003cbr\u003eprint(max_depth([]))                ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    s = 1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if isinstance(i,list):\u003cbr\u003e            s += max_depth(i)\u003cbr\u003e    return s\u003cbr\u003e            ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    s = str(lst)    \u003cbr\u003e    max_d = 0\u003cbr\u003e    current = 0\u003cbr\u003e\u003cbr\u003e    for char in s:\u003cbr\u003e        if char == '[':\u003cbr\u003e            current += 1\u003cbr\u003e            if current &gt; max_d:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    elif not lst:\u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        return 1 + max(max_depth(item) for item in lst)\u003cbr\u003e    \u003cbr\u003e# Here we are using recursions\u003cbr\u003e# If lst is not list function will return 0\u003cbr\u003e# If lst is empty function will return 1\u003cbr\u003e# If lst is not empty function will call by itself\u003cbr\u003e\u003cbr\u003e ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    lengthOfList = len(lst)\u003cbr\u003e    for i in range(lengthOfList):\u003cbr\u003e        if type(lst[i]) == list:\u003cbr\u003e            return max_depth(lst[i]) + 1\u003cbr\u003e    return 1","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0 \u003cbr\u003e    if not lst:\u003cbr\u003e        return 1  \u003cbr\u003e    return 1 + max(max_depth(item) for item in lst)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst,list):\u003cbr\u003e        return 0\u003cbr\u003e    if lst==[]:\u003cbr\u003e        return 1\u003cbr\u003e    count=1\u003cbr\u003e    for i in range(len(lst)):\u003cbr\u003e        if isinstance(lst[i],list):\u003cbr\u003e            count=max(count,1+max_depth(lst[i]))\u003cbr\u003e    return count","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not lst: \u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for x in lst:\u003cbr\u003e        if type(x) is list:\u003cbr\u003e            s_depth = 1 + max_depth(x)  \u003cbr\u003e            depth = max(depth, s_depth)\u003cbr\u003e            \u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003eprint(max_depth([]))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:  \u003cbr\u003e        return 1   \u003cbr\u003e    return 1 + max(max_depth(n) for n in lst)\u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    x = str(lst)\u003cbr\u003e    y = list(x)\u003cbr\u003e    l = [ch for ch in y if ch == \"[\" or ch == \"]\"]\u003cbr\u003e    count = 0\u003cbr\u003e    listbr = []\u003cbr\u003e    for i in range(len(l)):\u003cbr\u003e        if l[i]==\"[\":\u003cbr\u003e            count=count+1\u003cbr\u003e        else:\u003cbr\u003e            listbr.append(count)\u003cbr\u003e            count=count-1\u003cbr\u003e    depth = max(listbr)\u003cbr\u003e    return depth","analysis.embedding.code_embedding"],["\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    if not isinstance(lst,list):\u003cbr\u003e        return 0\u003cbr\u003e    else:\u003cbr\u003e        l= max(max_depth(x) for x in lst)\u003cbr\u003e    return l+1\u003cbr\u003e\u003cbr\u003e        \u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e     Return the maximum nesting depth of lists. A flat list\u003cbr\u003e     (includinghas depth 1. If there are nested lists inside,\u003cbr\u003e     the depth increase\u003cbr\u003e    \"\"\"\u003cbr\u003e    i = 0\u003cbr\u003e    while i &lt; len(lst):\u003cbr\u003e        if type(lst[i]) == int or type(lst[i]) == float:\u003cbr\u003e            lst.pop(i)  \u003cbr\u003e        else:\u003cbr\u003e            i += 1   \u003cbr\u003e        \u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0  # not a list → depth = 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1  # empty list still has depth 1\u003cbr\u003e    return 1 + max(max_depth(item) for item in lst)\u003cbr\u003e    \u003cbr\u003e\u003cbr\u003e# 🔹 Example usage\u003cbr\u003eprint(max_depth([1, 2, 3]))                  # 1\u003cbr\u003eprint(max_depth([1, [2, 3], 4]))             # 2\u003cbr\u003eprint(max_depth([1, [2, [3, 4], 5], 6]))     # 3\u003cbr\u003eprint(max_depth([[[[1]]]]))                  # 4\u003cbr\u003eprint(max_depth([]))                         # 1","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    Count = 0\u003cbr\u003e    if type(lst) == list:\u003cbr\u003e        Count += 1\u003cbr\u003e    else:\u003cbr\u003e        return Count\u003cbr\u003e    Inner_maximum = Count\u003cbr\u003e    for element in lst:\u003cbr\u003e        if type(element) == list:\u003cbr\u003e            Inner_list = max_depth(element)\u003cbr\u003e            if Inner_list + 1 &gt; Inner_maximum:\u003cbr\u003e                Inner_maximum = Inner_list + 1\u003cbr\u003e    return Inner_maximum\u003cbr\u003e            ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    count = 1\u003cbr\u003e    for p in lst:\u003cbr\u003e       if type(p) == list:\u003cbr\u003e            count += max_depth(p)\u003cbr\u003e    return count","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list): \u003cbr\u003e        return 0\u003cbr\u003e    if not lst:  \u003cbr\u003e        return 1\u003cbr\u003e    \u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e    return depth\u003cbr\u003e","analysis.embedding.code_embedding"],["\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    string = str(lst).split(\"]\")\u003cbr\u003e    count = 0\u003cbr\u003e    for i in string:\u003cbr\u003e        if i == \"\":\u003cbr\u003e            count += 1\u003cbr\u003e    return count\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003emax_depth([1, 2, 3])\u003cbr\u003emax_depth([])","analysis.embedding.code_embedding"],["# Maximum Depth of Nested Lists\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max(max_depth(item) for item in lst)\u003cbr\u003e    \u003cbr\u003e\u003cbr\u003e ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    count=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:# if data type is list then the count increases\u003cbr\u003e            count+=1\u003cbr\u003e            max_depth(i)\u003cbr\u003e    return count","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e \u003cbr\u003e    if not isinstance(lst, list):  \u003cbr\u003e        return 0\u003cbr\u003e    if not lst:  \u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0) \u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e''' THE LINE 7 HAS THE ALGORITHM AS FIRST IT RECURSIVELY CALL THE FUCTION max_depth()\u003cbr\u003e    AND IT ONLY SEND THE LISTS IN IT NOT ANY THING IN IT AND ON RECURSIVE CALLING IT\u003cbr\u003e    FINDS THE LIST WITH MAXIMUM DEPTH\u003cbr\u003e'''","analysis.embedding.code_embedding"],["\u003cbr\u003e\"\"\"\u003cbr\u003eReturn the maximum nesting depth of lists. A flat list\u003cbr\u003e(including an empty list)\u003cbr\u003ehas depth 1. If there are nested lists inside, the depth\u003cbr\u003eincreases.\u003cbr\u003e\"\"\"\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    if type(lst)!=list:\u003cbr\u003e        return 0\u003cbr\u003e    sub_depths=[max_depth(item) for item in lst if isinstance(item,list)]\u003cbr\u003e    if not sub_depths:\u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        return 1+max(sub_depths)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003eReturn the maximum nesting depth of lists. A flat list\u003cbr\u003e(including an empty list)\u003cbr\u003ehas depth 1. If there are nested lists inside, the depth\u003cbr\u003eincreases.\u003cbr\u003e\"\"\"\u003cbr\u003e    \u003cbr\u003e    if not isinstance(lst, list):                      #If input is not a list: raise TypeError\u003cbr\u003e        raise TypeError(\"max_depth expects a list\")\u003cbr\u003e\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1                                       #An empty list (or a list with no nested lists) has depth 1\u003cbr\u003e\u003cbr\u003e    # Compute depths of nested lists only\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    depth = 1\u003cbr\u003e\u003cbr\u003e    for element in lst:\u003cbr\u003e        if type(element) == list:  # if the element is a list\u003cbr\u003e            depth = max(depth, 1 + max_depth(element))\u003cbr\u003e\u003cbr\u003e    return depth\u003cbr\u003eprint( max_depth([1, [2, [3, [4]]]]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    count=0\u003cbr\u003e    for m in lst:\u003cbr\u003e        if isinstance(m,(int,float,complex)):\u003cbr\u003e            count=1\u003cbr\u003e        elif isinstance(m,(list,tuple)):\u003cbr\u003e            count=count+max_depth(m)\u003cbr\u003e    return(count)\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003e            ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e    return depth\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_dept(lst):\u003cbr\u003e    c=1\u003cbr\u003e    for i in range(0,len(lst)):\u003cbr\u003e        if(type(lst[i])!=int):\u003cbr\u003e            c=c+1\u003cbr\u003e            for k in range(0,len(lst[i])):\u003cbr\u003e                if(type(lst[i][k])!=int):\u003cbr\u003e                    c=c+1\u003cbr\u003e                    for j in range(0,len(lst[i][k])):\u003cbr\u003e                        if(type(lst[i][k][j])!=int):\u003cbr\u003e                            c=c+1\u003cbr\u003e                            for l in range(0,len(lst[i][k][j])):\u003cbr\u003e                                if(type(lst[i][k][j][l])!=int):\u003cbr\u003e                                    c=c+1\u003cbr\u003e        else:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list) has depth 1. If there are nested lists inside, the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if type(lst) is not list:\u003cbr\u003e        return 0\u003cbr\u003e    \u003cbr\u003e    if len(lst) == 0:\u003cbr\u003e        return 1\u003cbr\u003e    \u003cbr\u003e    max_dpt = 0\u003cbr\u003e    for item in lst:\u003cbr\u003e        depth = max_depth(item)\u003cbr\u003e        if depth &gt; max_dpt:\u003cbr\u003e            max_dpt = depth\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists.\u003cbr\u003e    A flat list (including an empty list) has depth 1.\u003cbr\u003e    If there are nested lists inside, the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if type(lst) != list:\u003cbr\u003e        return 0\u003cbr\u003e\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            d = 1 + max_depth(item)\u003cbr\u003e            if d &gt; depth:\u003cbr\u003e                depth = d\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["#WAP to find max_depth\u003cbr\u003ecount=1\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    global count\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:# if data type is list count increases\u003cbr\u003e            count+=1\u003cbr\u003e            max_depth(i)\u003cbr\u003e    return count","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) is not list:\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    max_inner_depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) is list:\u003cbr\u003e            depth = 1 + max_depth(item)\u003cbr\u003e            max_inner_depth = max(max_inner_depth, depth)\u003cbr\u003e    return max_inner_depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def max_depth(x):\u003cbr\u003e    max_d = 1\u003cbr\u003e    for item in x:\u003cbr\u003e        if isinstance(item, list):\u003cbr\u003e            max_d = max(max_d, 1 + max_depth(item))\u003cbr\u003e    return max_d\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if len(lst) ==1 or len(lst) == 0 :\u003cbr\u003e        n = 1\u003cbr\u003e    else :\u003cbr\u003e        n = 1\u003cbr\u003e        for i in (len(lst)-1, -1,-1):   # i start from len(lst)-1 to 0 (exclusive -1) decrement by -1\u003cbr\u003e            if isinstance(lst[i],list):  # if obj is list then count as n\u003cbr\u003e                n = n + 1    \u003cbr\u003e    return n\u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))           \u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["''' i counted the number of ']' in the list end which is equal to the depth because\u003cbr\u003eotherwise the parallel lists were being counted as nested.'''\u003cbr\u003ed = 0\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    global d\u003cbr\u003e    s = str(lst)\u003cbr\u003e    for i in s:\u003cbr\u003e        if i == ']':\u003cbr\u003e            d += 1\u003cbr\u003e    return int(d\u002f2)","analysis.embedding.code_embedding"],["def max_depth(n):\u003cbr\u003e\tc=1\u003cbr\u003e\tl=len(n)\u003cbr\u003e\ti=0\u003cbr\u003e\twhile i&lt;l:\u003cbr\u003e\t\twhile type(n[i])==list:\u003cbr\u003e\t\t\tn=n[i]\u003cbr\u003e\t\t\tc+=1\u003cbr\u003e\t\telse:\u003cbr\u003e\t\t\tn.remove(n[i])\u003cbr\u003e\t\tl=len(n)\u003cbr\u003e\treturn c\u003cbr\u003e\t","analysis.embedding.code_embedding"],["c = 1\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    l=[]\u003cbr\u003e    m=[]\u003cbr\u003e    global c\u003cbr\u003e    for i in lst:   # through this loop I am storing all the elements of lst which are list, in l.\u003cbr\u003e        if type(i) == list:\u003cbr\u003e            l.append(i)   \u003cbr\u003e    if len(l) != 0:  # through this loop I am just removing the 2nd depth of the list and storing it in m.\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    c=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i) == list:\u003cbr\u003e            c=c+max_depth(i)\u003cbr\u003e    return c\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if type(lst) != list:\u003cbr\u003e        return 0\u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1\u003cbr\u003e    inner_depths = []\u003cbr\u003e    for x in lst:\u003cbr\u003e        if type(x) == list:\u003cbr\u003e            inner_depths.append(max_depth(x))\u003cbr\u003e    if inner_depths == []: \u003cbr\u003e        return 1\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e\tcount=1\u003cbr\u003e\tfor i in lst:\u003cbr\u003e\t\tif type(i) in [list]:\u003cbr\u003e\t\t\tcount+=max_depth(i)\u003cbr\u003e\treturn count\u003cbr\u003e\t\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))# 4\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, 2, 3]))# 1\u003cbr\u003e\u003cbr\u003eprint(max_depth([]))# 1)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    count = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if isinstance(item, list):  # here isinstance say the type of item \u003cbr\u003e            count += 1\u003cbr\u003e    return count\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list) has depth 1. If there are nested\u003cbr\u003e    lists inside, the depth increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    global k\u003cbr\u003e    k=0\u003cbr\u003e    def is_list(value):\u003cbr\u003e        ty=type(value)\u003cbr\u003e        if(ty==list):\u003cbr\u003e            return True\u003cbr\u003e        else:\u003cbr\u003e            return False\u003cbr\u003e    def count(value2):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) != list:\u003cbr\u003e        return 0\u003cbr\u003e    if lst == []:           \u003cbr\u003e        return 1\u003cbr\u003e    depths = []\u003cbr\u003e    for x in lst:\u003cbr\u003e        depths.append(max_depth(x))   \u003cbr\u003e    \u003cbr\u003e    return 1 + max(depths)\u003cbr\u003e#print(max_depth([1,[2,[3,[4]]]]))","analysis.embedding.code_embedding"],["def max_depth(*lst1):\u003cbr\u003e    moves=0\u003cbr\u003e    for i in lst1:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            moves=1+max_depth(*i)\u003cbr\u003e    return moves\u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([]))\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e \"\"\"\u003cbr\u003e Return the maximum nesting depth of lists. A flat list\u003cbr\u003e (including an empty list)\u003cbr\u003e has depth 1. If there are nested lists inside, the depth\u003cbr\u003e increases.\u003cbr\u003e \"\"\"\u003cbr\u003e if not isinstance (  lst , list ) :\u003cbr\u003e    return 0\u003cbr\u003e    \u003cbr\u003e return 1 + max( max_depth(it) for it in lst )\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]])   )  \u003cbr\u003e     ","analysis.embedding.code_embedding"],["def nested_depth_counter(obj):\u003cbr\u003e    nested = 1\u003cbr\u003e    for i in obj:\u003cbr\u003e        if type(i)==int:\u003cbr\u003e            continue\u003cbr\u003e        else:\u003cbr\u003e            x = nested_depth_counter(i)\u003cbr\u003e            nested += x\u003cbr\u003e\u003cbr\u003e    return nested\u003cbr\u003e\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) != list:\u003cbr\u003e        return 0\u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if type(item) == list), default=0)\u003cbr\u003e    \u003cbr\u003eprint(max_depth([1, [2], [5]]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    depth=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            depth=max(depth,1+max_depth(i))\u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e            ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) != list:\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    depthsOfItems = [max_depth(item) for item in lst]\u003cbr\u003e    maxInnerDepth = max(depthsOfItems or [0])\u003cbr\u003e\u003cbr\u003e    return 1 + maxInnerDepth","analysis.embedding.code_embedding"],["\u003cbr\u003edef max_depth(lst):\u003cbr\u003e\u003cbr\u003e    depth = 1 # initial depth is 1\u003cbr\u003e\u003cbr\u003e    for i in lst: # loop runs for each index in the list\u003cbr\u003e\u003cbr\u003e        d = 1 # d is a variable that sotes the depth of the element of particular index\u003cbr\u003e\u003cbr\u003e        if type(i)==list: \u003cbr\u003e\u003cbr\u003e            d += max_depth(i) # calls the function recursively if element is list\u003cbr\u003e\u003cbr\u003e            if d&gt;depth:  # if d (depth of the index) is more than depth then depth takes value of d\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):         #define a function for maximum depth\u003cbr\u003e    if type(lst) != list:   #condition according to question\u003cbr\u003e        return 0\u003cbr\u003e\u003cbr\u003e    depth = 1\u003cbr\u003e\u003cbr\u003e    for item in lst:        #for loop\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e\u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst): \u003cbr\u003e    depth = 1\u003cbr\u003e    i=0\u003cbr\u003e    while i&lt;len(lst):\u003cbr\u003e        if type(lst[0]) == int:\u003cbr\u003e            lst.remove(lst[0])\u003cbr\u003e        elif type(lst[0]) == list:\u003cbr\u003e            depth=depth+1\u003cbr\u003e            lst = lst[0]\u003cbr\u003e        i=0\u003cbr\u003e    return depth\u003cbr\u003e    \u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([ ]))","analysis.embedding.code_embedding"],["# Really Liked this question !\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    depths=[]\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i) == int:\u003cbr\u003e            depths.append(0)\u003cbr\u003e        elif type(i) == list:\u003cbr\u003e            depths.append(max_depth(i))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not lst: \u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for x in lst:\u003cbr\u003e        if type(x) is list:\u003cbr\u003e            s_depth = 1 + max_depth(x)  \u003cbr\u003e            depth = max(depth, s_depth)\u003cbr\u003e            \u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003e\u003cbr\u003e   ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst,list):\u003cbr\u003e        return 0\u003cbr\u003e    if len(lst)==0:\u003cbr\u003e        return 1\u003cbr\u003e    return 1+ max(max_depth(i) for i in lst)\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    count = 1\u003cbr\u003e    for i in range (len(lst)):\u003cbr\u003e        if type(lst[i]) == list:\u003cbr\u003e            count = 1 + max_depth(lst[i])            \u003cbr\u003e    return count    \u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))  \u003cbr\u003eprint(max_depth([1, 2, 3]))      \u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases\u003cbr\u003e    \"\"\"\u003cbr\u003e\u003cbr\u003e    count = 0\u003cbr\u003e    if len(lst) == 0:\u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        run = True\u003cbr\u003e        while run:\u003cbr\u003e            try:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not lst: \u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for x in lst:\u003cbr\u003e        if type(x) is list:\u003cbr\u003e            s_depth = 1 + max_depth(x)  \u003cbr\u003e            depth = max(depth, s_depth)\u003cbr\u003e            \u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003eprint(max_depth([]))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst,list):\u003cbr\u003e        print(\"input shoulb be a list\")\u003cbr\u003e    depth=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if isinstance(i,list):\u003cbr\u003e            depth=max(depth,1+max_depth(i))\u003cbr\u003e    return depth\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if isinstance(item, list):\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e    return depth","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    current_depth = 1\u003cbr\u003e    for element in lst:\u003cbr\u003e        if type(element) == list:\u003cbr\u003e            nested_depth = max_depth(element)\u003cbr\u003e            total_depth = 1 + nested_depth\u003cbr\u003e            if total_depth &gt; current_depth:\u003cbr\u003e                current_depth = total_depth\u003cbr\u003e    \u003cbr\u003e    return current_depth","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    # Check if lst is a list\u003cbr\u003e    if type(lst) != list:\u003cbr\u003e        return 0  \u003cbr\u003e    # If the list is empty, its depth is 1\u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        return 1+ max(max_depth(item) for item in lst)\u003cbr\u003e        \u003cbr\u003e    \u003cbr\u003e","analysis.embedding.code_embedding"],["a = eval(input(\"Enter a list : \"))\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    b = str(lst)\u003cbr\u003e    c = b.count(\"[\")\u003cbr\u003e    return c\u003cbr\u003e\u003cbr\u003eprint(max_depth(a))\u003cbr\u003e","analysis.embedding.code_embedding"],["#B25CS044_Q7\u003cbr\u003e#Return the maximum nesting depth of lists\u003cbr\u003e\u003cbr\u003elst=eval(input('Enter the list: '))\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    \u003cbr\u003e    string=str(lst)\u003cbr\u003e    new_lst=list(string)\u003cbr\u003e    count=0\u003cbr\u003e    for i in new_lst:\u003cbr\u003e        if i=='[':     #The number of opening [ = number of lists\u003cbr\u003e            count+=1\u003cbr\u003e        else:\u003cbr\u003e            continue\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) != list:\u003cbr\u003e        return 0   \u003cbr\u003e    \u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1   \u003cbr\u003e    \u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if type(item) == list), default=0)\u003cbr\u003e\u003cbr\u003e# print(max_depth([2, [3], [4]]))\u003cbr\u003e","analysis.embedding.code_embedding"],["def checker(ch):\u003cbr\u003e    \"\"\"Checks if list or not and acts as a counter\"\"\"\u003cbr\u003e    global count\u003cbr\u003e    if type(ch) == list:\u003cbr\u003e        count+=1\u003cbr\u003e        return True\u003cbr\u003e    else:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    \"\"\"Returns final answer and sets counter to 1\"\"\"\u003cbr\u003e    global count\u003cbr\u003e    count = 1\u003cbr\u003e    worker(lst)\u003cbr\u003e    return count\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0       #if the entered one is not a list then 0 returns\u003cbr\u003e    elif not lst:\u003cbr\u003e        return 1       #If the entered list's depth is only one or is a null list then 1 returns\u003cbr\u003e    else:\u003cbr\u003e        return 1 + max(max_depth(v) for v in lst)\u003cbr\u003e    #If the entered one contains more then one list then this function executes counting the number of lists\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    num=0\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            a=max_depth(i)+1\u003cbr\u003e            num=a\u003cbr\u003e            \u003cbr\u003e    if num==0:\u003cbr\u003e        return 1\u003cbr\u003e    return num\u003cbr\u003e\u003cbr\u003e       \u003cbr\u003e   ","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list): \u003cbr\u003e        return 0\u003cbr\u003e    if not lst:  \u003cbr\u003e        return 1\u003cbr\u003e    \u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0)","analysis.embedding.code_embedding"],["#q7\u003cbr\u003e\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e\u003cbr\u003e    stack = [(lst, 1)] \u003cbr\u003e    max_depth_value = 1\u003cbr\u003e\u003cbr\u003e    while stack:\u003cbr\u003e        current_list, depth = stack.pop()\u003cbr\u003e\u003cbr\u003e        if depth &gt; max_depth_value:\u003cbr\u003e            max_depth_value = depth\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["depth_count=1 # initially for outer list\u003cbr\u003edef max_depth(l):\u003cbr\u003e    \u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    \u003cbr\u003e    temp=[]\u003cbr\u003e    q=[]\u003cbr\u003e    global depth_count\u003cbr\u003e\u003cbr\u003e    for k in l:                 #loop for identifying the nested list\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if isinstance(item, list):\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e    return depth\u003cbr\u003e\"\"\"Test Cases:\u003cbr\u003e• max depth([1, [2, [3, [4]]]]) # 4\u003cbr\u003e• max depth([1, 2, 3]) # 1\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["#maximum depth of list\u003cbr\u003e\u003cbr\u003edef max_depth(*n):\u003cbr\u003e    m=0\u003cbr\u003e    for i in n:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            m=1+max_depth(*i)\u003cbr\u003e\u003cbr\u003e    return m\u003cbr\u003eprint(max_depth([1,[5,[7]]]))\u003cbr\u003eprint(max_depth([1,[5,[7,[2,2,3]]]]))","analysis.embedding.code_embedding"],["\u003cbr\u003e\"\"\"\u003cbr\u003eReturn the maximum nesting depth of lists. A flat list\u003cbr\u003e(including an empty list)\u003cbr\u003ehas depth 1. If there are nested lists inside, the depth\u003cbr\u003eincreases.\u003cbr\u003e\"\"\"\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    if type(lst)!=list:\u003cbr\u003e        return 0\u003cbr\u003e    sub_depths=[max_depth(item) for item in lst if isinstance(item,list)]\u003cbr\u003e    if not sub_depths:\u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        return 1+max(sub_depths)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    '''i used the same logic as previous q \u003cbr\u003e    i again and again called the same function and updated the number of times i called the function\u003cbr\u003e    since the values are aldready in a list i added 1 to the answer'''\u003cbr\u003e    totsum = 0\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i) == list or type(i) == tuple:\u003cbr\u003e            totsum= totsum+max_depth(i)\u003cbr\u003e    return totsum+1","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if isinstance(item, list):\u003cbr\u003e            item_depth = max_depth(item) + 1\u003cbr\u003e            if item_depth &gt; depth:\u003cbr\u003e                depth = item_depth\u003cbr\u003e    return depth\u003cbr\u003e\u003cbr\u003e# Test cases\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))  # 4\u003cbr\u003eprint(max_depth([1, 2, 3]))           # 1\u003cbr\u003eprint(max_depth([]))    #1","analysis.embedding.code_embedding"],["a=list(input(\"\"))\u003cbr\u003ecount=0\u003cbr\u003efor i in a:\u003cbr\u003e    if i==\"[\" or i== \"]\":\u003cbr\u003e        count+=1\u003cbr\u003eprint(count\u002f2)","analysis.embedding.code_embedding"],["\u003cbr\u003edef max_depth(lst):\u003cbr\u003e   \u003cbr\u003e    if len(lst) == 0:\u003cbr\u003e        return 1\u003cbr\u003e\u003cbr\u003e    depth = 1   \u003cbr\u003e    i = 0\u003cbr\u003e\u003cbr\u003e    while i &lt; len(lst):\u003cbr\u003e        if type(lst[i]) == list:   \u003cbr\u003e            nested_depth = 1 + max_depth(lst[i])\u003cbr\u003e            \u003cbr\u003e            if nested_depth &gt; depth:\u003cbr\u003e                depth = nested_depth\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    '''Firstly i checked if any element is not list so it returns depth as 0 else iterate through if again it encounters any\u003cbr\u003e    list it calls again itself for this new list to know its depth, if its depth is greater than previous depth \u003cbr\u003e    depth gets modified and finally maximum depth is returned\u003cbr\u003e    '''\u003cbr\u003e    if(type(lst)!=list):\u003cbr\u003e        return 0\u003cbr\u003e    depth=1#as every list has at least 1 depth\u003cbr\u003e    for i in lst:\u003cbr\u003e        if(type(i)==list):\u003cbr\u003e            k=1+max_depth(i)#the list i is also present in a list lst so depth must increase by 1\u003cbr\u003e            if(k&gt;depth):\u003cbr\u003e                depth=k\u003cbr\u003e    return depth","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    c = 1\u003cbr\u003e    if len(lst) == 0 :\u003cbr\u003e        return 0 \u003cbr\u003e    for element in lst:\u003cbr\u003e        if isinstance(element, list): \u003cbr\u003e            total_depth = max_depth(element)\u003cbr\u003e            if total_depth + 1 &gt; c:\u003cbr\u003e                c = total_depth + 1                 \u003cbr\u003e    return c\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))\u003cbr\u003eprint(max_depth([1, 2, 3]))\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\"\"\"\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max((max_depth(x) for x in lst if isinstance(x, list)), default=0)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e#  print(max_depth([1,2,3,4]))        \u003cbr\u003e#  print(max_depth([1,2,3,4,6,[45,6]]))\u003cbr\u003e# print(max_depth([1, [2, [3, [4]]]])) # 4\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    d = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if isinstance(item, list):\u003cbr\u003e            d = max(d, 1 + max_depth(item))\u003cbr\u003e    return d","analysis.embedding.code_embedding"],["def rotate_list(nums, k):\u003cbr\u003e    if n &lt; 2:\u003cbr\u003e        return nums\u003cbr\u003e    k = k % n\u003cbr\u003e    if k == 0:\u003cbr\u003e        return nums\u003cbr\u003e    def reverse(start, end):\u003cbr\u003e        while start &lt; end:\u003cbr\u003e            nums[start], nums[end] = nums[end], nums[start]\u003cbr\u003e            start += 1\u003cbr\u003e            end -= 1\u003cbr\u003e    reverse(0, n - 1)\u003cbr\u003e    reverse(0, k - 1)\u003cbr\u003e    reverse(k, n - 1)\u003cbr\u003e    return nums","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) != list:   \u003cbr\u003e        return 0\u003cbr\u003e    elif lst == []:         \u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        depth = 1\u003cbr\u003e        for item in lst:\u003cbr\u003e            if type(item) == list:\u003cbr\u003e                b = max_depth(item) + 1\u003cbr\u003e                if b &gt; depth:\u003cbr\u003e                    depth = b\u003cbr\u003e        return depth","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003eReturn the maximum nesting depth of lists. A flat list\u003cbr\u003e(including an empty list)\u003cbr\u003ehas depth 1. If there are nested lists inside, the depth\u003cbr\u003eincreases.\u003cbr\u003e   \"\"\"\u003cbr\u003e\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) == list :\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e    return depth","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    count = 1 # already counting the input as a list\u003cbr\u003e    for e1 in lst:\u003cbr\u003e        if isinstance( e1, (list, tuple, dict)):\u003cbr\u003e            count = max(count, 1 + max_depth(e1))\u003cbr\u003e    return count","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        # If it's not the list and there is no depth contribution\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:\u003cbr\u003e        # depth of empty list is 1\u003cbr\u003e        return 1\u003cbr\u003e    # For non-empty list, depth is 1 + max depth of any nested lists inside\u003cbr\u003e    return 1 + max(max_depth(num) for num in lst)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"Return the maximum nesting depth of lists. A flat list (including an empty list) has depth 1. If there are nested lists inside, the depth increases.\"\"\"\u003cbr\u003e    depth = 1  # a flat list has depth 1\u003cbr\u003e    \u003cbr\u003e    for element in lst:\u003cbr\u003e        if isinstance(element, list):\u003cbr\u003e            # compute depth of the sublist\u003cbr\u003e            sub_depth = 1 + max_depth(element)\u003cbr\u003e            depth = max(depth, sub_depth)\u003cbr\u003e    \u003cbr\u003e    return depth\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(st):\u003cbr\u003e    max_depth_val = 1\u003cbr\u003e    for item in st:\u003cbr\u003e        if isinstance(item, list):\u003cbr\u003e            max_depth_val = max(max_depth_val, 1 + max_depth(item))\u003cbr\u003e            \u003cbr\u003e    print(max_depth_val)\u003cbr\u003e    return max_depth_val\u003cbr\u003e\u003cbr\u003emax_depth([1, [2, [3, [4]]]])\u003cbr\u003emax_depth([1, 2, 3])\u003cbr\u003emax_depth([])","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst)!=list:\u003cbr\u003e        return 0\u003cbr\u003e    if lst==[ ]:\u003cbr\u003e        return 1\u003cbr\u003e    depth=[max_depth(num) for num in lst if type(num)==list]\u003cbr\u003e    if len(depth)==0:\u003cbr\u003e       return 1\u003cbr\u003e    else:\u003cbr\u003e      return 1+max(depth)\u003cbr\u003e      \u003cbr\u003e      \u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([ ]))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if  type(lst)!= list :\u003cbr\u003e        return 0   \u003cbr\u003e    depth = 1     # every list has at least depth 1 ,base case\u003cbr\u003e    for item in lst:\u003cbr\u003e        depth = max(depth, 1 + max_depth(item))\u003cbr\u003e    return depth","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst) != list:   \u003cbr\u003e        return 0\u003cbr\u003e    elif lst == []:         \u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        depth = 1\u003cbr\u003e        for item in lst:\u003cbr\u003e            if type(item) == list:\u003cbr\u003e                b = max_depth(item) + 1\u003cbr\u003e                if b &gt; depth:\u003cbr\u003e                    depth = b\u003cbr\u003e        return depth","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0 \u003cbr\u003e    if not lst:\u003cbr\u003e        return 1  \u003cbr\u003e    return 1 + max(max_depth(item) for item in lst)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e  \u003cbr\u003e  \u003cbr\u003e  sub_depths = [max_depth(item) for item in lst if isinstance(item, list)]\u003cbr\u003e  \u003cbr\u003e  return 1 + max(sub_depths or [0])","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    stack = list(args)\u003cbr\u003e\u003cbr\u003e    while stack:\u003cbr\u003e        item = stack.pop(0)\u003cbr\u003e\u003cbr\u003e        if type(item) == int or type(item) == float:\u003cbr\u003e            total += item\u003cbr\u003e\u003cbr\u003e        elif type(item) == list:\u003cbr\u003e            for elem in item:\u003cbr\u003e                stack.append(elem)\u003cbr\u003e\u003cbr\u003e        elif type(item) == tuple:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["###################################################################################################\u003cbr\u003e#SATYA RISHINDRA SONTHENA\u003cbr\u003e#B25MM027\u003cbr\u003e#MATERIAL SCIENCES AND METALLURGICAL ENGINEERING\u003cbr\u003e#INDIAN INSTITUTE OF TECHNOLOGY BHILAI\u003cbr\u003e###################################################################################################\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0  \u003cbr\u003e    return 1 + max((max_depth(item) for item in lst if isinstance(item, list)), default=0)\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))","analysis.embedding.code_embedding"],["\u003cbr\u003e\u003cbr\u003ecount=1\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    global count\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i) is not list:    #if the element is list we update the global variable count\u003cbr\u003e            continue\u003cbr\u003e        elif type(i) is list:\u003cbr\u003e            count=count+1\u003cbr\u003e            max_depth(i)\u003cbr\u003e        else:\u003cbr\u003e            continue\u003cbr\u003e    return count\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    depth=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            depth+=max_depth(i)\u003cbr\u003e    return depth\u003cbr\u003ea=max_depth([1, [2, [3, [4]]]]) # 4\u003cbr\u003eb=max_depth([1, 2, 3]) # 1\u003cbr\u003ec=max_depth([]) # 1","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    k=0\u003cbr\u003e    def list_counter(i):\u003cbr\u003e        sum=0\u003cbr\u003e        if (type(i) is list):\u003cbr\u003e          sum=sum+1\u003cbr\u003e          for j in i:\u003cbr\u003e                sum=list_counter(j)+sum\u003cbr\u003e        return sum\u003cbr\u003e    for i in lst:\u003cbr\u003e        k=list_counter(i)+k\u003cbr\u003e    return k+1\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e  ","analysis.embedding.code_embedding"],["\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    count=1\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:     # if data type is list count increases\u003cbr\u003e            count+=1\u003cbr\u003e            max_depth(i)\u003cbr\u003e    return count","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if lst == []:\u003cbr\u003e        return 1\u003cbr\u003e    depth = 1\u003cbr\u003e    for item in lst:\u003cbr\u003e        if type(item) == list:\u003cbr\u003e            depth = max(depth, 1 + max_depth(item))\u003cbr\u003e    return depth\u003cbr\u003e","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    return 1 + max((max_depth(i) for i in lst), default=0)\u003cbr\u003e\u003cbr\u003e# Test cases\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]))  # 4\u003cbr\u003eprint(max_depth([1, 2, 3]))          # 1\u003cbr\u003eprint(max_depth([]))                # 1","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst)!=list:\u003cbr\u003e        return 0\u003cbr\u003e    if lst==[ ]:\u003cbr\u003e        return 1\u003cbr\u003e    depth=[max_depth(num) for num in lst if type(num)==list]\u003cbr\u003e    if len(depth)==0:\u003cbr\u003e       return 1\u003cbr\u003e    else:\u003cbr\u003e      return 1+max(depth)\u003cbr\u003e      \u003cbr\u003e      \u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([ ]))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    sum=1\u003cbr\u003e    if type(lst)==list:\u003cbr\u003e        while len(lst)&gt;0 and type(lst[len(lst)-1])==list:\u003cbr\u003e            sum+=1\u003cbr\u003e            lst=lst[len(lst)-1]\u003cbr\u003e        return sum\u003cbr\u003e    else:\u003cbr\u003e        return 0","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists .\u003cbr\u003e    \u003cbr\u003e    \"\"\"\u003cbr\u003e    if not isinstance(lst, list):\u003cbr\u003e        return 0\u003cbr\u003e    if not lst:   \u003cbr\u003e        return 1\u003cbr\u003e    return 1 + max(max_depth(x) for x in lst if isinstance(x, list))if any(isinstance(x, list) for x in lst) else 1\u003cbr\u003eprint(max_depth([1,[2,[3,[4]]]]))\u003cbr\u003eprint(max_depth([1,2,3]))\u003cbr\u003eprint(max_depth([]))","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e\u003cbr\u003e    depth = 1\u003cbr\u003e\u003cbr\u003e    for i in lst:\u003cbr\u003e        d = 1\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            d += max_depth(i)\u003cbr\u003e            if d&gt;depth:\u003cbr\u003e                depth = d\u003cbr\u003e\u003cbr\u003e    return depth","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    if type(lst)!=list:\u003cbr\u003e        return 0\u003cbr\u003e    sub_depths=[max_depth(item) for item in lst if isinstance(item,list)]\u003cbr\u003e    if not sub_depths:\u003cbr\u003e        return 1\u003cbr\u003e    else:\u003cbr\u003e        return 1+max(sub_depths)","analysis.embedding.code_embedding"],["def max_depth(lst):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return the maximum nesting depth of lists. A flat list\u003cbr\u003e    (including an empty list)\u003cbr\u003e    has depth 1. If there are nested lists inside, the depth\u003cbr\u003e    increases.\u003cbr\u003e    \"\"\"\u003cbr\u003e    x=str(lst)\u003cbr\u003e    return x.count(\"[\")","analysis.embedding.code_embedding"],["c=0\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    global c\u003cbr\u003e    for i in lst:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            c+=1\u003cbr\u003e            max_depth(i)        \u003cbr\u003e    return c+1\u003cbr\u003eprint(max_depth([1, [2, [3, [4]]]]))","analysis.embedding.code_embedding"],["count=1\u003cbr\u003edef max_depth(lst):\u003cbr\u003e    global count\u003cbr\u003e    for element in lst:\u003cbr\u003e        if(type(element)==type([])):\u003cbr\u003e            count+=1\u003cbr\u003e            max_depth(element)\u003cbr\u003e    return count","analysis.embedding.code_embedding"]],"hovertemplate":"\u003cb\u003eStudent ID:\u003c\u002fb\u003e %{hovertext}\u003cbr\u003e\u003cb\u003ePass Percentage:\u003c\u002fb\u003e %{marker.color:.2f}%\u003cbr\u003e\u003cb\u003eSource:\u003c\u002fb\u003e %{customdata[1]}\u003cbr\u003e\u003cbr\u003e\u003cb\u003eCode Snippet:\u003c\u002fb\u003e\u003cbr\u003e%{customdata[0]}\u003cextra\u003e\u003c\u002fextra\u003e","hovertext":["B25EC037_q7","B25EE048_q7","B25ME058_q7","B25MT011_q7","B25CS045_Q7","B25EC035_q7","B25ME041_q7","B25EC041_q7","B25CS002_q7","B25CS026_q7","B25DS003_q7","B25MT026_q7","B25CS027_Q7","B25DS011_q7","B25EC036_q7","B25EC032_ABHISHEK UJVAL_Q7","B25CS021_q7","b25cs038 q7","B25ME005_q7","B25MM023_q7","B25MM008_q7","B25EE011_q7","B25ME038_Q7","B25MT004_q7","B25CS030_q7","B25DS019_q7","B25CS061_q7","B25EE021_q7","s25ma008_q7","B25CS048_q7","B25EC014_q7","B25MT019_q7","B25DS029_q7","B25DS020_Q7","B25CS029_q7","B25EC011_q7","B25ME024_q7","B25ME004_Q7.py","B25ee014_q7","B25CS013_q7","B25EE056_Q7","B25DS008_q7","B25EE033.q7","B25ME047_Q7","B25EE036_q7","B25EC027_q7","B25EE052_q7","B25EC020_Q7","B25ME032_q7","B25DS014_q7","B25EE044_q7","B25EE025_q7","B25ME060_q7","B25MT027_q7","B25MM017.q7","B25MT005_q7","B25DS022_Q7","B25DS018_q7","B25EC026_q7","B25ME045_q7","B25CS035_q7","B25ME048_q7","B25MT003_q7","B25EE037_q7","B25EE031_q7","B25DS004_q7","B25EC003_Q7","B25MM006_q7","B25MM007_q7","B25EC033_q7","B25MT024_q7","B25EC002_q7","B25ME050_q7","B25ME012_q7","B25DS016_q7","B25ME022_q7(P5,6)","B25EC039_q7","B25EC022_q7","B25ME028_q7.py","B25MT020_Q7","B25EC021_q7","B25MT018_q7","B25CS037_q7","B25EC008_ q7","B25EE034_q7","B25MT002_q7","B25CS010_q7","B25DS024_Q7","B25DS007_q7","(B25DS042)_(Q7)","B25EC013_q7","B25MT017_q7","q7(B25MM016)","B25CS023_q7","B25ME014_q7.py","B25ME001_q7","B25ME030 Q7","B25DS040_q7","B25MT014_q7","B25DS012_q7","B25MT016_q7","B25MMO14_q7","B25ME018_q7","B25EC042_q7","B25ME008_Q7","B25EC007_q7","B25CS016_q7","B25MM002 q7","B25MM025_q7","B25ME027_q7","B25MM013_q7","B25DS027_q7","B25MM004_q7","B25MT008_q7","B25MM028_q7","B25EE015_Q7","B25EE020_q7","B25ME010_q7","B25EE027_Q7","B25EC031_q7","B25CS014_q7","B25EE058_q7","B25ME059_q7","B25MT022_q7","\u003cB25CS024\u003e_Q7","B25ME019_q7","B25DS017_q7","B25DS025_q7","MandeepRewar_B25DS021_q7","B25ME009_q7","B25EC045_q7","B25ME021_Q7","q7_B25ME046","B25CS004_q7","B25MM009 Q7","B25DS030_q7","\u003cB25DS005\u003e_q7","B25EC017_q7","B25ME007_q7","B25MT023\u003cQ7\u003e","B25CS041_q7","B25EE042_q7","B25CS020_q7","B25ME029_q7","B25MM026_q7","B25DS006_q7","B25CS062_q7","B25DS026.q7","B25DS023_q7","B25EE049_Q7","B25DS015_q7","B25mm015_q7","B25EE060_q7","B25MT032_q7","shourya_q7","B25mm018_Q7","B25CS008_Q7","B25MM021_q7","B25ME051_Q7","B25ME002_q7","B25EE017_q7","B25DS043_q7","B25EE029_q7","B25MT010_q7","B25ME037_Q7","B25DS035_q7","B25DS041_q7","B25EE051_q7","B25EE026_Q7","B25EE050_q7","B25DS032_q7","B25CS019_q7","B25MT009_Q7","B25EC015.q7","B25CS055_q7","S25MA018_q7","B25CS022_q7","B25CS060_q7","B25EE023_q7","B25ME013_q7","B25DS001_q7","B25ME006_q7","B25CS009_q7","B25DS010_Q7","B25MT029_Q7","B25EC043_q7","B25EE053_q7","B25CS054_q7","B25EE057_q7","B25EC038_q7.py","B25CS033_q7","B25EE022_q7","B25ME026_q7","\u003cB25CS036\u003e__q7","B25CS056_q7","B25MT007_q7","B25ME035_q7","B25DS028_q7","B25MT015_q7","B25EE001_q7","B25MM020_q7","B25CS044_Q7","B25EC001_q7","B25CS011_q7","B25EE013_q7","B25MT031_q7","B25EE055_q7","B25CS051_q7","B25MT006_q7","B25EC006_q7","B25CS034_q7","(q7)B25ME017","B25EE035.Q7","B25CS025_q7","B25EC018_q7","B25cs005_q7","B25DS034_q7","B25CS039_q7","B25ME043_q7","B24MT001_Q7","B25EE045_q7","B25ME054_q7","B25ME034_q7","B25EC024_q7","B25EC034_q7","B25EE006 Q7","B25EC_q7","B25ME049_q7","B25EC029.q7","B25ME056_q7","B25EE054_q7","B25ME003_q7","B25EC030_q7","B25MT021_q7","B25MM027_q7","B25EC044_Q7","B25ME033_Q7","B25EE007_q7","B25DS039_Q7","B25EC010_Q7","S25MA001_q7","B25EE003.q7","B25EE043_q7","B25ME011_q7","b25me039_q7","B25EE018_q7","B25CS059_q7","B25CS047_q7","B25EE004_q7"],"legendgroup":"","marker":{"color":{"dtype":"f8","bdata":"AAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJEmSJEmSPEDbtm3btm1VQAAAAAAAAAAAAAAAAAAAAADbtm3btm1VQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACRJkiRJkjxAAAAAAAAAWUAkSZIkSZI8QAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAADbtm3btm1VQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAt23btm3bUUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUC3bdu2bdtRQAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQLdt27Zt21FAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAADbtm3btm1VQAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAt23btm3bUUAAAAAAAAAAALdt27Zt21FA27Zt27ZtVUC3bdu2bdtRQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAALdt27Zt21FAAAAAAAAAAAAAAAAAAAAAALdt27Zt21FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAt23btm3bUUAAAAAAAAAAAAAAAAAAAFlAt23btm3bUUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAt23btm3bUUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAALdt27Zt21FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAt23btm3bUUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUC3bdu2bdtRQAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAADbtm3btm1VQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALdt27Zt21FAAAAAAAAAWUAAAAAAAAAAALdt27Zt21FAAAAAAAAAAAAAAAAAAABZQNu2bdu2bVVAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQCRJkiRJkkxA27Zt27ZtVUAAAAAAAAAAAAAAAAAAAFlAt23btm3bUUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQCRJkiRJkjxAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAt23btm3bUUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAkSZIkSZI8QAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAt23btm3bUUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAALdt27Zt21FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQLdt27Zt21FAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAt23btm3bUUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALdt27Zt21FAt23btm3bUUAkSZIkSZI8QAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAt23btm3bUUAAAAAAAAAAALdt27Zt21FA"},"coloraxis":"coloraxis","symbol":"circle","line":{"color":"DarkSlateGrey","width":1},"size":12},"mode":"markers","name":"","orientation":"v","showlegend":false,"x":{"dtype":"f4","bdata":"6goiQTzzNkGHmTZBu4wdQYS0W0ARN4ZAir49QbM2GEG07C5BZ4obQJisC0E243lA8WEJQU1OF0HOfhtBRipsQLXANUHmAU1BPMU3QbPSSUEuoRtBxFoeQY5ACUGm8jhBOX6KQESnQ0Emv0NB+aIkQCcgIUGEvyZAETEgQKedFUE0iBlAHhwsQUiZNEFbbzJAkko6QZHiHkFXe0pA3ShOQBm3J0EOWRhBik4KQS2RNUHu3yhA6y2EQDY2YkBsRylBBoMLQcw+I0EW8ApBiJMeQbskTUFfjRxBQAcZQaGGJUC1EAtBUccYQTqIP0EgTkNBltodQRnuIkAN5SFB99khQUgxH0GtdTRBwtspQe\u002fuC0EeqUJBOqchQY0EIUGydypA2GscQSA6K0FzrQtB8PolQVk4IEGBWydBrXIUQVuaTkDHpytB7t4vQSTIN0EgCy5AZHYnQZfHLEDikwxAaHxBQcIqR0Eh5yJBWf41QRdBREF2FBlBzMREQDfCHkAZlglBm1waQY9XGUHOaDJAe249QQ+TYUAicCVBlRwKQJkhC0F4DChBOGNDQCXuGUHpDlRARJILQRaLTUEVEylBpXAcQeewREELxQpBmh0gQUstiUBhXjxBtTIyQcF6dEAlLGtAve5QQOiwIEE6iglByEcjQaUDIEHIZBFBI1IJQSDQNkC4HIxAWMpMQSYIFkHI10JBgzUYQY1\u002fMkHkSBZByS8+QfvvCkHDCjdBwtMyQcghGUGoNBRA5H4KQA6iSEHsVT5Bi6tOQYY1OkH1VwhB5+kkQQSeDUHS0EtBNxZLQKR3F0HLjTpBj3o1QTu5SEHfhkJBm7wIQYOWh0A43S9BiGdDQas4ikCmEUVAkIk4QcsfL0H3b0VBxoAkQb7lZUA+UiZA+JAnQaNURUH9SBBB2mouQbuvDkH8sCtBDfoQQTSKH0E4VEFABkgmQcOpNUEgVT9AO6UqQbtaG0HsozlAijwpQU8kKkHaU0BB2P9DQT\u002fhQkESJB9Bo+cnQVB6JECqBwlB\u002f3xPQc5CJ0Eu4VNA2pgJQVeIQkESsyJAHe4+QdxsTkH8+wpByokMQU8KLkGWtB1BpM9KQf0XVkCCjzdBQz5HQd+nGkFSexlBEF1rQKM5IEGHu4hApZc0QYZjGEEHHgxB2zAGQT0uNkFpqhpBWMdrQAquREH9nShBydI\u002fQR9UJkBefTRBojNNQY3FEEBTnjtB\u002fwsiQR0QIkDJ6EJBUwdPQW1+PkERFixBp\u002fskQTNYH0HBWhxB1awxQSNlM0FllkNB3FQYQc36IEFQ1jhBeCFjQOl8Q0G7xD1BYCgHQJaxFkEPQCBB"},"xaxis":"x","y":{"dtype":"f4","bdata":"Qzc9QI\u002fBLEBpuDlAjgZxvzP3G8DRlh\u002fA1uFwPzbVAUBpWRhAc2IPwIqZpECYXA3A6dk0PmijBkA8sAvAiasawFXuOEAGBPq\u002f+hI1QOWVk78PyQTAfi0HwLELSD7vPzu\u002f9sXavymOG7+239m+S44awAjarz8LOQrAqLACwBBulEBzcNm\u002fQFklQLrDS0DeWJy\u002fUaZ8P69srr9TJ7a\u002fSxCxv7cwTD8M9vI\u002fn5qCQGl4jr4C9KO\u002fTKwjwPnNAsAjut29hkGnQE\u002fUTEAx\u002fKtA8pcPwAJh9b+LicA\u002f\u002fOQWwCJZrL940KpAj0gOQJkaPz\u002f5XWq+BgIWwB85HsBdlvi\u002fy6FGQETBUT98bD1AUMrLPxggfkDCuCy\u002f4uCjP0tWA8An6w7AG91sv3OwGkCjqalAyrUWQM2rDcDnph+\u002f51qAvhLpvL+FL9y\u002f1Ik+QFDgPD8+DynArIhVQCf5IMBNj+a\u002fl8gIvgF06r9hBgHAxtY0vmcG7L+QE\u002fQ+rDPhv11PEcBIDJ9AWJmyvyTf0b8J6qC\u002fKOUgPwZx279SuxxA4BkPwKezQT7M5VtAP9DIv1Hy5z++asy\u002fEqaGQDeF57+nrRFA6+QWwPokC76sZKZAqgM2vyOqH8DACR1AFkAaQO8GFsBfLxLAb3C+v1V5Jz+wPqZA+osAwKrjRUCetMC8WSdFPqDJ978u5iDAlYrYv+FHA0C99ii+gtsRP43fREDIj+o+\u002fgm4vxqyg0D96II\u002fiKblvzsBBsDHpe2\u002f744IwPoV+L\u002f10HE\u002fhFPov9np0D81Xgg9IyL8v8g9q0BJ3ra\u002f8vUVwLtZDMD+BzJADHxBQH8v2r8gHpq+tZWgQD+\u002f4b\u002fNCVNA91rpv6dMHMDBmQXAffdKPsUjRkCB\u002fYq+k6LHP3P2FMCwSbi\u002fJwhHQJugXL9tI0w+rhDzP5eon0CgCAhAzhTzP\u002fmToj\u002ftS8i\u002f1xT6Pw5FRUAIsA7A\u002f9\u002f4v42SLz9liSjAxuZTQOpX0r8eVCE\u002f6cWPv6uY2D544BG\u002fcBI8PyMIJsAqz34+MJbHv1wVCUA6XiTAdFFUPnpuNz\u002fvYc2\u002fqQE4Pjz89r9pqoVAoZ+QQGqC679w6k5AQXv6vxU117\u002fBEQpAUAPjvxMqxL+EUjFA6+gSwA7LlD\u002fh9yDAC+oPQOyeib\u002frq4ZAfWBzPMgvC0Cr\u002fJo\u002fpVEewMAFob7VJ9m+mkJFv4aSDcBe5ldAdaz3v621sb+B3Qo\u002fQsnwvyIiJMBgcFa\u002fx4nbv7tawr9I1VBAJV9hvzpxTEDduDo\u002fDitSQDQqUEDMv5K+RX8PwLJ\u002f8b9iaY0\u002ffjAhwPLAtj6LXei\u002fyGj1v7U86z9PJExA"},"yaxis":"y","type":"scatter"}],                        {"template":{"data":{"histogram2dcontour":[{"type":"histogram2dcontour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"choropleth":[{"type":"choropleth","colorbar":{"outlinewidth":0,"ticks":""}}],"histogram2d":[{"type":"histogram2d","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"heatmap":[{"type":"heatmap","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"contourcarpet":[{"type":"contourcarpet","colorbar":{"outlinewidth":0,"ticks":""}}],"contour":[{"type":"contour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"surface":[{"type":"surface","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"mesh3d":[{"type":"mesh3d","colorbar":{"outlinewidth":0,"ticks":""}}],"scatter":[{"fillpattern":{"fillmode":"overlay","size":10,"solidity":0.2},"type":"scatter"}],"parcoords":[{"type":"parcoords","line":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolargl":[{"type":"scatterpolargl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"bar":[{"error_x":{"color":"#2a3f5f"},"error_y":{"color":"#2a3f5f"},"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"scattergeo":[{"type":"scattergeo","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolar":[{"type":"scatterpolar","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"scattergl":[{"type":"scattergl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatter3d":[{"type":"scatter3d","line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattermap":[{"type":"scattermap","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattermapbox":[{"type":"scattermapbox","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterternary":[{"type":"scatterternary","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattercarpet":[{"type":"scattercarpet","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"carpet":[{"aaxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"baxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"type":"carpet"}],"table":[{"cells":{"fill":{"color":"#EBF0F8"},"line":{"color":"white"}},"header":{"fill":{"color":"#C8D4E3"},"line":{"color":"white"}},"type":"table"}],"barpolar":[{"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"pie":[{"automargin":true,"type":"pie"}]},"layout":{"autotypenumbers":"strict","colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#2a3f5f"},"hovermode":"closest","hoverlabel":{"align":"left"},"paper_bgcolor":"white","plot_bgcolor":"#E5ECF6","polar":{"bgcolor":"#E5ECF6","angularaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"radialaxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"ternary":{"bgcolor":"#E5ECF6","aaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"baxis":{"gridcolor":"white","linecolor":"white","ticks":""},"caxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"sequential":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"sequentialminus":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]]},"xaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"yaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"scene":{"xaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"yaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"zaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2}},"shapedefaults":{"line":{"color":"#2a3f5f"}},"annotationdefaults":{"arrowcolor":"#2a3f5f","arrowhead":0,"arrowwidth":1},"geo":{"bgcolor":"white","landcolor":"#E5ECF6","subunitcolor":"white","showland":true,"showlakes":true,"lakecolor":"white"},"title":{"x":0.05},"mapbox":{"style":"light"}}},"xaxis":{"anchor":"y","domain":[0.0,1.0],"title":{"text":"UMAP Dim 1"},"gridcolor":"lightgray"},"yaxis":{"anchor":"x","domain":[0.0,1.0],"title":{"text":"UMAP Dim 2"},"gridcolor":"lightgray"},"coloraxis":{"colorbar":{"title":{"text":"Pass %"},"ticks":"outside","dtick":20},"colorscale":[[0.0,"rgb(0,0,0)"],[0.3333333333333333,"rgb(230,0,0)"],[0.6666666666666666,"rgb(255,210,0)"],[1.0,"rgb(255,255,255)"]],"cmin":0,"cmax":100},"legend":{"tracegroupgap":0,"title":{"text":"Pass Percentage"}},"title":{"text":"Code Submission Semantic Map — practice5_6_q7 (UMAP)"},"plot_bgcolor":"white","paper_bgcolor":"white"},                        {"responsive": true}                    )                };            </script>        </div>
<script>
(function() {
  const divId = "plot_practice5_6_q7";
  const gd = document.getElementById(divId);
  const xs = [10.127664566040039, 11.434383392333984, 11.412482261657715, 9.846858024597168, 3.4328927993774414, 4.1942219734191895, 11.859018325805664, 9.513354301452637, 10.932788848876953, 2.4303224086761475, 8.729637145996094, 3.9044928550720215, 8.586411476135254, 9.456616401672363, 9.71845817565918, 3.690080165863037, 11.35954761505127, 12.812963485717773, 11.485652923583984, 12.613940238952637, 9.726850509643555, 9.897159576416016, 8.57826042175293, 11.559240341186523, 4.327908039093018, 12.228336334228516, 12.234167098999023, 2.5724470615386963, 10.07034969329834, 2.6054391860961914, 2.5029947757720947, 9.35098934173584, 2.3989381790161133, 10.756864547729492, 11.287422180175781, 2.7880465984344482, 11.643205642700195, 9.930314064025879, 3.163778066635132, 3.2212440967559814, 10.48220157623291, 9.52174186706543, 8.644174575805664, 11.347943305969238, 2.638667583465576, 4.130605220794678, 3.5345587730407715, 10.579936981201172, 8.719488143920898, 10.202831268310547, 8.683614730834961, 9.911018371582031, 12.821467399597168, 9.784514427185059, 9.56427001953125, 2.5863420963287354, 8.69157886505127, 9.548661231994629, 11.970758438110352, 12.206573486328125, 9.865865707397461, 2.5457823276519775, 10.118420600891113, 10.115714073181152, 9.949531555175781, 11.278729438781738, 10.616151809692383, 8.745833396911621, 12.166288375854492, 10.103326797485352, 10.063611030578613, 2.66355562210083, 9.776329040527344, 10.701690673828125, 8.729846000671387, 10.373764038085938, 10.01375675201416, 10.459839820861816, 9.277997016906738, 3.2281711101531982, 10.728461265563965, 10.991926193237305, 11.48636245727539, 2.7194290161132812, 10.46640396118164, 2.6996819972991943, 2.196526050567627, 12.092872619628906, 12.447938919067383, 10.181427955627441, 11.37459659576416, 12.265891075134277, 9.567495346069336, 3.0745115280151367, 2.4806039333343506, 8.59914493560791, 9.647608757019043, 9.583876609802246, 2.787646770477295, 11.839472770690918, 3.5246007442474365, 10.339876174926758, 2.157994508743286, 8.69570255279541, 10.503044128417969, 3.0529308319091797, 9.620640754699707, 3.3134100437164307, 8.723209381103516, 12.846456527709961, 10.567158699035645, 9.777501106262207, 12.29318904876709, 8.67310619354248, 10.007226943969727, 4.286778926849365, 11.773041725158691, 11.13737964630127, 3.8199923038482666, 3.6745693683624268, 3.26457142829895, 10.043190002441406, 8.596246719360352, 10.205024719238281, 10.000889778137207, 9.087104797363281, 8.582552909851074, 2.8564529418945312, 4.378505706787109, 12.799400329589844, 9.376989364624023, 12.177680969238281, 9.51306438446045, 11.156140327453613, 9.39279556274414, 11.886666297912598, 8.683588981628418, 11.4401273727417, 11.176698684692383, 9.570747375488281, 2.315713882446289, 2.163994789123535, 12.53956413269043, 11.895977020263672, 12.91688060760498, 11.638067245483398, 8.52147388458252, 10.30710506439209, 8.851078033447266, 12.738481521606445, 3.1732308864593506, 9.46670913696289, 11.65961742401123, 11.342421531677246, 12.545222282409668, 12.157927513122559, 8.546046257019043, 4.237123012542725, 10.991508483886719, 12.212776184082031, 4.319417476654053, 3.079202175140381, 11.533584594726562, 10.94526195526123, 12.339835166931152, 10.281438827514648, 3.5921473503112793, 2.5987696647644043, 10.472892761230469, 12.333163261413574, 9.01781940460205, 10.901086807250977, 8.917902946472168, 10.730709075927734, 9.061047554016113, 9.971240997314453, 3.0207653045654297, 10.392583847045898, 11.3539457321167, 2.9895706176757812, 10.665339469909668, 9.709650993347168, 2.900629997253418, 10.577280044555664, 10.633864402770996, 12.020471572875977, 12.249961853027344, 12.179991722106934, 9.946306228637695, 10.494051933288574, 2.569965362548828, 8.564371109008789, 12.968016624450684, 10.45380973815918, 3.3106188774108887, 8.599817276000977, 12.158286094665527, 2.542179584503174, 11.933133125305176, 12.90157699584961, 8.686519622802734, 8.783639907836914, 10.877516746520996, 9.856588363647461, 12.67569351196289, 3.3452141284942627, 11.472536087036133, 12.4527006149292, 9.665984153747559, 9.592607498168945, 3.6775550842285156, 10.014071464538574, 4.272891521453857, 11.287022590637207, 9.524297714233398, 8.757330894470215, 8.386927604675293, 11.3862886428833, 9.666604042053223, 3.684041976928711, 12.292490005493164, 10.53857135772705, 11.988961219787598, 2.598884344100952, 11.280607223510742, 12.825105667114258, 2.2620575428009033, 11.726153373718262, 10.127928733825684, 2.532233476638794, 12.181832313537598, 12.939288139343262, 11.905865669250488, 10.755387306213379, 10.31143856048584, 9.959033012390137, 9.772156715393066, 11.104695320129395, 11.212191581726074, 12.224217414855957, 9.52071762084961, 10.061230659484863, 11.552322387695312, 3.548917770385742, 12.217995643615723, 11.860529899597168, 2.1118392944335938, 9.418355941772461, 10.015639305114746];
  const ys = [2.95649790763855, 2.6993138790130615, 2.9018805027008057, -0.9415062665939331, -2.436962842941284, -2.4935801029205322, 0.9409459829330444, 2.0286383628845215, 2.3804571628570557, -2.2403838634490967, 5.143742561340332, -2.2087764739990234, 0.1766125112771988, 2.1037235260009766, -2.182631492614746, -2.416719675064087, 2.8895466327667236, -1.9532477855682373, 2.8292832374572754, -1.1530119180679321, -2.0747716426849365, -2.112151622772217, 0.19535709917545319, -0.7314442992210388, -1.7091662883758545, -0.6076379418373108, -0.4255349040031433, -2.4149348735809326, 1.3738412857055664, -2.15973162651062, -2.042032241821289, 4.638435363769531, -1.6987441778182983, 2.5835723876953125, 3.183821201324463, -1.2214620113372803, 0.9869127869606018, -1.3626917600631714, -1.4230750799179077, -1.3833097219467163, 0.7976183295249939, 1.8981337547302246, 4.081374645233154, -0.2782624065876007, -1.280884027481079, -2.5573911666870117, -2.0438215732574463, -0.10826518386602402, 5.226748466491699, 3.200458288192749, 5.374535083770752, -2.2436490058898926, -1.917022943496704, 1.5041974782943726, -2.3577260971069336, -1.3464701175689697, 5.337947845458984, 2.2231786251068115, 0.7464995980262756, -0.2288741022348404, -2.3438735008239746, -2.472236394882202, -1.9420887231826782, 3.1036250591278076, 0.8193552494049072, 2.9597463607788086, 1.592111587524414, 3.9707088470458984, -0.6746941804885864, 1.2803003787994385, -2.0521419048309326, -2.233102560043335, -0.9252488017082214, 2.4170196056365967, 5.301957607269287, 2.3548455238342285, -2.213610887527466, -0.6236404776573181, -0.25069352984428406, -1.475862741470337, -1.7202001810073853, 2.9771623611450195, 0.737797737121582, -2.6415553092956543, 3.3364667892456055, -2.515207052230835, -1.8012481927871704, -0.13357768952846527, -1.8316651582717896, -2.016014337539673, -0.17660054564476013, -1.8439453840255737, 0.4767117500305176, -1.7593894004821777, -2.2704689502716064, 4.970249176025391, -1.3953046798706055, -1.6396222114562988, -1.257142186164856, 0.6284966468811035, -1.7143867015838623, 2.4489331245422363, -2.2359542846679688, 0.18916188180446625, 3.4359006881713867, -1.5688551664352417, 1.8120824098587036, -1.5970075130462646, 4.207772254943848, -1.8087528944015503, 2.27622389793396, -2.357722043991089, -0.13588324189186096, 5.199789047241211, -0.7109934091567993, -2.4947593212127686, 2.4537200927734375, 2.4101614952087402, -2.3441731929779053, -2.2841413021087646, -1.4878062009811401, 0.6541951298713684, 5.195152282714844, -2.0085434913635254, 3.0920205116271973, -0.02352362498641014, 0.19253291189670563, -1.9358406066894531, -2.5140490531921387, -1.691729187965393, 2.051262140274048, -0.1650037318468094, 0.5697556734085083, 3.0761444568634033, 0.4581282138824463, -1.437804937362671, 4.115490913391113, 1.0227352380752563, -1.794144630432129, -2.093825101852417, -1.8566216230392456, -2.1337239742279053, -1.9381706714630127, 0.94459468126297, -1.8150486946105957, 1.6321364641189575, 0.033292967826128006, -1.9697917699813843, 5.351291656494141, -1.4286586046218872, -2.3431363105773926, -2.192976713180542, 2.781737804412842, 3.023196220397949, -1.704574465751648, -0.3010110855102539, 5.018274784088135, -1.7636488676071167, 3.297473192214966, -1.823088526725769, -2.44217848777771, -2.0875093936920166, 0.1982097178697586, 3.095933198928833, -0.27146533131599426, 1.559648871421814, -2.3275420665740967, -1.439748764038086, 3.109872579574585, -0.8618256449699402, 0.199353888630867, 1.8989465236663818, 4.989329814910889, 2.1255264282226562, 1.8990724086761475, 1.2701407670974731, -1.5648170709609985, 1.9537609815597534, 3.0823397636413574, -2.229494094848633, -1.9443358182907104, 0.6858299374580383, -2.6333858966827393, 3.310960292816162, -1.6433079242706299, 0.6301897764205933, -1.1232272386550903, 0.4230397641658783, -0.569831371307373, 0.7346563339233398, -2.5942466259002686, 0.24883714318275452, -1.5592708587646484, 2.1419286727905273, -2.568251132965088, 0.2073419690132141, 0.7165294885635376, -1.6045511960983276, 0.17969383299350739, -1.929572582244873, 4.177052021026611, 4.519485950469971, -1.8399174213409424, 3.2330589294433594, -1.9568864107131958, -1.6813074350357056, 2.1573336124420166, -1.773538589477539, -1.5325340032577515, 2.7706613540649414, -2.295466184616089, 1.1624467372894287, -2.515129327774048, 2.24865984916687, -1.075162410736084, 4.208486080169678, 0.014854547567665577, 2.1747913360595703, 1.2108358144760132, -2.4737331867218018, -0.3144969940185547, -0.42413201928138733, -0.7705475091934204, -2.2120680809020996, 3.3734354972839355, -1.9349504709243774, -1.3883568048477173, 0.5424423813819885, -1.8811419010162354, -2.5645833015441895, -0.8376522064208984, -1.7151421308517456, -1.518393874168396, 3.2630176544189453, -0.8803580403327942, 3.194410800933838, 0.7293832898139954, 3.2838778495788574, 3.2525758743286133, -0.28661954402923584, -2.242142915725708, -1.886709451675415, 1.104778528213501, -2.518584728240967, 0.3569408059120178, -1.8153547048568726, -1.9172601699829102, 1.8377901315689087, 3.189716100692749];
  const ids = ["B25EC037_q7", "B25EE048_q7", "B25ME058_q7", "B25MT011_q7", "B25CS045_Q7", "B25EC035_q7", "B25ME041_q7", "B25EC041_q7", "B25CS002_q7", "B25CS026_q7", "B25DS003_q7", "B25MT026_q7", "B25CS027_Q7", "B25DS011_q7", "B25EC036_q7", "B25EC032_ABHISHEK UJVAL_Q7", "B25CS021_q7", "b25cs038 q7", "B25ME005_q7", "B25MM023_q7", "B25MM008_q7", "B25EE011_q7", "B25ME038_Q7", "B25MT004_q7", "B25CS030_q7", "B25DS019_q7", "B25CS061_q7", "B25EE021_q7", "s25ma008_q7", "B25CS048_q7", "B25EC014_q7", "B25MT019_q7", "B25DS029_q7", "B25DS020_Q7", "B25CS029_q7", "B25EC011_q7", "B25ME024_q7", "B25ME004_Q7.py", "B25ee014_q7", "B25CS013_q7", "B25EE056_Q7", "B25DS008_q7", "B25EE033.q7", "B25ME047_Q7", "B25EE036_q7", "B25EC027_q7", "B25EE052_q7", "B25EC020_Q7", "B25ME032_q7", "B25DS014_q7", "B25EE044_q7", "B25EE025_q7", "B25ME060_q7", "B25MT027_q7", "B25MM017.q7", "B25MT005_q7", "B25DS022_Q7", "B25DS018_q7", "B25EC026_q7", "B25ME045_q7", "B25CS035_q7", "B25ME048_q7", "B25MT003_q7", "B25EE037_q7", "B25EE031_q7", "B25DS004_q7", "B25EC003_Q7", "B25MM006_q7", "B25MM007_q7", "B25EC033_q7", "B25MT024_q7", "B25EC002_q7", "B25ME050_q7", "B25ME012_q7", "B25DS016_q7", "B25ME022_q7(P5,6)", "B25EC039_q7", "B25EC022_q7", "B25ME028_q7.py", "B25MT020_Q7", "B25EC021_q7", "B25MT018_q7", "B25CS037_q7", "B25EC008_ q7", "B25EE034_q7", "B25MT002_q7", "B25CS010_q7", "B25DS024_Q7", "B25DS007_q7", "(B25DS042)_(Q7)", "B25EC013_q7", "B25MT017_q7", "q7(B25MM016)", "B25CS023_q7", "B25ME014_q7.py", "B25ME001_q7", "B25ME030 Q7", "B25DS040_q7", "B25MT014_q7", "B25DS012_q7", "B25MT016_q7", "B25MMO14_q7", "B25ME018_q7", "B25EC042_q7", "B25ME008_Q7", "B25EC007_q7", "B25CS016_q7", "B25MM002 q7", "B25MM025_q7", "B25ME027_q7", "B25MM013_q7", "B25DS027_q7", "B25MM004_q7", "B25MT008_q7", "B25MM028_q7", "B25EE015_Q7", "B25EE020_q7", "B25ME010_q7", "B25EE027_Q7", "B25EC031_q7", "B25CS014_q7", "B25EE058_q7", "B25ME059_q7", "B25MT022_q7", "<B25CS024>_Q7", "B25ME019_q7", "B25DS017_q7", "B25DS025_q7", "MandeepRewar_B25DS021_q7", "B25ME009_q7", "B25EC045_q7", "B25ME021_Q7", "q7_B25ME046", "B25CS004_q7", "B25MM009 Q7", "B25DS030_q7", "<B25DS005>_q7", "B25EC017_q7", "B25ME007_q7", "B25MT023<Q7>", "B25CS041_q7", "B25EE042_q7", "B25CS020_q7", "B25ME029_q7", "B25MM026_q7", "B25DS006_q7", "B25CS062_q7", "B25DS026.q7", "B25DS023_q7", "B25EE049_Q7", "B25DS015_q7", "B25mm015_q7", "B25EE060_q7", "B25MT032_q7", "shourya_q7", "B25mm018_Q7", "B25CS008_Q7", "B25MM021_q7", "B25ME051_Q7", "B25ME002_q7", "B25EE017_q7", "B25DS043_q7", "B25EE029_q7", "B25MT010_q7", "B25ME037_Q7", "B25DS035_q7", "B25DS041_q7", "B25EE051_q7", "B25EE026_Q7", "B25EE050_q7", "B25DS032_q7", "B25CS019_q7", "B25MT009_Q7", "B25EC015.q7", "B25CS055_q7", "S25MA018_q7", "B25CS022_q7", "B25CS060_q7", "B25EE023_q7", "B25ME013_q7", "B25DS001_q7", "B25ME006_q7", "B25CS009_q7", "B25DS010_Q7", "B25MT029_Q7", "B25EC043_q7", "B25EE053_q7", "B25CS054_q7", "B25EE057_q7", "B25EC038_q7.py", "B25CS033_q7", "B25EE022_q7", "B25ME026_q7", "<B25CS036>__q7", "B25CS056_q7", "B25MT007_q7", "B25ME035_q7", "B25DS028_q7", "B25MT015_q7", "B25EE001_q7", "B25MM020_q7", "B25CS044_Q7", "B25EC001_q7", "B25CS011_q7", "B25EE013_q7", "B25MT031_q7", "B25EE055_q7", "B25CS051_q7", "B25MT006_q7", "B25EC006_q7", "B25CS034_q7", "(q7)B25ME017", "B25EE035.Q7", "B25CS025_q7", "B25EC018_q7", "B25cs005_q7", "B25DS034_q7", "B25CS039_q7", "B25ME043_q7", "B24MT001_Q7", "B25EE045_q7", "B25ME054_q7", "B25ME034_q7", "B25EC024_q7", "B25EC034_q7", "B25EE006 Q7", "B25EC_q7", "B25ME049_q7", "B25EC029.q7", "B25ME056_q7", "B25EE054_q7", "B25ME003_q7", "B25EC030_q7", "B25MT021_q7", "B25MM027_q7", "B25EC044_Q7", "B25ME033_Q7", "B25EE007_q7", "B25DS039_Q7", "B25EC010_Q7", "S25MA001_q7", "B25EE003.q7", "B25EE043_q7", "B25ME011_q7", "b25me039_q7", "B25EE018_q7", "B25CS059_q7", "B25CS047_q7", "B25EE004_q7"];
  let searchTraceIndex = null;

  function updateSearch(query) {
    // remove prior search trace
    if (searchTraceIndex !== null && gd.data && gd.data[searchTraceIndex]) {
      Plotly.deleteTraces(gd, searchTraceIndex);
      searchTraceIndex = null;
    }
    query = (query || "").toLowerCase().trim();
    if (!query) return;
    const hits = [];
    for (let i=0; i<ids.length; i++) {
      if ((ids[i] || "").toLowerCase().includes(query)) {
        hits.push(i);
      }
    }
    if (!hits.length) return;
    const trace = {
      x: hits.map(i => xs[i]),
      y: hits.map(i => ys[i]),
      mode: 'markers+text',
      text: hits.map(i => ids[i]),
      textposition: 'top center',
      marker: {
        symbol: 'star',
        size: 20,
        color: 'rgba(0,0,0,0)',
        line: { color: 'red', width: 3 }
      },
      name: 'Search',
      hoverinfo: 'skip'
    };
    Plotly.addTraces(gd, [trace]).then(idxs => {
      searchTraceIndex = idxs[0];
    });
  }

  function initControls() {
    const input = document.getElementById('searchBox');
    const btn = document.getElementById('searchBtn');
    if (!input || !btn) return;

    // Click button triggers search
    btn.addEventListener('click', () => updateSearch(input.value));

    // Pressing Enter in input triggers search
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        btn.click();
      }
    });
  }

  // Wait until Plotly figure is ready, then init controls
  if (gd) {
    if (gd._fullLayout) {
      initControls();
    } else {
      gd.addEventListener('plotly_afterplot', initControls, { once: true });
    }
  }
})();
</script>
</body></html>
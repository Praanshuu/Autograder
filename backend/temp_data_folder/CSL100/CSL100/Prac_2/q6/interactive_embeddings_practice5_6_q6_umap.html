<!DOCTYPE html><html><head><meta charset='utf-8'><title>practice5_6_q6 Embeddings</title></head><body>
<div style="margin: 8px 0; display:flex; gap:12px; align-items:center; flex-wrap: wrap;">
  <label><b>Search Roll No:</b></label>
  <input id="searchBox" type="text" placeholder="e.g., B25DS024" style="padding:6px 8px; width:220px;">
  <button id="searchBtn" style="padding:6px 12px; cursor:pointer;">Search</button>
  <span style="color:#666;">(Click Search to highlight matches on the plot)</span>
</div>
<div>                        <script type="text/javascript">window.PlotlyConfig = {MathJaxConfig: 'local'};</script>
        <script charset="utf-8" src="https://cdn.plot.ly/plotly-3.0.1.min.js" integrity="sha256-oy6Be7Eh6eiQFs5M7oXuPxxm9qbJXEtTpfSI93dW16Q=" crossorigin="anonymous"></script>                <div id="plot_practice5_6_q6" class="plotly-graph-div" style="height:100%; width:100%;"></div>            <script type="text/javascript">                window.PLOTLYENV=window.PLOTLYENV || {};                                if (document.getElementById("plot_practice5_6_q6")) {                    Plotly.newPlot(                        "plot_practice5_6_q6",                        [{"customdata":[["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    \u003cbr\u003e    def helper(item):\u003cbr\u003e        nonlocal total\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            total += item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            for sub in item:\u003cbr\u003e                helper(sub)\u003cbr\u003e        else:\u003cbr\u003e            raise TypeError(f\"Unsupported type: {type(item)}\")\u003cbr\u003e    \u003cbr\u003e    for arg in args:\u003cbr\u003e        helper(arg)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    s=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i) in (int,float):\u003cbr\u003e            s+=i\u003cbr\u003e        else:\u003cbr\u003e            s+=smart_sum(*i) \u003cbr\u003e    return s\u003cbr\u003e\u003cbr\u003e#Test Cases:\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6))) # 21\u003cbr\u003eprint(smart_sum(10)) # 10\u003cbr\u003eprint(smart_sum([1, [2, 3]])) # 6","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e       Sum all numeric inputs, including numbers contained inside lists\u003cbr\u003ethemselves may be nested arbitrarily). Non-numeric values are not\u003cbr\u003eReturn the sum as an int or float.\u003cbr\u003e                                  \"\"\"\u003cbr\u003e    \u003cbr\u003e    s = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if isinstance(arg,list):\u003cbr\u003e            for nums in arg:\u003cbr\u003e                if isinstance(nums,list):\u003cbr\u003e                    for num in nums:\u003cbr\u003e                        s += num\u003cbr\u003e                else:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int:\u003cbr\u003e            sum+=i\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            sum+=smart_sum(*i)\u003cbr\u003e        if type(i)==tuple:\u003cbr\u003e            sum+=smart_sum(*i)\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if isinstance(arg, (int, float)):\u003cbr\u003e            total += arg\u003cbr\u003e        elif isinstance(arg, (list, tuple)):\u003cbr\u003e            total += smart_sum(*arg)\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*inputs):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside lists or tuples\u003cbr\u003e    (which themselves may be nested arbitrarily).\u003cbr\u003e    Non-numeric values are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    result = 0\u003cbr\u003e    for item in inputs:\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            result += item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            nested_sum = smart_sum(*item)\u003cbr\u003e            result += nested_sum\u003cbr\u003e    return result","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    def helper(x):\u003cbr\u003e        if isinstance(x, (int, float)):\u003cbr\u003e            return x\u003cbr\u003e        if isinstance(x, (list, tuple)):\u003cbr\u003e            return sum(helper(i) for i in x)\u003cbr\u003e        return 0\u003cbr\u003e    return sum(helper(a) for a in args)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    s=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==list or type(i)==tuple:\u003cbr\u003e            for j in i:\u003cbr\u003e                s+=j\u003cbr\u003e        else:\u003cbr\u003e            s+=i\u003cbr\u003e    return s","analysis.embedding.code_embedding"],["def smart_sum(args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    sum all nueric inputs , including numbers containes inside lists\u003cbr\u003e    \u003cbr\u003e    \"\"\"\u003cbr\u003e    if isinstance(args,int):\u003cbr\u003e        return args\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i,(list,tuple)):\u003cbr\u003e            sum=sum + smart_sum(i)\u003cbr\u003e        else:\u003cbr\u003e            sum=sum+i\u003cbr\u003e    return sum\u003cbr\u003eprint(smart_sum((1,2,[3,4],(5,6))))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e \u003cbr\u003e  total = 0\u003cbr\u003e  \u003cbr\u003e  \u003cbr\u003e  for item in args:\u003cbr\u003e    # Check if the item is a list or a tuple\u003cbr\u003e    if isinstance(item, (list, tuple)):\u003cbr\u003e      \u003cbr\u003e      total += smart_sum(*item)\u003cbr\u003e    else:\u003cbr\u003e      # This is the base case: if the item is just a number, add it.\u003cbr\u003e      total += item\u003cbr\u003e      \u003cbr\u003e  return total","analysis.embedding.code_embedding"],["def smart_sum(args):\u003cbr\u003e    n = args\u003cbr\u003e    \u003cbr\u003e    if len(n) == 1 :   #single obj then take out 0 index obj to get output in int\u003cbr\u003e        sum = n[0]\u003cbr\u003e    else:\u003cbr\u003e        \u003cbr\u003e        for i in range (0 , len(n)):\u003cbr\u003e            sum = 0\u003cbr\u003e            if not  isinstance(n[i],list):\u003cbr\u003e                if not isinstance(n[i],tuple):  # if obj at index i is not list or tuple then obj can be added to sum \u003cbr\u003e                    a = (str(n[i]))\u003cbr\u003e                    b =int(a)\u003cbr\u003e                    sum = sum + b\u003cbr\u003e                else:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\u003cbr\u003e\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside lists or tuples\u003cbr\u003e    (which themselves may be nested arbitrarily). Non-numeric values are not\u003cbr\u003e    expected. Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    total = 0\u003cbr\u003e    for item in args:\u003cbr\u003e        if isinstance(item, (list, tuple)):\u003cbr\u003e            # If the item is a list or tuple, recursively call smart_sum\u003cbr\u003e            # on its elements by unpacking them.\u003cbr\u003e            total += smart_sum(*item)\u003cbr\u003e        elif isinstance(item, (int, float)):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for y in args:\u003cbr\u003e        if type(y) in [int,float]:\u003cbr\u003e            total=total+y\u003cbr\u003e        elif type(y) in [list,tuple]:\u003cbr\u003e            total=total+smart_sum(*y)\u003cbr\u003e    return total\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in range(len(args)):\u003cbr\u003e        if isinstance(args[i],(list,tuple)):\u003cbr\u003e            sum+=smart_sum(*args[i])\u003cbr\u003e        else:\u003cbr\u003e            sum+=args[i]\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def check_and_add(q):\u003cbr\u003e    sum_partial=0\u003cbr\u003e    for i in q:\u003cbr\u003e        if type(i)==int or type(i)==float:\u003cbr\u003e            sum_partial+=i\u003cbr\u003e        elif type(i)==list or type(i)==tuple:\u003cbr\u003e            sum_partial+=check_and_add(i)\u003cbr\u003e    return sum_partial\u003cbr\u003edef smart_sum(p,*args):\u003cbr\u003e    if type(p)==int or type(p)==float:\u003cbr\u003e            sum_final=p\u003cbr\u003e    elif type(p)==list or type(p)==tuple:\u003cbr\u003e            sum_final=check_and_add(p)\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int or type(i)==float:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["#B25CS044_Q6\u003cbr\u003e#Sum all numeric inputs, including numbers contained inside liststhemselves may be nested arbitrarily\u003cbr\u003e\u003cbr\u003eargs=eval(input('Enter the data to be summed: '))\u003cbr\u003e\u003cbr\u003edef smart_sum(args):\u003cbr\u003e    tot=0   #Defining variable to add individual sums of numbers or elements in a list or tuple\u003cbr\u003e    \u003cbr\u003e    def _sum(item):\u003cbr\u003e        total=0\u003cbr\u003e        \u003cbr\u003e        if type(item)==int or type(item)==float:    #Checking for numbers\u003cbr\u003e            total+=item\u003cbr\u003e        elif type(item)==list or type(item)==tuple: #Checking for lists\u003cbr\u003e            for num in item:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    count = 0\u003cbr\u003e    for n in args:\u003cbr\u003e        if (type(n) == int or type(n) == float):\u003cbr\u003e            count = count + n\u003cbr\u003e        elif (type(n) == list or type(n) == tuple):\u003cbr\u003e            count = count + smart_sum(*n)\u003cbr\u003e    return count","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for x in args :\u003cbr\u003e         if type(x) in (int,float):\u003cbr\u003e             total=total+x\u003cbr\u003e         elif type(x) in (tuple,list):\u003cbr\u003e             total=total+smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["m=list(eval(input(\"enter the elements\")))\u003cbr\u003edef smart_sum(m):\u003cbr\u003e    s=0\u003cbr\u003e    for i in m:\u003cbr\u003e        if isinstance(i,list)==True:\u003cbr\u003e            s=s+sum(i)\u003cbr\u003e        elif isinstance(i,tuple)==True:\u003cbr\u003e             s=s+sum(i)\u003cbr\u003e        else:\u003cbr\u003e            s=s+i\u003cbr\u003e    return s\u003cbr\u003eq=smart_sum(m)\u003cbr\u003eprint(q)\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for sep_arg in args:\u003cbr\u003e        if type(sep_arg)!=int:\u003cbr\u003e         for i in range(len(sep_arg)):\u003cbr\u003e            sum+=sep_arg[i]\u003cbr\u003e        else:\u003cbr\u003e            sum+=sep_arg\u003cbr\u003e    return sum\u003cbr\u003e  \u003cbr\u003eprint(smart_sum(1,2,[3,4],[5,6]))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum(1,[2,3]))","analysis.embedding.code_embedding"],["#Smart Sum\u003cbr\u003e\u003cbr\u003edef sort_out(items):                    #Helper function to sort out the nessted lists\u002f tuples and collect all numbers.\u003cbr\u003e    sort = []\u003cbr\u003e    for i in items:\u003cbr\u003e        if isinstance(i, (int, float)): \u003cbr\u003e            sort.append(i)              # add one item\u003cbr\u003e        elif isinstance(i, (list, tuple)):\u003cbr\u003e            sort.extend(sort_out(i))    # rescursive call, extend(): add all items from an iterable\u003cbr\u003e    return sort\u003cbr\u003e\u003cbr\u003edef smart_sum(*args):                   # * is used to collect multiple arguments in a single variable\u003cbr\u003e    sorted_list = sort_out(args)\u003cbr\u003e    return sum(sorted_list)\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int:\u003cbr\u003e            sum+=i\u003cbr\u003e        else:\u003cbr\u003e            for j in i:\u003cbr\u003e                if type(j)==int:\u003cbr\u003e                    sum+=j\u003cbr\u003e                else:\u003cbr\u003e                    for k in j:\u003cbr\u003e                        sum+=k\u003cbr\u003e    \u003cbr\u003e    return sum\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sums = 0\u003cbr\u003e    def sum_recursive(item):\u003cbr\u003e        nonlocal sums\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            sums = sums + item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            for i in item:\u003cbr\u003e                sum_recursive(i)\u003cbr\u003e    for arg in args:\u003cbr\u003e        sum_recursive(arg)\u003cbr\u003e    print(sums)\u003cbr\u003e    return sums\u003cbr\u003e\u003cbr\u003esmart_sum(1, 2, [3, 4], (5, 6))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int:\u003cbr\u003e            sum+=i\u003cbr\u003e        else:\u003cbr\u003e            for j in i:\u003cbr\u003e                if type(j)==int:\u003cbr\u003e                    sum+=j\u003cbr\u003e                else:\u003cbr\u003e                    for k in j:\u003cbr\u003e                        sum+=k\u003cbr\u003e    \u003cbr\u003e    return sum\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if isinstance(arg, (int, float)):\u003cbr\u003e            total += arg\u003cbr\u003e        elif isinstance( arg, (list, tuple)):\u003cbr\u003e            total += smart_sum(*arg)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum([1, [2, 3]]))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if isinstance(arg, (list, tuple)):\u003cbr\u003e            total += smart_sum(*arg)  # recursion for nested\u003cbr\u003e        elif isinstance(arg, (int, float)):\u003cbr\u003e            total += arg\u003cbr\u003e        else:\u003cbr\u003e            raise ValueError(f\"Unsupported type: {type(arg)}\")\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e# ðŸ”¹ Example usage\u003cbr\u003eprint(smart_sum(1, 2, 3))                         # 6\u003cbr\u003eprint(smart_sum([1, 2, 3], (4, 5)))               # 15\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \u003cbr\u003e    total = 0\u003cbr\u003e\u003cbr\u003e    for item in args:\u003cbr\u003e        if isinstance(item, (int, float)): \u003cbr\u003e            total += item\u003cbr\u003e        elif isinstance(item, (list, tuple)):  \u003cbr\u003e            total += smart_sum(*item)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which themselves may be nested arbitrarily).\u003cbr\u003e    Non-numeric values are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    total = 0\u003cbr\u003e    for x in args:\u003cbr\u003e        if type(x) in (int, float):        \u003cbr\u003e            total += x #checking the int or float part and adding them first\u003cbr\u003e        if type(x) in (list, tuple):      \u003cbr\u003e            total += smart_sum(*x) #checking the inner lists and tuples and adding them\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) == int or type(arg) == float:   \u003cbr\u003e            total += arg\u003cbr\u003e        elif type(arg) == list or type(arg) == tuple:  \u003cbr\u003e            total += smart_sum(*arg)\u003cbr\u003e        else:   \u003cbr\u003e            total += 0\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["###############################################################################\u003cbr\u003e#NAME: Kammuri Lok Prakash Chowdary\u003cbr\u003e#ID NO: B25EC020\u003cbr\u003e#Discipline: Electronics and Communication Engineering\u003cbr\u003e#institute Name: Indian Institute of Technology Bhilai\u003cbr\u003e#######################################################################################\u003cbr\u003esum=0\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    global sum\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int:\u003cbr\u003e            sum+=i\u003cbr\u003e        else:\u003cbr\u003e            for j in range(len(i)):\u003cbr\u003e                sum+=i[j]\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for item in args:\u003cbr\u003e    \u003cbr\u003e        if isinstance(item,(int,float)):\u003cbr\u003e            total += item\u003cbr\u003e            \u003cbr\u003e        elif isinstance(item,(list,tuple)):\u003cbr\u003e            total += smart_sum(*item)\u003cbr\u003e        \u003cbr\u003e    return total\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003eSum all numeric inputs, including numbers contained inside\u003cbr\u003elists or tuples (which\u003cbr\u003ethemselves may be nested arbitrarily). Non-numeric values\u003cbr\u003eare not expected.\u003cbr\u003eReturn the sum as an int or float.\"\"\"\u003cbr\u003e    total = 0\u003cbr\u003e\u003cbr\u003e    def add_num(num):\u003cbr\u003e        nonlocal total\u003cbr\u003e        if isinstance(num, (list, tuple)):    #If num is a list or tuple, it iterates through its elements and calls add_num recursively.\u003cbr\u003e            for term in num:\u003cbr\u003e                add_num(term)\u003cbr\u003e        elif isinstance(num, (int, float)):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(args):\u003cbr\u003e    sum = 0\u003cbr\u003e    if type(args) == int or type(args) == float:\u003cbr\u003e        sum = args\u003cbr\u003e    else:\u003cbr\u003e        for i in args:\u003cbr\u003e            if type(i) == int or type(i)== float:\u003cbr\u003e                smart_sum(i) == i\u003cbr\u003e                sum+= i\u003cbr\u003e            elif type(i) == tuple or type(i) == list:\u003cbr\u003e                sum += smart_sum(i)\u003cbr\u003e    return sum\u003cbr\u003e        ","analysis.embedding.code_embedding"],["''' if it is a list then we pass the content of the list as arguments to *args to  add the\u003cbr\u003enested lists.'''\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    s = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i) == list or type(i) == tuple:\u003cbr\u003e            s += smart_sum(*i)\u003cbr\u003e        elif type(i) == int or type(i) == float:\u003cbr\u003e            s += i    \u003cbr\u003e    return s","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for x in args:\u003cbr\u003e        if type(x) == int or type(x) == float:   \u003cbr\u003e            total += x\u003cbr\u003e        elif type(x) == list or type(x) == tuple:  \u003cbr\u003e            total += smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(smart_sum(2,45, [4, 9], (9, 0)))   \u003cbr\u003eprint(smart_sum(678))                     \u003cbr\u003eprint(smart_sum([0, [9,4]]))            ","analysis.embedding.code_embedding"],["\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i, (int, float)):        \u003cbr\u003e            total += i\u003cbr\u003e        elif isinstance(i, (list, tuple)):      \u003cbr\u003e            total += smart_sum(*i)              \u003cbr\u003e       \u003cbr\u003e    return total\u003cbr\u003e         \u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e         \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(n):\u003cbr\u003e\ts=0\u003cbr\u003e\tfor digits in n:\u003cbr\u003e\t\tif type(digits)==int:\u003cbr\u003e\t\t\ts+=digits\u003cbr\u003e\t\telif type(digits)==list:\u003cbr\u003e\t\t\ts+=smart_sum(digits)\u003cbr\u003e\t\telif type(digits)==tuple:\u003cbr\u003e\t\t\ts+=smart_sum(digits)\u003cbr\u003e\treturn s","analysis.embedding.code_embedding"],["def smart_sum(*n):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in n:\u003cbr\u003e        if type(i)==list or type(i)==tuple :\u003cbr\u003e             sum=sum+smart_sum(*i)            \u003cbr\u003e#if i is list then again call the function smart_sum\u003cbr\u003e        else:\u003cbr\u003e            sum=sum+i\u003cbr\u003e#sum of digit\u003cbr\u003e            \u003cbr\u003e    return(sum)\u003cbr\u003eprint(smart_sum(1, (5, 6)))\u003cbr\u003e            ","analysis.embedding.code_embedding"],["def smart_sums(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if isinstance(arg, int):\u003cbr\u003e            total += arg\u003cbr\u003e        elif isinstance(arg, (list, tuple)):\u003cbr\u003e            total += smart_sums(*arg)  \u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):             \u003cbr\u003e    def flatten_and_sum(item):       \u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            return item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            return sum(flatten_and_sum(x) for x in item)\u003cbr\u003e        else:\u003cbr\u003e            return 0\u003cbr\u003e\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        total += flatten_and_sum(arg)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum numeric inputs, including numbers in nested lists\u002ftuples.\u003cbr\u003e    \"\"\"\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if isinstance(arg, (list, tuple)):\u003cbr\u003e            total += smart_sum(*arg)\u003cbr\u003e        else:\u003cbr\u003e            total += arg\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(args):\u003cbr\u003e   \"\"\"\u003cbr\u003e   Sum all numeric inputs, including numbers contained inside lists or tuples (which\u003cbr\u003e   themselves may be nested arbitrarily). Non-numeric values are not expected.\u003cbr\u003e   Return the sum as an int or float.\u003cbr\u003e   \"\"\"\u003cbr\u003e   n=len(args)\u003cbr\u003e   s=0\u003cbr\u003e   c=0\u003cbr\u003e   for i in range(0,n):\u003cbr\u003e       a=args[i]\u003cbr\u003e       if type(a)==list or type(a)==tuple or type(a)==set:\u003cbr\u003e           for j in range(0,len(a)):\u003cbr\u003e               b=a[j]\u003cbr\u003e               c+=b \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"Sum all numeric inputs, including numbers contained inside lists\u003cbr\u003e       themselves may be nested arbitrarily). Non-numeric values are not\u003cbr\u003e       Return the sum as an int or float\"\"\"\u003cbr\u003e    sum=0\u003cbr\u003e    for item in args:\u003cbr\u003e        if type(item)==list or type(item)==tuple:\u003cbr\u003e            sum =sum+smart_sum(*item)  #recursive step\u003cbr\u003e        else:\u003cbr\u003e            sum=sum+item\u003cbr\u003e    return(sum)\u003cbr\u003e    \u003cbr\u003eprint(smart_sum(1,2,[3,4],(5,6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum([1,[2,3]]))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i,(int,float)):\u003cbr\u003e            total += i\u003cbr\u003e        elif isinstance(i,(list,tuple)):\u003cbr\u003e            total += smart_sum(*i)\u003cbr\u003e    return total            ","analysis.embedding.code_embedding"],["sum=0\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    global sum\u003cbr\u003e    for item in args:\u003cbr\u003e        if(type(item)==list or type(item)==tuple):\u003cbr\u003e            for i in item:\u003cbr\u003e                smart_sum(i)\u003cbr\u003e        elif(type(item)==int or type(item)==float):\u003cbr\u003e            sum+=item\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["##############################################################################\u003cbr\u003e#Name:Purushotham Partha saradhi\u003cbr\u003e#Id no.:B25EE043\u003cbr\u003e#Discipline:Electrical Engineering\u003cbr\u003e#Institute name:Indian Institute of Technology Bhila\u003cbr\u003e###############################################################################\u003cbr\u003e\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int:\u003cbr\u003e            sum=sum+i\u003cbr\u003e        else:\u003cbr\u003e            for k in range (0,len(i)):\u003cbr\u003e                sum=sum+i[k]\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    Summ=0                                #initialize sum with Zero\u003cbr\u003e    for i in args:                        #accessing each element\u003cbr\u003e        if type(i)==int or type(i)==float:        #if int\u002ffloat then adding it\u003cbr\u003e            Summ+=i\u003cbr\u003e        else:\u003cbr\u003e            Summ+=smart_sum(i)            # if not directly adding then using recursion\u003cbr\u003e    return Summ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    sum=0.0\u003cbr\u003e    \u003cbr\u003e    for argument in args: # goes through all arguments.\u003cbr\u003e        \u003cbr\u003e        if type(argument)==int or  type(argument)==float: # if argument is number, adds it to running sum.\u003cbr\u003e            sum+=argument\u003cbr\u003e        \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for item in args:\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            total += item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            total += smart_sum(*item)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e# testing\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))  # 21\u003cbr\u003eprint(smart_sum(10))                    # 10\u003cbr\u003eprint(smart_sum([1, [2, 3]]))           # 6","analysis.embedding.code_embedding"],["\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    c = 0\u003cbr\u003e    for s in args:\u003cbr\u003e        try:\u003cbr\u003e            a= int(s)\u003cbr\u003e        except TypeError:\u003cbr\u003e            c = c + smart_sum(*s)\u003cbr\u003e        else:\u003cbr\u003e            c = c + s\u003cbr\u003e    return(c)\u003cbr\u003e    \u003cbr\u003et =  smart_sum(1, 2, [3, 4], (5, 6))\u003cbr\u003eprint(t)\u003cbr\u003e        \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    count = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        data_type = type(i)\u003cbr\u003e        if data_type is int or data_type is float:     \u003cbr\u003e            count += i\u003cbr\u003e        if data_type is list or data_type is tuple:      \u003cbr\u003e            count += smart_sum(*i)\u003cbr\u003e    return count\u003cbr\u003e\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum([1, [2, 3]]))\u003cbr\u003e  ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    count  = 0\u003cbr\u003e    for x in range(0,len(args)):\u003cbr\u003e        if type(args[x]) == list or type(args[x]) == tuple:\u003cbr\u003e            for w in args[x]:\u003cbr\u003e             count=count+smart_sum(w)\u003cbr\u003e        elif type(args[x]) == int or type(args[x]) == float:\u003cbr\u003e            count = count + args[x]\u003cbr\u003e    return count\u003cbr\u003e\"\"\"it goes inside,if  it gets a list it goes inside the list and adds the sum using recurison...if its a integer or a float\u003cbr\u003eit directly adds it\"\"\"\u003cbr\u003e        \u003cbr\u003e    ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e \"\"\"\u003cbr\u003e Sum all numeric inputs, including numbers contained inside\u003cbr\u003e lists or tuples (which\u003cbr\u003e themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e are not expected.\u003cbr\u003e Return the sum as an int or float.\u003cbr\u003e \"\"\"\u003cbr\u003e summ = 0\u003cbr\u003e for i in args :\u003cbr\u003e     if isinstance(i , (list,tuple)):\u003cbr\u003e         summ += smart_sum(*i) \u003cbr\u003e        \u003cbr\u003e        \u003cbr\u003e     elif isinstance( i , (int,float)):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    global s\u003cbr\u003e    for i in args:\u003cbr\u003e        try:\u003cbr\u003e            s=s+i\u003cbr\u003e        except:\u003cbr\u003e            smart_sum(*i)\u003cbr\u003e    return s\u003cbr\u003es=0\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))","analysis.embedding.code_embedding"],["#arg=eval(input('Enter an argument: ' ))\u003cbr\u003esum = 0 \u003cbr\u003edef smart_sum(arg):\u003cbr\u003e    global sum\u003cbr\u003e    if type(arg) == int or type(arg) == float:\u003cbr\u003e        sum+=arg\u003cbr\u003e    elif type(arg)==list or type(arg) == tuple:\u003cbr\u003e        for i in arg:\u003cbr\u003e            if type(i) == int:\u003cbr\u003e                sum+=i\u003cbr\u003e            elif type(i) == list:\u003cbr\u003e                sum=smart_sum(i)\u003cbr\u003e            elif type(i) == tuple:\u003cbr\u003e                sum=smart_sum(i)\u003cbr\u003e    return sum\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int:\u003cbr\u003e            sum+=i\u003cbr\u003e        elif type(i)==list:\u003cbr\u003e            for j in i:\u003cbr\u003e                if type(j)==list:\u003cbr\u003e                    for t in j:\u003cbr\u003e                        sum+=t\u003cbr\u003e                else:\u003cbr\u003e                    sum+=j\u003cbr\u003e        elif type(i)==tuple:\u003cbr\u003e            for k in i:\u003cbr\u003e                sum+=k\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sums all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not returned.\u003cbr\u003e    Returns the sum as an int or float\u003cbr\u003e    \"\"\"\u003cbr\u003e    sum = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        k = type(i)\u003cbr\u003e        if k!= type(1) and k!= type(0.5):\u003cbr\u003e            for j in i:\u003cbr\u003e                sum = sum + j        \u003cbr\u003e        else:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int:\u003cbr\u003e            sum+=i\u003cbr\u003e        else:\u003cbr\u003e            sum += smart_sum(*i)\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e\u003cbr\u003e    sum = 0\u003cbr\u003e\u003cbr\u003e    for i in args:  # loop runs for each value of args\u003cbr\u003e\u003cbr\u003e        # elements of the args is list or tuple the calls itself recursively and passes the element as args\u003cbr\u003e        if type(i)==list or type(i)==tuple: \u003cbr\u003e\u003cbr\u003e            sum += smart_sum(*i)  # the function returns the smart sum of the elements (list or tuple) which gets added to the sum \u003cbr\u003e\u003cbr\u003e        else:\u003cbr\u003e            \u003cbr\u003e            sum += i  # if element in args is integer or float it is directly added to the sum\u003cbr\u003e    \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside lists or tuples(which\u003cbr\u003e    themselves may be nested arbbitrarily ).\u003cbr\u003e    Non-numeric values are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    def sum_nums(nums):\u003cbr\u003e        s = 0\u003cbr\u003e        if type(nums) in (int, float):\u003cbr\u003e            s += nums\u003cbr\u003e        elif type(nums) in (list, tuple):\u003cbr\u003e            for a in nums:\u003cbr\u003e                s += sum_nums(a)\u003cbr\u003e        return s\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    t = 0\u003cbr\u003e    \u003cbr\u003e    for item in args:\u003cbr\u003e        if type(item) == int or type(item) == float:\u003cbr\u003e            t += item\u003cbr\u003e        elif type(item) == list or type(item) == tuple:\u003cbr\u003e            t += smart_sum(*item)\u003cbr\u003e    \u003cbr\u003e    return t","analysis.embedding.code_embedding"],["\u003cbr\u003e\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside lists or tuples\u003cbr\u003e    (which themselves may be nested arbitrarily). Non-numeric values are not\u003cbr\u003e    expected. Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    total = 0\u003cbr\u003e    for item in args:\u003cbr\u003e        if isinstance(item, (list, tuple)):\u003cbr\u003e            # If the item is a list or tuple, recursively call smart_sum\u003cbr\u003e            # on its elements by unpacking them.\u003cbr\u003e            total += smart_sum(*item)\u003cbr\u003e        elif isinstance(item, (int, float)):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e    for num in args:\u003cbr\u003e        if type(num) == int or type(num) == float:\u003cbr\u003e           sum = sum + num\u003cbr\u003e        elif type(num) == list or type(num) == tuple:\u003cbr\u003e            sum = sum + smart_sum(*num)\u003cbr\u003e        \u003cbr\u003e    return sum\u003cbr\u003e        \u003cbr\u003eprint(smart_sum(1,2,[3,4],(5,6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum(1,[2, 3]))\u003cbr\u003e            ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg)==int or type(arg)==float:\u003cbr\u003e            sum=sum+arg\u003cbr\u003e        elif type(arg)==list or type(arg)==tuple:\u003cbr\u003e            for i in arg:\u003cbr\u003e                if type(i)==int or type(i)==float:\u003cbr\u003e                    sum=sum+i\u003cbr\u003e                else:\u003cbr\u003e                    for j in i:\u003cbr\u003e                        sum=sum+j\u003cbr\u003e        else:\u003cbr\u003e            continue\u003cbr\u003e    return sum\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*elements):\u003cbr\u003e    sum=0\u003cbr\u003e    def give_until_number(j):\u003cbr\u003e        sum=0\u003cbr\u003e        if(type(j)==list or type(j)==tuple):\u003cbr\u003e            for i in j:\u003cbr\u003e                if(type(i)==list or type(i)==tuple):\u003cbr\u003e                   sum=give_until_number(i)+sum\u003cbr\u003e                if(type(i)==int or type(i)==float):\u003cbr\u003e                    sum=sum+i\u003cbr\u003e        return sum\u003cbr\u003e    for i in elements:\u003cbr\u003e        if(type(i)==list or type(i)==tuple):\u003cbr\u003e            sum=sum+give_until_number(i)\u003cbr\u003e        if(type(i)==int or type(i)==float):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\u003cbr\u003et =0\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    global t\u003cbr\u003e    for p in args:\u003cbr\u003e        if type(p) == list or type(p)==tuple or type(p)==set:\u003cbr\u003e            smart_sum(*p)\u003cbr\u003e        else : t += p\u003cbr\u003e    return t\u003cbr\u003e\u003cbr\u003e# print(smart_sum([1, [2, 3], 5]))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum numeric inputs, including numbers in nested lists\u002ftuples.\u003cbr\u003e    \"\"\"\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if isinstance(arg, (list, tuple)):\u003cbr\u003e            total += smart_sum(*arg)\u003cbr\u003e        else:\u003cbr\u003e            total += arg\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for x in args :\u003cbr\u003e         if type(x) in (int,float):\u003cbr\u003e             total=total+x\u003cbr\u003e         elif type(x) in (tuple,list):\u003cbr\u003e             total=total+smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    def recur_sum(x):\u003cbr\u003e        if isinstance(x, (int, float)):\u003cbr\u003e            return x\u003cbr\u003e        elif isinstance(x, (list, tuple)):\u003cbr\u003e            return sum(recur_sum(i) for i in x)\u003cbr\u003e        else:\u003cbr\u003e            return 0\u003cbr\u003e    return sum(recur_sum(arg) for arg in args)\u003cbr\u003eprint(smart_sum(1,2,[3,4]))\u003cbr\u003e\u003cbr\u003e    \u003cbr\u003e    ","analysis.embedding.code_embedding"],["\u003cbr\u003e\"\"\"\u003cbr\u003eSum all numeric inputs, including numbers contained inside\u003cbr\u003elists or tuples (which\u003cbr\u003ethemselves may be nested arbitrarily). Non-numeric values\u003cbr\u003eare not expected.\u003cbr\u003eReturn the sum as an int or float.\u003cbr\u003e\"\"\"\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    if type(args)==int:\u003cbr\u003e        return args\u003cbr\u003e    if isinstance(args,(list,tuple)):\u003cbr\u003e        sum=0\u003cbr\u003e        for item in args:\u003cbr\u003e            if isinstance(item,(int,float)):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) == int or type(arg) == float:   \u003cbr\u003e            total += arg\u003cbr\u003e        elif type(arg) == list or type(arg) == tuple:  \u003cbr\u003e            total += smart_sum(*arg)\u003cbr\u003e        else:   \u003cbr\u003e            total += 0\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    \u003cbr\u003e    for item in args:\u003cbr\u003e        try:\u003cbr\u003e            # Try to treat item as a number\u003cbr\u003e            total += item\u003cbr\u003e        except TypeError:\u003cbr\u003e            # If it's not directly a number, check if it's a list or tuple\u003cbr\u003e            try:\u003cbr\u003e                for elem in item:\u003cbr\u003e                    total += smart_sum(elem)\u003cbr\u003e            except TypeError:\u003cbr\u003e                # If it's neither a number nor iterable, ignore it\u003cbr\u003e                pass\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int or type(i)==float:\u003cbr\u003e            total +=i\u003cbr\u003e        elif type(i) == list or type(i)==tuple:\u003cbr\u003e              total += smart_sum(*i)\u003cbr\u003e        return total   \u003cbr\u003e       \u003cbr\u003eprint(smart_sum(1,2,[3,4],(5,6)))     \u003cbr\u003eprint(smart_sum(10))  \u003cbr\u003eprint(smart_sum([1,[2,3]]))     \u003cbr\u003e    \u003cbr\u003e    ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) in [int, float]:\u003cbr\u003e            total= total+arg\u003cbr\u003e        else:  \u003cbr\u003e            total= total+smart_sum(*arg)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    s=0\u003cbr\u003e    for k in args:\u003cbr\u003e        if type(k)==list or type(k)==tuple:\u003cbr\u003e            s +=smart_sum(*k)\u003cbr\u003e        else:\u003cbr\u003e            s += k\u003cbr\u003e    return s\u003cbr\u003e    \u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    def ltd(n): # list tuple and directry\u003cbr\u003e        t = type(n)\u003cbr\u003e        if t is list or t is tuple:\u003cbr\u003e            total = 0\u003cbr\u003e            for x in n:\u003cbr\u003e                total += ltd(x)   # recursive call\u003cbr\u003e            return total\u003cbr\u003e        else:\u003cbr\u003e            return n\u003cbr\u003e\u003cbr\u003e    total = 0\u003cbr\u003e    for item in args:\u003cbr\u003e        total += ltd(item)\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)in [int,float]: #add if integer or float \u003cbr\u003e            sum=sum+i\u003cbr\u003e        elif type(i) in [tuple,list]:      #iterate if list or tuple\u003cbr\u003e            for j in i:\u003cbr\u003e                sum=sum+smart_sum(j)        #adding and using reccursion to check more nested lists\u003cbr\u003e    return sum\u003cbr\u003e","analysis.embedding.code_embedding"],["\"\"\"\u003cbr\u003eSum all numeric inputs, including numbers contained inside\u003cbr\u003elists or tuples (which\u003cbr\u003ethemselves may be nested arbitrarily). Non-numeric values\u003cbr\u003eare not expected.\u003cbr\u003eReturn the sum as an int or float.\u003cbr\u003e\"\"\"\u003cbr\u003e\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    def ltd(n):\u003cbr\u003e        l = 0\u003cbr\u003e        t =type(n)\u003cbr\u003e        if t is list:\u003cbr\u003e            for i in range(len(n)):\u003cbr\u003e                l += n[i]\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    ans=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i,int) or isinstance(i,float):\u003cbr\u003e            ans+=i\u003cbr\u003e        else:\u003cbr\u003e            ans+=smart_sum(*i)\u003cbr\u003e    return ans\u003cbr\u003esmart_sum(1, 2, [3, 4], (5, 6)) # 21\u003cbr\u003esmart_sum(10) # 10\u003cbr\u003esmart_sum([1, [2, 3]]) # 6","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    \u003cbr\u003e    for item in args:\u003cbr\u003e        if type(item) == int or type(item) == float:\u003cbr\u003e            total = total + item\u003cbr\u003e        elif type(item) == list or type(item) == tuple:\u003cbr\u003e            for element in item:\u003cbr\u003e                if type(element) == list or type(element) == tuple:\u003cbr\u003e                    for nested_element in element:\u003cbr\u003e                        if type(nested_element) == list or type(nested_element) == tuple:\u003cbr\u003e                            for deep_element in nested_element:\u003cbr\u003e                                if type(deep_element) == int or type(deep_element) == float:\u003cbr\u003e                                    total = total + deep_element\u003cbr\u003e                        else:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    ''' Sum all numeric inputs,including no.s in contained inside lists or tuples(which themselves may be nested arbitrarily). Non - numeric are not expected.\u003cbr\u003e        returns the sums as int or float'''\u003cbr\u003e    sum=0\u003cbr\u003e    for item in args:\u003cbr\u003e        if type(item)==list:\u003cbr\u003e            for x in item:\u003cbr\u003e                sum+=x\u003cbr\u003e        elif type(item)==tuple:\u003cbr\u003e            for x in item:\u003cbr\u003e                sum+=x\u003cbr\u003e        else:\u003cbr\u003e            sum +=item\u003cbr\u003e    return sum\u003cbr\u003eprint(smart_sum(37,34))      \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which themselves may be nested arbitrarily).\u003cbr\u003e    Non-numeric values are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    total = 0\u003cbr\u003e    for item in args:\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            total += item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            total += smart_sum(*item)  # Unpack and recurse\u003cbr\u003e    return total\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))  ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e\tsum=0\u003cbr\u003e\tfor i in args:\u003cbr\u003e\t\tif type(i) in [list,tuple]:\u003cbr\u003e\t\t\tsum+=smart_sum(*i)\u003cbr\u003e\t\t\t\t\u003cbr\u003e\t\telse:\u003cbr\u003e\t\t\tsum+=i\u003cbr\u003e\t\t\t\u003cbr\u003e\treturn sum\u003cbr\u003e\u003cbr\u003e#test cases\u003cbr\u003eprint(smart_sum(1, 2,[3,4],(5, 6)))\u003cbr\u003eprint(smart_sum([1, [2, 3]]))\t\u003cbr\u003eprint(smart_sum(10))","analysis.embedding.code_embedding"],["data = [1, [2, 3], (4, 5)]\u003cbr\u003e\u003cbr\u003edef calc(x):\u003cbr\u003e    total = 0\u003cbr\u003e    for i in x:\u003cbr\u003e        if isinstance(i, (int, float)):\u003cbr\u003e            total += i\u003cbr\u003e        elif isinstance(i, (list, tuple)):\u003cbr\u003e            total += calc(i)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003eprint(calc(data))","analysis.embedding.code_embedding"],["def smart_sum(*args): \u003cbr\u003e\t\"\"\" sum all numeric inputs, including numbers contained inside lists or tuples (which themselves may be nested arbitrarily). Non-numeric values are not expected. Return the total as an int or float. \"\"\"\u003cbr\u003e\ttotal = 0\u003cbr\u003e\t\u003cbr\u003e\tfor element in args:\u003cbr\u003e\t\tif isinstance(element, (int, float)):\u003cbr\u003e\t\t\ttotal += element\u003cbr\u003e\t\t\u003cbr\u003e\t\telif isinstance(element, (list, tuple)):\u003cbr\u003e\t\t\tfor i in element:\u003cbr\u003e\t\t\t\ttotal += smart_sum(i)\u003cbr\u003e\t\t\u003cbr\u003e\treturn total\u003cbr\u003e\t\u003cbr\u003eprint(smart_sum(1, [8,5], (1,5,9),5))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        \u003cbr\u003e        if isinstance(i,(int,float)):\u003cbr\u003e            sum+=i\u003cbr\u003e        elif isinstance(i,(list, tuple)):\u003cbr\u003e            sum+= smart_sum(*i)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including nested lists\u002ftuples.\u003cbr\u003e    \"\"\"\u003cbr\u003e    def flatten_sum(item):\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            return item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            return sum(flatten_sum(sub) for sub in item)\u003cbr\u003e        return 0  # Should not occur if input is valid\u003cbr\u003e\u003cbr\u003e    return sum(flatten_sum(arg) for arg in args)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    sum = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i, (int, float)):\u003cbr\u003e            sum += i\u003cbr\u003e        else:\u003cbr\u003e            sum += smart_sum(*i)\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["#########################################################################################\u003cbr\u003e#KOYYA SUMANTH BABU\u003cbr\u003e#B25EC022\u003cbr\u003e#ELECTRONICS AND COMMUNICATION ENGINEERING\u003cbr\u003e#INDIAN INSTITUTE OF TECHNOLOGY BHILAI\u003cbr\u003e#########################################################################################\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for item in args:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    cnt=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i) in (int, float):\u003cbr\u003e            cnt += i\u003cbr\u003e        if type(i) in (list, tuple):\u003cbr\u003e            cnt += smart_sum(i)\u003cbr\u003e        \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int:\u003cbr\u003e            sum+=i\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            sum+=smart_sum(*i)\u003cbr\u003e        if type(i)==tuple:\u003cbr\u003e            sum+=smart_sum(*i)\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    items = list(args)\u003cbr\u003e    total_sum = 0\u003cbr\u003e    while items:\u003cbr\u003e        current_item = items.pop()\u003cbr\u003e        itemType = type(current_item)\u003cbr\u003e        if itemType == int or itemType == float:\u003cbr\u003e            total_sum += current_item\u003cbr\u003e        elif itemType == list or itemType == tuple:\u003cbr\u003e            items.extend(current_item)\u003cbr\u003e\u003cbr\u003e    return total_sum\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    summ = 0\u003cbr\u003e    for element in args:\u003cbr\u003e        # If the element is a list or tuple, call smart_sum recursively\u003cbr\u003e        if type(element) == list or type(element) == tuple:\u003cbr\u003e            summ = summ + smart_sum(*element)\u003cbr\u003e        else:\u003cbr\u003e            summ = summ + element\u003cbr\u003e\u003cbr\u003e    return summ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for num in args:\u003cbr\u003e        if type(num)==int or type(num)==float:\u003cbr\u003e            total=total+num\u003cbr\u003e           \u003cbr\u003e        elif type(num)==list or type(num)==tuple:\u003cbr\u003e            total=total+smart_sum(*num)\u003cbr\u003e            \u003cbr\u003e    return total\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003eprint(smart_sum(1,2,[3,4],(5,6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum(1,[2,3]))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if(isinstance(i,(tuple,list))):\u003cbr\u003e            sum=sum+smart_sum(*i) #will keep calling the function and add the characters of list and tuples and then to final sum\u003cbr\u003e        elif(isinstance(i,(int,float))): #will directly add numbers\u003cbr\u003e             sum=sum+i\u003cbr\u003e    return(sum)    \u003cbr\u003e      \u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum([1,[2,3]]))","analysis.embedding.code_embedding"],["def smart_sum(data):\u003cbr\u003e    sum = 0\u003cbr\u003e    for num in data:\u003cbr\u003e        if isinstance(num, (list, tuple)):\u003cbr\u003e            sum += smart_sum(num)  # recursively sum nested list\u002ftuple\u003cbr\u003e        else:\u003cbr\u003e            sum += num  # add the element\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) == int or type(arg) == float:\u003cbr\u003e            total += arg\u003cbr\u003e        elif type(arg) == list or type(arg) == tuple:\u003cbr\u003e\u003cbr\u003e            inner_total = smart_sum(*arg)\u003cbr\u003e            total += inner_total\u003cbr\u003e    return total\u003cbr\u003eprint(smart_sum(1,2,[3,4],(5,6)))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for x in args:\u003cbr\u003e        if type(x) == int or type(x) == float:\u003cbr\u003e            total = total + x\u003cbr\u003e        elif type(x) == list or type(x) == tuple:\u003cbr\u003e            total = total + smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003eprint(smart_sum(1, 2, 3))                  # 6\u003cbr\u003eprint(smart_sum([1, 2, 3], 4))             # 10\u003cbr\u003eprint(smart_sum(1, (2, 3), [4, [5, 6]]))  # 21\u003cbr\u003eprint(smart_sum())                          # 0","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    def addval(x):\u003cbr\u003e        if type(x) == int or type(x) == float:\u003cbr\u003e            return x\u003cbr\u003e        elif type(x) == list or type(x) == tuple:\u003cbr\u003e            s = 0\u003cbr\u003e            for item in x:\u003cbr\u003e                s = s+ addval(item) \u003cbr\u003e        return 0   \u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        total =total+ addval(arg)\u003cbr\u003e    return total\u003cbr\u003eprint(smart_sum(1,2,[3,4],(5,6)))   #21\u003cbr\u003eprint(smart_sum(10))   #10\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    s=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i,(int,float)):\u003cbr\u003e            s+=i\u003cbr\u003e        elif isinstance(i,(list,tuple)):\u003cbr\u003e            s+=smart_sum(*i)\u003cbr\u003e    return s\u003cbr\u003e\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e        ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    s=0\u003cbr\u003e    def helper(item):\u003cbr\u003e        nonlocal s\u003cbr\u003e        if isinstance(item,(int, float)):\u003cbr\u003e            s=s+item\u003cbr\u003e        \u003cbr\u003e         \u003cbr\u003e        elif isinstance(item,(list, tuple)):\u003cbr\u003e                for sub in item:\u003cbr\u003e                    helper(sub)\u003cbr\u003e    for a in args:\u003cbr\u003e        helper(a)\u003cbr\u003e    return s\u003cbr\u003esmart_sum(1,2,[3,4],(5,6))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) == int or type(arg) == float:   \u003cbr\u003e            total += arg\u003cbr\u003e        elif type(arg) == list or type(arg) == tuple:  \u003cbr\u003e            total += smart_sum(*arg)\u003cbr\u003e        else:   \u003cbr\u003e            total += 0\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for x in args:\u003cbr\u003e        if type(x) == int or type(x) == float:   \u003cbr\u003e            total += x\u003cbr\u003e        elif type(x) == list or type(x) == tuple:  \u003cbr\u003e            total += smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))   # 21\u003cbr\u003eprint(smart_sum(10))                     # 10\u003cbr\u003eprint(smart_sum([1, [2, 3]]))            # 6","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e    for value in args:\u003cbr\u003e        if isinstance(value, (int, float)):\u003cbr\u003e            sum += value\u003cbr\u003e        elif isinstance(value, (list, tuple)):\u003cbr\u003e            sum += smart_sum(*value)\u003cbr\u003e    return sum\u003cbr\u003e        \u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum([1, [2, 3]]))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e\u003cbr\u003e        if type(i)==float or type(i)==int:\u003cbr\u003e            sum=sum+i\u003cbr\u003e\u003cbr\u003e        elif type(i)==tuple or type(i)==list:\u003cbr\u003e            sum=sum+smart_sum(*i)\u003cbr\u003e\u003cbr\u003e    return sum\u003cbr\u003e \u003cbr\u003e \u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6))) \u003cbr\u003eprint(smart_sum(10,(1,2))) \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(args):\u003cbr\u003e    sum =0\u003cbr\u003e    for i in args:\u003cbr\u003e        \u003cbr\u003e        if isinstance(i,list):\u003cbr\u003e            a=[]\u003cbr\u003e            a.append(i)\u003cbr\u003e            for i in a :\u003cbr\u003e                b =\",\".join(i)\u003cbr\u003e                list1=[]\u003cbr\u003e                list1.append(b)\u003cbr\u003e            return list1\u003cbr\u003e           \u003cbr\u003e        elif isinstance(i,tuple):\u003cbr\u003e            c=[]\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for x in args:\u003cbr\u003e        if type(x) in (list, tuple):   \u003cbr\u003e            total += smart_sum(*x)     \u003cbr\u003e        else:  \u003cbr\u003e            total += x                 \u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def sum_of_list(lst):\u003cbr\u003e    total = 0\u003cbr\u003e    for num in lst:\u003cbr\u003e        if type(num) in (list, tuple):   #checks if tuple or list present inside list also\u003cbr\u003e            total += smart_sum(num)\u003cbr\u003e        else:\u003cbr\u003e            total += num\u003cbr\u003e    return total\u003cbr\u003e    pass\u003cbr\u003e\u003cbr\u003edef sum_of_tuple(tup):\u003cbr\u003e    total = 0\u003cbr\u003e    for num in tup:\u003cbr\u003e        if type(num) in (list, tuple):      #checks if tuple or list present inside tuple also\u003cbr\u003e            total += smart_sum(num)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smartsum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e\u003cbr\u003e        if type(i)==float or type(i)==int:\u003cbr\u003e            sum=sum+i\u003cbr\u003e\u003cbr\u003e        elif type(i)==tuple or type(i)==list:\u003cbr\u003e            sum=sum+smartsum(*i)\u003cbr\u003e\u003cbr\u003e    return sum\u003cbr\u003e \u003cbr\u003e \u003cbr\u003eprint(smartsum(1, 2, [3, 4], (5, 6))) \u003cbr\u003eprint(smartsum(10,(1,2))) \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for x in args :\u003cbr\u003e         if type(x) in (int,float):\u003cbr\u003e             total=total+x\u003cbr\u003e         elif type(x) in (tuple,list):\u003cbr\u003e             total=total+smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for element in args:\u003cbr\u003e        if isinstance(element, (list, tuple)):\u003cbr\u003e            total += smart_sum(*element)\u003cbr\u003e        elif isinstance(element, (int, float)):\u003cbr\u003e            total += element\u003cbr\u003e    \u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists (lists themselves may be nested arbitrarily).\u003cbr\u003e    Non-numeric values are not added. Return the sum as an int or\u003cbr\u003e    float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    global s\u003cbr\u003e    s=0\u003cbr\u003e    def add(value):\u003cbr\u003e        global s\u003cbr\u003e        ty=type(value)\u003cbr\u003e        if (ty==int or ty==float): #Add number to sum if value is an int or float\u003cbr\u003e            s=s+value\u003cbr\u003e        elif (ty==list or ty==tuple): #If value is a list, check each item in the list\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    '''\u003cbr\u003e    Sum all numeric inputs, including numbers contained\u003cbr\u003e    inside liststhemselves may be nested arbitrarily.\u003cbr\u003e    Non-numeric values are notReturn the sum as an int or float.\u003cbr\u003e    '''\u003cbr\u003e    res = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) == int or type(arg) == float :\u003cbr\u003e            res += arg\u003cbr\u003e        elif type(arg) == list or type(arg) == tuple or type(arg) == set:\u003cbr\u003e            res += smart_sum(*arg)\u003cbr\u003e    return res\u003cbr\u003e\u003cbr\u003e#Test Cases:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    '''\u003cbr\u003e    i first made an empty list and then added the elements given by user inside the new list. then i converted the list into string including all the brackets and comas. then i made another list consisting all the non number elements that the list can have and thus seperated the numbers from the list and then added then using for loop.\u003cbr\u003e    '''\u003cbr\u003e    c=0\u003cbr\u003e    j=0\u003cbr\u003e    y=[]\u003cbr\u003e    y.append(args)\u003cbr\u003e    y=str(y)\u003cbr\u003e    z=[\"[\",\"]\",\",\",\"(\",\")\",\"\",\" \"]\u003cbr\u003e    while(j&lt;len(y)):\u003cbr\u003e        if(y[j] not in z):\u003cbr\u003e            c=c+int(y[j])\u003cbr\u003e        j+=1\u003cbr\u003e    return c","analysis.embedding.code_embedding"],["def recursion(index):\u003cbr\u003e    '''i created a recursion function which will see if an index in the input was a list or a tuple \u003cbr\u003e    if yes i called the recursion function again else i added the sum'''\u003cbr\u003e    totsum = 0\u003cbr\u003e    for i in range(len(index)):\u003cbr\u003e        if type(index[i]) == list or type(index[i]) == tuple:\u003cbr\u003e            totsum=totsum+recursion(index[i])\u003cbr\u003e        else:\u003cbr\u003e            totsum=totsum +index[i]\u003cbr\u003e    return totsum\u003cbr\u003e\u003cbr\u003edef smart_totsum(*args):\u003cbr\u003e    '''here i again used the same logic and calculated the sum'''\u003cbr\u003e    totsum = 0\u003cbr\u003e    for i in args:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e#Sums all numbers, including those nested in lists or tuples.\u003cbr\u003e    total = 0\u003cbr\u003e\u003cbr\u003e    def find_and_add(items):\u003cbr\u003e        nonlocal total\u003cbr\u003e        for item in items:\u003cbr\u003e            if isinstance(item, (int, float)):\u003cbr\u003e                total += item\u003cbr\u003e            elif isinstance(item, (list, tuple)):\u003cbr\u003e                find_and_add(item)\u003cbr\u003e\u003cbr\u003e    find_and_add(args)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    S = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i) == int:\u003cbr\u003e            S = S + 1\u003cbr\u003e        elif type(i) == list or tuple:\u003cbr\u003e            a = sum(i)\u003cbr\u003e            S = S + a\u003cbr\u003e    return S","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for x in args:\u003cbr\u003e        if type(x) in [int,float]:\u003cbr\u003e            total=total+x\u003cbr\u003e        elif type(x) in [list,tuple]:\u003cbr\u003e            total=total+smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(n:list):\u003cbr\u003e    a = list(n)\u003cbr\u003e    b =[]\u003cbr\u003e    for i in range(0,len(a)):\u003cbr\u003e        if len(str(a[i]))==1:\u003cbr\u003e            b.append(a[i])\u003cbr\u003e        else:\u003cbr\u003e            for j in range(0,len(a[i])):\u003cbr\u003e                b.append(a[i][j])\u003cbr\u003e    sum = 0\u003cbr\u003e    for ele in b:\u003cbr\u003e        sum = sum + int(ele)\u003cbr\u003e        \u003cbr\u003e    return sum\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Recursively sum all numeric inputs, including numbers inside lists\u002ftuples (nested arbitrarily).\u003cbr\u003e    \"\"\"\u003cbr\u003e    total = 0\u003cbr\u003e    for item in args:\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            total += item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            total += smart_sum(*item)\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=o\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i,(int,float)):   # to check if i is int float\u003cbr\u003e            sum=sum+i\u003cbr\u003e        elif isinstance(i,(list,tuple)):   # to check if i is tuple or list\u003cbr\u003e            sum=sum+smart_sum(*i)\u003cbr\u003e    return sum\u003cbr\u003e            \u003cbr\u003e            \u003cbr\u003e\u003cbr\u003e         \u003cbr\u003e     \u003cbr\u003e     \u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["#WAP to find smart sum\u003cbr\u003esum=0\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    global sum\u003cbr\u003e    for i in args:\u003cbr\u003e        tp=type(i)#check for data type\u003cbr\u003e        if tp==int or tp==float:#add if int or float\u003cbr\u003e            sum+=i\u003cbr\u003e        elif tp==list or tp==tuple:#go inside in case of list or tuple\u003cbr\u003e            smart_sum(*i)#recursion\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    stack = list(args)\u003cbr\u003e    \u003cbr\u003e    while stack:\u003cbr\u003e        item = stack.pop(0)\u003cbr\u003e        if type(item) == int or type(item) == float:\u003cbr\u003e            total += item\u003cbr\u003e        elif type(item) == list or type(item) == tuple:\u003cbr\u003e            for elem in item:\u003cbr\u003e                stack.append(elem)\u003cbr\u003e    \u003cbr\u003e    return total\u003cbr\u003eprint(smart_sum(1, 2, 3))\u003cbr\u003eprint(smart_sum([1, 2, 3], 4))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(args):\u003cbr\u003e    j = 0\u003cbr\u003e    l = 0\u003cbr\u003e    \u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i) == int:\u003cbr\u003e            j = j + i\u003cbr\u003e        else:\u003cbr\u003e            for k in i:\u003cbr\u003e                l = l + k\u003cbr\u003e        \u003cbr\u003e        \u003cbr\u003e    m = l + j\u003cbr\u003e    return m\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):             #define a function for smart sum\u003cbr\u003e    def flatten_and_sum(item):       #again define a function for flatten and sum of items\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            return item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            return sum(flatten_and_sum(x) for x in item)\u003cbr\u003e        else:\u003cbr\u003e            return 0\u003cbr\u003e\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        total += flatten_and_sum(arg)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside lists themselves may be nested arbitrarily).\u003cbr\u003e    Non-numeric values are not Return the sum as an int or float.\u003cbr\u003e    \"\"\" \u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) in [int, float]:\u003cbr\u003e            total += arg\u003cbr\u003e        elif type(arg) in [list, tuple]:  \u003cbr\u003e            total += smart_sum(*arg)       \u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(* args):\u003cbr\u003e\ttotal = 0\u003cbr\u003e\t\u003cbr\u003e\tfor arg in args:\u003cbr\u003e\t\tif isinstance(arg, (int, float)):\u003cbr\u003e\t\t\ttotal += arg\u003cbr\u003e\t\telif isinstance(arg, (list, tuple)):\u003cbr\u003e\t\t\t\ttotal += smart_sum(*arg)\u003cbr\u003e\t\t\t\u003cbr\u003e\treturn total\u003cbr\u003e# test cases\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum([1,[2,3]]))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i, (int, float)):\u003cbr\u003e            sum+=i\u003cbr\u003e        elif isinstance(i, (list, tuple)):\u003cbr\u003e            sum+=smart_sum(*i)\u003cbr\u003e    return sum\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    s=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if  isinstance(i,int):\u003cbr\u003e            s=s+i\u003cbr\u003e        \u003cbr\u003e        else:\u003cbr\u003e            for j in i:\u003cbr\u003e                s=s+j\u003cbr\u003e    return s\u003cbr\u003e\u003cbr\u003e#smart_sum(1,2,[3,4],(5,6))\u003cbr\u003e\u003cbr\u003e    \u003cbr\u003e        ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    \u003cbr\u003e    def recursive_sum(item):\u003cbr\u003e        nonlocal total\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            total += item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            for sub_item in item:\u003cbr\u003e                recursive_sum(sub_item)\u003cbr\u003e    \u003cbr\u003e    for arg in args:\u003cbr\u003e        recursive_sum(arg)\u003cbr\u003e    \u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which themselves may be nested arbitrarily).\u003cbr\u003e    Non-numeric values are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e\u003cbr\u003e    def sum(item):\u003cbr\u003e        total = 0\u003cbr\u003e        \u003cbr\u003e        if type(item) == int or type(item) == float:\u003cbr\u003e            total = total + item\u003cbr\u003e        \u003cbr\u003e        elif type(item) == list:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which themselves may be nested arbitrarily).\u003cbr\u003e    Non-numeric values are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    total = 0  # Initialize total to 0\u003cbr\u003e    for x in args:\u003cbr\u003e        t = type(x)  # For easy coding\u003cbr\u003e        if (t is int or t is float):  # Type is int or float   \u003cbr\u003e            total += x\u003cbr\u003e        if (t is list or t is tuple):  # Type is list or tuple    \u003cbr\u003e            total += smart_sum(*x)    # Final sum\u003cbr\u003e    return total  # Total will be output\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    def insidelist(n):\u003cbr\u003e        l=0\u003cbr\u003e        t=type(n)\u003cbr\u003e        if t is list:\u003cbr\u003e            for i in range(len(n)): #if the element is single number we return the number if it is a list or tuple we return the sum of the list or tuple and at the end we return the sum of all the values we counted earlier\u003cbr\u003e                l=l+n[i]\u003cbr\u003e                return l           \u003cbr\u003e        elif t is tuple:\u003cbr\u003e            for i in range(len(n)):\u003cbr\u003e                l += n[i]\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["sum=0\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    global sum\u003cbr\u003e    for i in args:\u003cbr\u003e        tp=type(i)#check for data type\u003cbr\u003e        if tp==int or tp==float:#int or float\u003cbr\u003e            sum+=i\u003cbr\u003e        elif tp==list or tp==tuple:#list or tuple\u003cbr\u003e            smart_sum(*i)#recursion\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def check_and_add(q):\u003cbr\u003e    sum_partial=0\u003cbr\u003e    for i in q:\u003cbr\u003e        if type(i)==int or type(i)==float:\u003cbr\u003e            sum_partial+=i\u003cbr\u003e        elif type(i)==list or type(i)==tuple:\u003cbr\u003e            sum_partial+=check_and_add(i)\u003cbr\u003e    return sum_partial\u003cbr\u003edef smart_sum(p,*args):\u003cbr\u003e    if type(p)==int or type(p)==float:\u003cbr\u003e            sum_final=p\u003cbr\u003e    elif type(p)==list or type(p)==tuple:\u003cbr\u003e            sum_final=check_and_add(p)\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int or type(i)==float:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\"\"\"\u003cbr\u003eSum all numeric inputs, including numbers contained inside\u003cbr\u003elists or tuples (which\u003cbr\u003ethemselves may be nested arbitrarily). Non-numeric values\u003cbr\u003eare not expected.\u003cbr\u003eReturn the sum as an int or float.\u003cbr\u003e\"\"\"\u003cbr\u003edef smart_sum(args):\u003cbr\u003e    s=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if (type(i)==int or type(i)==float):\u003cbr\u003e            s+=i\u003cbr\u003e        elif (type(i)==list or type(i)==tuple):\u003cbr\u003e            for a in i:\u003cbr\u003e                s=s+a\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def funsum(nist):\u003cbr\u003e    \"\"\"This function returns sum of the elements\u003cbr\u003e       input\"\"\"\u003cbr\u003e    sums=0\u003cbr\u003e    if type(nist)== int or type(nist)== float:\u003cbr\u003e        sums = nist\u003cbr\u003e    else:\u003cbr\u003e        for i in nist:\u003cbr\u003e            sums += funsum(i)\u003cbr\u003e    return sums\u003cbr\u003e    \u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    \"\"\"returns final answer\"\"\"\u003cbr\u003e    sums=0\u003cbr\u003e    for i in args:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    def k(x):\u003cbr\u003e        if isinstance(x,(list,tuple)):\u003cbr\u003e            return sum(k(v) for v in x )\u003cbr\u003e        else:\u003cbr\u003e            return int(x)\u003cbr\u003e    return sum(k(v)for v in args)\u003cbr\u003e    \u003cbr\u003e\u003cbr\u003eprint(smart_sum(1,[2,3]))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e     def recursive_sum(ele):\u003cbr\u003e         localsum=0\u003cbr\u003e         for i in ele:\u003cbr\u003e             if type(i)==list or type(i)==tuple:\u003cbr\u003e                 localsum=localsum+recursive_sum(i)\u003cbr\u003e             else:\u003cbr\u003e                 localsum=localsum+i\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["data = [1, [2, 3], (4, 5)]\u003cbr\u003e\u003cbr\u003edef calc(x):\u003cbr\u003e    total = 0\u003cbr\u003e    for i in x:\u003cbr\u003e        if isinstance(i, (int, float)):\u003cbr\u003e            total += i\u003cbr\u003e        elif isinstance(i, (list, tuple)):\u003cbr\u003e            total += calc(i)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003eprint(calc(data))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    sum = 0\u003cbr\u003e\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) in (int, float):\u003cbr\u003e            sum += arg\u003cbr\u003e        elif type(arg) in (list, tuple):\u003cbr\u003e            sum += smart_sum(*arg)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    s=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i,(int,float)):\u003cbr\u003e            s+=i\u003cbr\u003e        elif isinstance(i,(list,tuple)):\u003cbr\u003e            s+=smart_sum(*i)\u003cbr\u003e    return s\u003cbr\u003e\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e        ","analysis.embedding.code_embedding"],["sum = 0 \u003cbr\u003edef smart_sum(arg):\u003cbr\u003e    global sum\u003cbr\u003e    if type(arg) == int or type(arg) == float:\u003cbr\u003e        sum+=arg\u003cbr\u003e    elif type(arg)==list or type(arg) == tuple:\u003cbr\u003e        for n in arg:\u003cbr\u003e            if type(n) == int:\u003cbr\u003e                sum+=n\u003cbr\u003e            elif type(n) == list:\u003cbr\u003e                sum=smart_sum(n)\u003cbr\u003e            elif type(n) == tuple:\u003cbr\u003e                sum=smart_sum(n)\u003cbr\u003e    return sum\u003cbr\u003e        \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i,(int, float)):\u003cbr\u003e            total += i\u003cbr\u003e        elif isinstance(i,(list,tuple)):\u003cbr\u003e            total+=smart_sum(*i)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum([1, [2, 3]]))","analysis.embedding.code_embedding"],["#q6\u003cbr\u003e\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e\u003cbr\u003e    for value in args:\u003cbr\u003e        if isinstance(value, (int, float)):\u003cbr\u003e            total += value\u003cbr\u003e        elif isinstance(value, (list, tuple)):\u003cbr\u003e            # use recursion to handle nested lists\u002ftuples\u003cbr\u003e            total += smart_sum(*value)\u003cbr\u003e\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e       Sum all numeric inputs, including numbers contained inside lists\u003cbr\u003ethemselves may be nested arbitrarily). Non-numeric values are not\u003cbr\u003eReturn the sum as an int or float.\u003cbr\u003e                                  \"\"\"\u003cbr\u003e    \u003cbr\u003e    s = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if isinstance(arg,list):\u003cbr\u003e            for nums in arg:\u003cbr\u003e                if isinstance(nums,list):\u003cbr\u003e                    for num in nums:\u003cbr\u003e                        s += num\u003cbr\u003e                else:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    \u003cbr\u003e    s = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i,(int,float,complex)):\u003cbr\u003e            s += i\u003cbr\u003e        else:\u003cbr\u003e            s += smart_sum(*i)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in range(len(args)):\u003cbr\u003e        if isinstance(args[i], (list, tuple)):  # If item is list or tuple, call again\u003cbr\u003e            sum += smart_sum(*args[i])\u003cbr\u003e        else:\u003cbr\u003e            sum += args[i]  # If item is number,  add it to sum\u003cbr\u003e    return sum  ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which themselves may be nested arbitrarily). \u003cbr\u003e    Non-numeric values are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    sum = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) == list or type(arg) == tuple:         #Checking the type\u003cbr\u003e            sum += add_data(arg)                   #if iterable send to given function\u003cbr\u003e        else:\u003cbr\u003e            sum += arg                             #else:  add them\u003cbr\u003e    return sum\u003cbr\u003e    \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i, (int,float)):\u003cbr\u003e            total += i\u003cbr\u003e        elif isinstance(i, (list,tuple)):\u003cbr\u003e            total += smart_sum(*i)\u003cbr\u003e            \u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e            ","analysis.embedding.code_embedding"],["#Smart Sum\u003cbr\u003e\u003cbr\u003edef sort_out(items):                    #Helper function to sort out the nessted lists\u002f tuples and collect all numbers.\u003cbr\u003e    sort = []\u003cbr\u003e    for i in items:\u003cbr\u003e        if isinstance(i, (int, float)): \u003cbr\u003e            sort.append(i)              # add one item\u003cbr\u003e        elif isinstance(i, (list, tuple)):\u003cbr\u003e            sort.extend(sort_out(i))    # rescursive call, extend(): add all items from an iterable\u003cbr\u003e    return sort\u003cbr\u003e\u003cbr\u003edef smart_sum(*args):                   # * is used to collect multiple arguments in a single variable\u003cbr\u003e    sortedlist = sort_out(args)\u003cbr\u003e    return sum(sortedlist)\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for x in args:\u003cbr\u003e        t = type(x)\u003cbr\u003e        if (t is int or t is float):     \u003cbr\u003e            total += x\u003cbr\u003e        if (t is list or t is tuple):      \u003cbr\u003e            total += smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003eprint(smart_sum())","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    count = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        data_type = type(i)\u003cbr\u003e        if data_type is int or data_type is float:     \u003cbr\u003e            count += i\u003cbr\u003e        if data_type is list or data_type is tuple:      \u003cbr\u003e            count += smart_sum(*i)\u003cbr\u003e    return count\u003cbr\u003e\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum([1, [2, 3]]))\u003cbr\u003e  ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e    for i in (args):\u003cbr\u003e        sum = sum + i\u003cbr\u003e    return sum\u003cbr\u003eprint(smart_sum(*(1,*[2,3])))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum(*(1,2,*[3,4],*(5,6))))","analysis.embedding.code_embedding"],["\"\"\"\u003cbr\u003eSum all numeric inputs, including numbers contained inside\u003cbr\u003elists or tuples (which\u003cbr\u003ethemselves may be nested arbitrarily). Non-numeric values\u003cbr\u003eare not expected.\u003cbr\u003eReturn the sum as an int or float.\u003cbr\u003e\"\"\"\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg)==int or type(arg)==float:\u003cbr\u003e            sum=sum+arg\u003cbr\u003e        elif type(arg)==tuple or type(arg)==list:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type (i) in ((int,float)):         # if input is a number\u003cbr\u003e            sum += i\u003cbr\u003e        elif type (i) in ((list,tuple)):      # if input is a list\u002ftuple\u003cbr\u003e            sum += smart_sum(*i)                # recursion by functin calling\u003cbr\u003e    return sum\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    total = 0\u003cbr\u003e    items = list(args)   \u003cbr\u003e    while items:\u003cbr\u003e        x = items.pop()\u003cbr\u003e        if type(x) == int or type(x) == float:\u003cbr\u003e            total += x\u003cbr\u003e        elif type(x) == list or type(x) == tuple:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float\u003cbr\u003e    \"\"\"\u003cbr\u003e    s=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i) == int or type(i) == float:   # numbers\u003cbr\u003e            s += i\u003cbr\u003e        elif type(i) == list or type(i) == tuple:  # lists\u002ftuples\u003cbr\u003e            s += smart_sum(*i)   # recursion if they are nested\u003cbr\u003e    return s\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(args):\u003cbr\u003e    sum = 0\u003cbr\u003e    for element in args:\u003cbr\u003e        if type(element)==list:\u003cbr\u003e            sum += smart_sum(element)\u003cbr\u003e\u003cbr\u003e        elif type(element)==tuple:\u003cbr\u003e            sum += smart_sum(element)\u003cbr\u003e\u003cbr\u003e        else:\u003cbr\u003e            y=int(element)\u003cbr\u003e            sum += y\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) in [int, float]:\u003cbr\u003e            total += arg\u003cbr\u003e        elif type(arg) in [list, tuple]:\u003cbr\u003e            total += smart_sum(*arg)  # recursion\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e#test case\u003cbr\u003eprint (smart_sum(1, 2, [3, 4], (5, 6)))\u003cbr\u003eprint (smart_sum(10))\u003cbr\u003eprint (smart_sum(1, [2,3]))","analysis.embedding.code_embedding"],["def smart_total(args):\u003cbr\u003e    if(type(args)==int):\u003cbr\u003e        return args\u003cbr\u003e    args=list(args)\u003cbr\u003e    global total\u003cbr\u003e    n=0\u003cbr\u003e    while(n==0):\u003cbr\u003e        total=0\u003cbr\u003e        n=1\u003cbr\u003e        for i in range (len(args)):\u003cbr\u003e            if(type(args[i])==float or type(args[i])==int):\u003cbr\u003e                total += args[i]\u003cbr\u003e            elif(type(args[i])==list or type(args[i])==float):\u003cbr\u003e                a=args[i]\u003cbr\u003e                for j in range(len(a)):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e\u003cbr\u003e    for val in args:\u003cbr\u003e        if type(val)==int:\u003cbr\u003e            sum+=val\u003cbr\u003e        else:\u003cbr\u003e            for value in val:\u003cbr\u003e                if type(value)==int:\u003cbr\u003e                    sum+=value\u003cbr\u003e                else:\u003cbr\u003e                    for val1 in value:\u003cbr\u003e                        sum+=val1\u003cbr\u003e    \u003cbr\u003e    return sum\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for x in args:\u003cbr\u003e        if type(x) in (list, tuple):   \u003cbr\u003e            total += smart_sum(*x)     \u003cbr\u003e        else:  \u003cbr\u003e            total += x                 \u003cbr\u003e    return total","analysis.embedding.code_embedding"],["\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e\u003cbr\u003e    def adder(value):\u003cbr\u003e        \u003cbr\u003e        if type(value) == list:\u003cbr\u003e            total = 0\u003cbr\u003e            i = 0\u003cbr\u003e            while i &lt; len(value):   \u003cbr\u003e                total += adder(value[i])\u003cbr\u003e                i += 1\u003cbr\u003e            return total\u003cbr\u003e\u003cbr\u003e        elif type(value) == tuple:\u003cbr\u003e            total = 0\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for x in args:\u003cbr\u003e        if type(x) in [int,float]:\u003cbr\u003e            total=total+x\u003cbr\u003e        elif type(x) in [list,tuple]:\u003cbr\u003e            total=total+smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e            ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    TotalSum = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i) == list or type(i) == tuple:\u003cbr\u003e            for j in range(len(i)):\u003cbr\u003e                if type(i[j]) == list or type(i[j]) == tuple:\u003cbr\u003e                    TotalSum += smart_sum(*i[j])\u003cbr\u003e                else:\u003cbr\u003e                    TotalSum = TotalSum + i[j]\u003cbr\u003e        else:\u003cbr\u003e            TotalSum = TotalSum + i\u003cbr\u003e    return TotalSum","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if isinstance(arg, (int, float)):\u003cbr\u003e            total += arg\u003cbr\u003e        elif isinstance(arg, (list, tuple)):\u003cbr\u003e            total += smart_sum(*arg)  # unpack list\u002ftuple for recursion\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e# Test cases\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))   \u003cbr\u003eprint(smart_sum([1, [2, 3]]))             ","analysis.embedding.code_embedding"],["def smart_sum(arguments):\u003cbr\u003e    sum = 0\u003cbr\u003e    for i in arguments:\u003cbr\u003e        if isinstance(i, int):\u003cbr\u003e            sum += i\u003cbr\u003e        elif isinstance(i, (tuple, list)):\u003cbr\u003e            sum += smart_sum(i)\u003cbr\u003e    return sum\u003cbr\u003e\u003cbr\u003eprint(smart_sum((1, 2, [3, 4], (5, 6))))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum(1,[2,3]))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for num in args:\u003cbr\u003e        if isinstance(num,(list)):\u003cbr\u003e            sum+=smart_sum(*num)\u003cbr\u003e        else:\u003cbr\u003e                sum+=num\u003cbr\u003e    return sum\u003cbr\u003eprint(smart_sum([1,2,[2,3]]))    ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    count = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        data_type = type(i)\u003cbr\u003e        if data_type is int or data_type is float:     \u003cbr\u003e            count += i\u003cbr\u003e        if data_type is list or data_type is tuple:      \u003cbr\u003e            count += smart_sum(*i)\u003cbr\u003e    return count\u003cbr\u003e\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum([1, [2, 3]]))\u003cbr\u003e  ","analysis.embedding.code_embedding"],["sum=0\u003cbr\u003edef smart_sum(database):\u003cbr\u003e    global sum\u003cbr\u003e    for data in database:\u003cbr\u003e        m=type(data)\u003cbr\u003e        if (type(data)==type(1)):\u003cbr\u003e            sum +=data\u003cbr\u003e        elif(type(data)==type([1])):\u003cbr\u003e            smart_sum(data)\u003cbr\u003e            \u003cbr\u003e    return sum        \u003cbr\u003e        \u003cbr\u003e    ","analysis.embedding.code_embedding"],["def smart_sum(args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    new_list=[]\u003cbr\u003e    sum2=0\u003cbr\u003e    sum1=0\u003cbr\u003e    if(type(args)==int):\u003cbr\u003e        return args\u003cbr\u003e    for i in range(0,len(args)):\u003cbr\u003e        if(type(args[i])!=list and type(args[i])!=tuple):\u003cbr\u003e            sum1=sum1+args[i]\u003cbr\u003e    for i in range(0,len(args)):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for num in args:\u003cbr\u003e        if type(num)==int or type(num)==float:\u003cbr\u003e            total=total+num\u003cbr\u003e           \u003cbr\u003e        elif type(num)==list or type(num)==tuple:\u003cbr\u003e            total=total+smart_sum(*num)\u003cbr\u003e            \u003cbr\u003e    return total\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003eprint(smart_sum(1,2,[3,4],(5,6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum(1,[2,3]))","analysis.embedding.code_embedding"],["# def is_iterable(input_):\u003cbr\u003e#     try:\u003cbr\u003e#         iter(input_)\u003cbr\u003e#         return True\u003cbr\u003e#     except:\u003cbr\u003e#         return False\u003cbr\u003e        \u003cbr\u003e# def are_all_non_iter(input_):\u003cbr\u003e#     count = 0\u003cbr\u003e#     for i in input_:\u003cbr\u003e#         if is_iterable(i):\u003cbr\u003e#             break\u003cbr\u003e#         else:\u003cbr\u003e#             count += 1\u003cbr\u003e#     if count == len(input_):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args) -&gt; Union[int, float]:\u003cbr\u003e    \"\"\"\u003cbr\u003e    Add up numbers, even if they are inside lists\u002ftuples at any depth.\u003cbr\u003e    Example: smart_sum([1, 2], (3, [4, 5])) â†’ 15\u003cbr\u003e    \"\"\"\u003cbr\u003e\u003cbr\u003e    def helper(x):\u003cbr\u003e        if isinstance(x, numbers.Number):\u003cbr\u003e            return x\u003cbr\u003e        if isinstance(x, (list, tuple)):\u003cbr\u003e            return sum(helper(i) for i in x)\u003cbr\u003e        return 0  # ignore non-numeric stuff\u003cbr\u003e\u003cbr\u003e    total = sum(helper(a) for a in args)\u003cbr\u003e    # Return int if result is whole, else float\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["import ast\u003cbr\u003eenterinputastuple = input('enter args : ' )\u003cbr\u003ex = ast.literal_eval(enterinputastuple)#converts string to tuple\u003cbr\u003edef smart_sum(x):\u003cbr\u003e    sumlist = []\u003cbr\u003e    smartsum =0\u003cbr\u003e    for i in x:\u003cbr\u003e        if type(i) == list :\u003cbr\u003e            for j in i:\u003cbr\u003e                sumlist.append(j)\u003cbr\u003e        elif type(i) == tuple :\u003cbr\u003e            for j in i :\u003cbr\u003e                sumlist.append(j)\u003cbr\u003e        else :\u003cbr\u003e            sumlist.append(i)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==list or type(i)==tuple:\u003cbr\u003e            sum = sum + smart_sum(*i)\u003cbr\u003e        else:\u003cbr\u003e            sum = sum + i\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i) is int or type(i) is float:\u003cbr\u003e            sum += i\u003cbr\u003e        elif type(i) is list or type(i) is tuple:\u003cbr\u003e            sum += smart_sum(*i)\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def smart_sum(value):\u003cbr\u003e\tn=value\u003cbr\u003e\tl=len(n)\u003cbr\u003e\ts=0\u003cbr\u003e\tfor i in range(l):\u003cbr\u003e\t\tif type(n[i])==int:\u003cbr\u003e\t\t\ts=s+n[i]\u003cbr\u003e\t\tif type(n[i])==list:\u003cbr\u003e\t\t\ts=s+smart_sum(n[i])\u003cbr\u003e\t\tif type(n[i])==tuple:\u003cbr\u003e\t\t\ts=s+smart_sum(n[i])\u003cbr\u003e\treturn s\u003cbr\u003esmart_sum([1,2,[3,4],(5,6)])","analysis.embedding.code_embedding"],["###################################################################################################\u003cbr\u003e#SATYA RISHINDRA SONTHENA\u003cbr\u003e#B25MM027\u003cbr\u003e#MATERIAL SCIENCES AND METALLURGICAL ENGINEERING\u003cbr\u003e#INDIAN INSTITUTE OF TECHNOLOGY BHILAI\u003cbr\u003e###################################################################################################\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for item in args:\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            total += item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            total += smart_sum(*item)  \u003cbr\u003e    return total\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))  ","analysis.embedding.code_embedding"],["sum = 0 \u003cbr\u003edef smart_sum(arg):\u003cbr\u003e    global sum\u003cbr\u003e    if type(arg) == int or type(arg) == float:\u003cbr\u003e        sum+=arg\u003cbr\u003e    elif type(arg)==list or type(arg) == tuple:\u003cbr\u003e        for i in arg:\u003cbr\u003e            if type(i) == int:\u003cbr\u003e                sum+=i\u003cbr\u003e            elif type(i) == list:\u003cbr\u003e                sum=smart_sum(i)\u003cbr\u003e            elif type(i) == tuple:\u003cbr\u003e                sum=smart_sum(i)\u003cbr\u003e    return sum\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which themselves may be nested arbitrarily).\u003cbr\u003e    Non-numeric values are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    total = 0\u003cbr\u003e\u003cbr\u003e    for arg in args:\u003cbr\u003e        if isinstance(arg, (int, float)):\u003cbr\u003e            total += arg\u003cbr\u003e        elif isinstance(arg, (list, tuple)):\u003cbr\u003e            total += smart_sum(*arg)  # unpack and recurse\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside lists themselves may be nested arbitrarily).\u003cbr\u003e    Non-numeric values are not Return the sum as an int or float.\u003cbr\u003e    \"\"\" \u003cbr\u003e    to = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) in [int, float]:\u003cbr\u003e            to =to+ arg\u003cbr\u003e        elif type(arg) in [list, tuple]:  \u003cbr\u003e            to =to+ smart_sum(*arg)       \u003cbr\u003e    return to","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i, (int, float)):\u003cbr\u003e            sum += i\u003cbr\u003e        else:  # if it's a list\u002ftuple (or any iterable)\u003cbr\u003e            sum += smart_sum(*i)\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i) in [int,float]:\u003cbr\u003e            total+=i\u003cbr\u003e        elif type(i) in [list,tuple]:\u003cbr\u003e            total+=smart_sum(*i)\u003cbr\u003e    return total\u003cbr\u003esmart_sum(1,2,[3,4],(5,6))\u003cbr\u003esmart_sum(10)\u003cbr\u003esmart_sum([1,[2,3]])","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    Sum = 0\u003cbr\u003e    for Number in args:\u003cbr\u003e        if type(Number) == list or type(Number) == tuple:\u003cbr\u003e            Sum += smart_sum(*Number)\u003cbr\u003e        else:\u003cbr\u003e            Sum += Number\u003cbr\u003e    return Sum","analysis.embedding.code_embedding"],["def smart_sum(l):\u003cbr\u003e    \u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e\u003cbr\u003e    s = 0\u003cbr\u003e    for e in l:\u003cbr\u003e        if (type(e) == list) or (type(e)==tuple):\u003cbr\u003e            s += smart_sum(e)\u003cbr\u003e        else:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for x in args:\u003cbr\u003e        if type(x) in [int,float]:\u003cbr\u003e            total=total+x\u003cbr\u003e        elif type(x) in [list,tuple]:\u003cbr\u003e            total=total+smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003e","analysis.embedding.code_embedding"],["#Smart Sum\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if(isinstance(i,int)):    #As By using type() there is an error I searched for an alternative for type()\u003cbr\u003e            sum=sum+i\u003cbr\u003e        elif(isinstance(i,float)):\u003cbr\u003e            sum=sum+i\u003cbr\u003e        elif(isinstance(i,list)):\u003cbr\u003e            sum=sum+smart_sum(*i)\u003cbr\u003e        elif(isinstance(i,tuple)):\u003cbr\u003e            sum=sum+smart_sum(*i)\u003cbr\u003e    return sum\u003cbr\u003eprint(smart_sum(1,2,[3,4],(5,6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    total = 0\u003cbr\u003e\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg)==int or type(arg)==float:  # add if it is number\u003cbr\u003e            total += arg\u003cbr\u003e        elif type(arg)==list or type(arg)==tuple:  \u003cbr\u003e            total += smart_sum(*arg)\u003cbr\u003e    return total\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    count = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        data_type = type(i)\u003cbr\u003e        if data_type is int or data_type is float:     \u003cbr\u003e            count += i\u003cbr\u003e        if data_type is list or data_type is tuple:      \u003cbr\u003e            count += smart_sum(*i)\u003cbr\u003e    return count\u003cbr\u003e\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        t = type(arg)\u003cbr\u003e        if t == int or t == float:     # numeric types\u003cbr\u003e            total += arg\u003cbr\u003e        elif t == list or t == tuple:  # recursive case\u003cbr\u003e            total += smart_sum(*arg)\u003cbr\u003e    return total\u003cbr\u003eprint(smart_sum(1,2,[3,4],(5,6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum([1,[2,3]]))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e    for x in args:\u003cbr\u003e        if type(x)== list or type(x)== tuple:\u003cbr\u003e            sum += smart_sum(*x)\u003cbr\u003e        else:\u003cbr\u003e            sum += x\u003cbr\u003e    return sum\u003cbr\u003e    pass\u003cbr\u003eprint(smart_sum(1, 2, [3,4], (5,6)))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum_of_the_numbers=0\u003cbr\u003e    for i in args:\u003cbr\u003e\u003cbr\u003e        if type(i)==float or type(i)==int:\u003cbr\u003e            sum_of_the_numbers+=i\u003cbr\u003e\u003cbr\u003e        elif type(i)==list or type(i)==tuple:\u003cbr\u003e            sum_of_the_numbers=sum_of_the_numbers+smart_sum(*i)\u003cbr\u003e\u003cbr\u003e    return sum_of_the_numbers\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6))) \u003cbr\u003eprint(smart_sum(10)) \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(args):\u003cbr\u003e    total = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            total += smart_sum(i)\u003cbr\u003e        elif type(i)==tuple:\u003cbr\u003e            total += smart_sum(i)\u003cbr\u003e        else:\u003cbr\u003e            z=int(i)\u003cbr\u003e            total += z\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e     #a function to calculate the sum of a nested list or a tuple\u003cbr\u003e     def recursive_sum(ele):\u003cbr\u003e         localsum=0\u003cbr\u003e         for i in ele:\u003cbr\u003e             if type(i)==list or type(i)==tuple:\u003cbr\u003e                 localsum=localsum+recursive_sum(i)\u003cbr\u003e             else:\u003cbr\u003e                 localsum=localsum+i\u003cbr\u003e         return localsum\u003cbr\u003e     sum=0\u003cbr\u003e     for j in args:\u003cbr\u003e         if type(j)==list or type(j)==tuple:\u003cbr\u003e                 #calling the recursive function\u003cbr\u003e                 sum=sum+recursive_sum(j)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside lists\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values are not\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e  \u003cbr\u003e       \"\"\"\u003cbr\u003e    total=0\u003cbr\u003e    for item in args:\u003cbr\u003e       #if the number is in a list or a tuple, convert to its elements\u003cbr\u003e        if isinstance(item,(list,tuple)):\u003cbr\u003e            total+=smart_sum(*item)#adds all items using recursion\u003cbr\u003e        else:\u003cbr\u003e            total+=item \u003cbr\u003e    return total\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    count  = 0\u003cbr\u003e    for x in range(0,len(args)):\u003cbr\u003e        if type(args[x]) == list or type(args[x]) == tuple:\u003cbr\u003e            for w in args[x]:\u003cbr\u003e            \u003cbr\u003e             count=count+smart_sum(w)#going through the function again if the required condition is true\u003cbr\u003e        elif type(args[x]) == int or type(args[x]) == float:\u003cbr\u003e            count = count + args[x]\u003cbr\u003e    return count\u003cbr\u003e\u003cbr\u003e            ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    s=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if(type(i)!=int):\u003cbr\u003e            if(len(i)==1):\u003cbr\u003e                s=s+i[0]\u003cbr\u003e            else:\u003cbr\u003e                for j in range(0,len(i)):\u003cbr\u003e                        s=s+i[j]\u003cbr\u003e        elif(type(i)==int):\u003cbr\u003e            s=s+i\u003cbr\u003e    return s\u003cbr\u003eprint(smart_sum(1,2,[3,4],[5,6]))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum(1,[2,3]))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    # *args stores everything into a list, given as input\u003cbr\u003e    total=0\u003cbr\u003e    for i in range(len(args)):\u003cbr\u003e        if isinstance(args[i], list):  #isinstance(object, type) returns boolean\u003cbr\u003e            m=args[i]\u003cbr\u003e            total+=smart_sum(*m)\u003cbr\u003e        elif isinstance(args[i],tuple):\u003cbr\u003e            m=args[i]\u003cbr\u003e            total+=smart_sum(*m)\u003cbr\u003e        else:\u003cbr\u003e            total+=args[i]\u003cbr\u003e    return total\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    '''since this * in parameter wraps all data in tuple lets iterate for all element if its numeric add\u003cbr\u003e    else for any collection recall the function by passing it as raw arguement rather than as collection that is *i unpacks\u003cbr\u003e    the list tuple or any other collections and finally returns the sum'''\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if(type(i)==int or type(i)==float):\u003cbr\u003e            sum+=i\u003cbr\u003e        else:\u003cbr\u003e            sum+=smart_sum(*i)\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    \u003cbr\u003e    def add_items(items):\u003cbr\u003e        nonlocal total\u003cbr\u003e        if isinstance(items, (int, float)):\u003cbr\u003e            total += items\u003cbr\u003e        elif isinstance(items, (list, tuple)):\u003cbr\u003e            for item in items:\u003cbr\u003e                add_items(item)\u003cbr\u003e                \u003cbr\u003e    for arg in args:\u003cbr\u003e        add_items(arg)\u003cbr\u003e        \u003cbr\u003e    return total\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*nums):\u003cbr\u003e  sum = 0\u003cbr\u003e  for i in nums:\u003cbr\u003e      if type(i) in [int, float]:\u003cbr\u003e          sum += i\u003cbr\u003e      elif type(i) in [list, tuple]:\u003cbr\u003e          sum += smart_sum(*i)\u003cbr\u003e  return sum    \u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6))) \u003cbr\u003eprint(smart_sum(10)) \u003cbr\u003eprint(smart_sum([1, [2, 3]]))","analysis.embedding.code_embedding"],["s=0\u003cbr\u003edef smart_sum(args):\u003cbr\u003e    global s\u003cbr\u003e    if(type(args)==int or type(args)==float):\u003cbr\u003e        s+=args\u003cbr\u003e    elif(type(args)==list or type(args)==tuple):\u003cbr\u003e        for x in args:\u003cbr\u003e            s=smart_sum(x)\u003cbr\u003e    return s","analysis.embedding.code_embedding"],["\u003cbr\u003es =0\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    global s\u003cbr\u003e    for a in args:\u003cbr\u003e        if type(a) == list or type(a)==tuple or type(a)==set:\u003cbr\u003e            smart_sum(*a)\u003cbr\u003e        else : s += a\u003cbr\u003e    return s\u003cbr\u003e\u003cbr\u003e# print(smart_sum([1, [2, 3], 5]))","analysis.embedding.code_embedding"],["#not able to solve","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e       calculates the sum of numbers present in lists.\u003cbr\u003e    \"\"\"   \u003cbr\u003e    t=0\u003cbr\u003e    r=0\u003cbr\u003e    for m in args:\u003cbr\u003e        if isinstance(m,(int,float,complex)):\u003cbr\u003e            t=t+m\u003cbr\u003e        elif isinstance(m,(list,set,tuple,dict)):\u003cbr\u003e            r=r+smart_sum(*m)\u003cbr\u003e    return(t+r)\u003cbr\u003e\u003cbr\u003e        \u003cbr\u003e            \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    sum = 0\u003cbr\u003e\u003cbr\u003e    for i in args:\u003cbr\u003e        if str(type(i)) in [\"&lt;class 'list'&gt;\", \"&lt;class 'tuple'&gt;\"]:\u003cbr\u003e            sum += smart_sum(*i)\u003cbr\u003e        else:\u003cbr\u003e            sum += i\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):             #define a function for smart sum\u003cbr\u003e    def flatten_and_sum(item):       #again define a function for flatten and sum of items\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            return item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            return sum(flatten_and_sum(x) for x in item)\u003cbr\u003e        else:\u003cbr\u003e            return 0\u003cbr\u003e\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        total += flatten_and_sum(arg)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    t=0\u003cbr\u003e    r=0\u003cbr\u003e    for m in args:\u003cbr\u003e        if isinstance(m,(int,float,complex)):\u003cbr\u003e            t=t+m\u003cbr\u003e        elif isinstance(m,(list,tuple)):\u003cbr\u003e            r=r+smart_sum(*m)\u003cbr\u003e    return(t+r)\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for x in args :\u003cbr\u003e         if type(x) in (int,float):\u003cbr\u003e             total=total+x\u003cbr\u003e         elif type(x) in (tuple,list):\u003cbr\u003e             total=total+smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003eSum all numeric inputs, including numbers contained inside\u003cbr\u003elists or tuples (which\u003cbr\u003ethemselves may be nested arbitrarily). Non-numeric values\u003cbr\u003eare not expected.\u003cbr\u003eReturn the sum as an int or float.\u003cbr\u003e\"\"\"\u003cbr\u003e\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) in [int, float]:\u003cbr\u003e            total += arg\u003cbr\u003e        elif type(arg) in [list, tuple]:  \u003cbr\u003e            total += smart_sum(*arg)       \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    \u003cbr\u003e    def helper(item):\u003cbr\u003e        nonlocal total\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            total += item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            for sub in item:\u003cbr\u003e                helper(sub)\u003cbr\u003e        else:\u003cbr\u003e            raise TypeError(f\"Unsupported type: {type(item)}\")\u003cbr\u003e    \u003cbr\u003e    for arg in args:\u003cbr\u003e        helper(arg)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):# so that function can take unlimited inputs\u003cbr\u003e    total  = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i) == int or type(i) == float: # is i is integer it will simply add\u003cbr\u003e            total += i\u003cbr\u003e        if type(i) == list or type(i) == tuple: #if i is list or tuple the elements will add\u003cbr\u003e            for j in i:\u003cbr\u003e                total+= j\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(args):\u003cbr\u003e    \"\"\"\u003cbr\u003eSum all numeric inputs, including numbers contained inside\u003cbr\u003elists or tuples (which\u003cbr\u003ethemselves may be nested arbitrarily). Non-numeric values\u003cbr\u003eare not expected.\u003cbr\u003eReturn the sum as an int or float.\u003cbr\u003e\"\"\"\u003cbr\u003e    sum = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==(int or float):\u003cbr\u003e            sum += i\u003cbr\u003e        else:\u003cbr\u003e            sum += smart_sum(*i)\u003cbr\u003e    return sum\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    def recursive(i):\u003cbr\u003e        if type(i)==int or type(i) ==float:\u003cbr\u003e            return i\u003cbr\u003e        elif type(i)== list or type(i)==tuple:\u003cbr\u003e            add = 0\u003cbr\u003e            for subnumb in i:\u003cbr\u003e                add= add+recursive(subnumb)\u003cbr\u003e            return \u003cbr\u003e        else:\u003cbr\u003e            return 0  \u003cbr\u003e\u003cbr\u003e    add= 0\u003cbr\u003e    for arg in args:\u003cbr\u003e      add=+ recursive(arg)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    result = 0\u003cbr\u003e    for number in args:\u003cbr\u003e        if isinstance(number, (int, float)):\u003cbr\u003e            result += number\u003cbr\u003e        elif isinstance(number, (list, tuple)):\u003cbr\u003e            result += smart_sum(*number)  \u003cbr\u003e        else:\u003cbr\u003e            pass\u003cbr\u003e    return result\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum([1, [2, 3]]))","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    if not args:\u003cbr\u003e        return 0\u003cbr\u003e    first,*rest= args\u003cbr\u003e    t=type(first)\u003cbr\u003e    if t is int or t is float:\u003cbr\u003e        return first+smart_sum(*rest)\u003cbr\u003e    elif t is list or t is tuple:\u003cbr\u003e        return smart_sum(*first)+smart_sum(*rest)\u003cbr\u003e    else:\u003cbr\u003e        return smart_sum(*rest)\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    def flatten_and_sum(item):\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            return item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            return sum(flatten_and_sum(x) for x in item)\u003cbr\u003e        else:\u003cbr\u003e            return 0  \u003cbr\u003e    return sum(flatten_and_sum(arg) for arg in args)\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))  \u003cbr\u003eprint(smart_sum(10))                    \u003cbr\u003eprint(smart_sum([1, [2, 3]]))           ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int or type(i)==float:\u003cbr\u003e            total=i+total\u003cbr\u003e        elif type(i)==list or type(i)==tuple:\u003cbr\u003e            smart_sum(*args)\u003cbr\u003e    return total   ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    count = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        data_type = type(i)\u003cbr\u003e        if data_type is int or data_type is float:     \u003cbr\u003e            count += i\u003cbr\u003e        if data_type is list or data_type is tuple:      \u003cbr\u003e            count += smart_sum(*i)\u003cbr\u003e    return count\u003cbr\u003e\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))\u003cbr\u003eprint(smart_sum(10))\u003cbr\u003eprint(smart_sum([1, [2, 3]]))\u003cbr\u003e  ","analysis.embedding.code_embedding"],["import ast\u003cbr\u003e\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    \u003cbr\u003e    def helper(element):\u003cbr\u003e        nonlocal total\u003cbr\u003e        if isinstance(element, (int, float)):\u003cbr\u003e            total += element\u003cbr\u003e        elif isinstance(element, (list, tuple)):\u003cbr\u003e            for item in element:\u003cbr\u003e                helper(item)\u003cbr\u003e    \u003cbr\u003e    for arg in args:\u003cbr\u003e        helper(arg)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for p in args:\u003cbr\u003e\u003cbr\u003e        if type(p)==float or type(p)==int:\u003cbr\u003e            sum=p+sum\u003cbr\u003e\u003cbr\u003e        elif type(p)==list or type(p)==tuple:\u003cbr\u003e            sum=sum+smart_sum(*p)\u003cbr\u003e\u003cbr\u003e    return sum\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6))) # 21\u003cbr\u003eprint(smart_sum(10)) # 10\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for x in args :\u003cbr\u003e         if type(x) in (int,float):\u003cbr\u003e             total=total+x\u003cbr\u003e         elif type(x) in (tuple,list):\u003cbr\u003e             total=total+smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    def flatten_sum(x):\u003cbr\u003e        if isinstance(x, (int, float)):\u003cbr\u003e            return x\u003cbr\u003e        elif isinstance(x, (list, tuple)):\u003cbr\u003e            return sum(flatten_sum(i) for i in x)\u003cbr\u003e        return 0  # Just in case\u003cbr\u003e\u003cbr\u003e    return sum(flatten_sum(arg) for arg in args)\u003cbr\u003e\u003cbr\u003e# Test cases\u003cbr\u003eprint(smart_sum(1, 2, [3, 4], (5, 6)))     # 21\u003cbr\u003eprint(smart_sum(10))                      # 10\u003cbr\u003eprint(smart_sum([1, [2, 3]]))             # 6","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    result = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        result = summation(arg,result)\u003cbr\u003e    return (result)\u003cbr\u003e\u003cbr\u003edef summation(value,result): #computes the sum of all elements of list\u003cbr\u003e    if type(value)==int or type(value)==float:\u003cbr\u003e        result += value\u003cbr\u003e        return result\u003cbr\u003e    elif type(value)==tuple or type(value)==list:\u003cbr\u003e        for i in range (0,len(value)):\u003cbr\u003e            result = summation(value[i],result) #recursion\u003cbr\u003e        return (result)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        t = str(type(arg))\u003cbr\u003e        if \"int\" in t or \"float\" in t:\u003cbr\u003e            total += arg\u003cbr\u003e        elif \"list\" in t or \"tuple\" in t:\u003cbr\u003e\u003cbr\u003e            inner_total = smart_sum(*arg)\u003cbr\u003e            total += inner_total\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i, (int, float)):        \u003cbr\u003e            total += i\u003cbr\u003e        elif isinstance(i, (list, tuple)):      \u003cbr\u003e            total += smart_sum(*i)              \u003cbr\u003e       \u003cbr\u003e    return total\u003cbr\u003e         \u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e         \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if type(i)==int:\u003cbr\u003e            sum+=i\u003cbr\u003e        if type(i)==list:\u003cbr\u003e            sum+=smart_sum(*i)\u003cbr\u003e        if type(i)==tuple:\u003cbr\u003e            sum+=smart_sum(*i)\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    s=0.0\u003cbr\u003e    for argt in args: \u003cbr\u003e        if type(argt)==int or  type(argt)==float: \u003cbr\u003e            s+=argt\u003cbr\u003e        elif type(argt)==list or type(argt)==tuple or type(argt)==set:\u003cbr\u003e            for element in argt:\u003cbr\u003e                s+=smart_sum(element)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(args):\u003cbr\u003e    sum=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if (type(i)==int or type(i)==float):\u003cbr\u003e            sum=sum+i\u003cbr\u003e        elif (type(i)==list or type(i)==tuple):\u003cbr\u003e            for j in i:\u003cbr\u003e                sum=sum+j\u003cbr\u003e    return (sum)\u003cbr\u003e'''args=eval(input('Enter a list'))\u003cbr\u003eprint(smart_sum(args))'''\u003cbr\u003e    \u003cbr\u003e\"\"\"\u003cbr\u003eSum all numeric inputs, including numbers contained inside lists\u003cbr\u003ethemselves may be nested arbitrarily). Non-numeric values are not\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"Returns the sum of all numeric inputs, including those contained inside\u003cbr\u003e    lists or tuples (which themselves may be nested arbitrarily).\u003cbr\u003e    Return the sum as an int or float.\"\"\"\u003cbr\u003e\u003cbr\u003e    total = 0\u003cbr\u003e    for x in args:\u003cbr\u003e        if type(x) == int or type(x) == float:\u003cbr\u003e            total += x\u003cbr\u003e\u003cbr\u003e        elif type(x) == list or type(x) == tuple:\u003cbr\u003e            for i in x:\u003cbr\u003e                total += smart_sum(i)           #Reccursive call\u003cbr\u003e\u003cbr\u003e    return total\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i, (int, float)):\u003cbr\u003e            sum += i\u003cbr\u003e        else:\u003cbr\u003e            sum += smart_sum(*i)\u003cbr\u003e    return sum","analysis.embedding.code_embedding"],["def smart_sum(Nlist):\u003cbr\u003e    if isinstance(Nlist,int):\u003cbr\u003e        return Nlist\u003cbr\u003e    else:\u003cbr\u003e        Sum=0\u003cbr\u003e        for i in Nlist:\u003cbr\u003e            if isinstance(i,int):\u003cbr\u003e                Sum+=i\u003cbr\u003e            else:\u003cbr\u003e                for r in i:\u003cbr\u003e                    if isinstance(r,int):\u003cbr\u003e                        Sum+=r\u003cbr\u003e    return Sum\u003cbr\u003eprint(smart_sum([1, 2, [3, 4], (5, 6)]))\u003cbr\u003eprint(smart_sum([1, [2, 3]]))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    sum = 0\u003cbr\u003e    for num in args:\u003cbr\u003e        if isinstance(num,(list)):\u003cbr\u003e            sum +=smart_sum(*num)# Andar ke element ka recursive summation\u003cbr\u003e        else:\u003cbr\u003e             sum+=num\u003cbr\u003e    return sum\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg) in (int, float):     \u003cbr\u003e            total += arg\u003cbr\u003e        elif type(arg) in (list, tuple):  \u003cbr\u003e            total += smart_sum(*arg)\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    stack = list(args)\u003cbr\u003e    \u003cbr\u003e    while stack:\u003cbr\u003e        item = stack.pop(0)\u003cbr\u003e        if type(item) == int or type(item) == float:\u003cbr\u003e            total += item\u003cbr\u003e        elif type(item) == list or type(item) == tuple:\u003cbr\u003e            for elem in item:\u003cbr\u003e                stack.append(elem)\u003cbr\u003e    \u003cbr\u003e    return total","analysis.embedding.code_embedding"],["# Liked this question!\u003cbr\u003e\u003cbr\u003edef keep_looping(I, o_I):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Keeps appending integer or float numbers to o_I exhaustively\u003cbr\u003e    \"\"\"\u003cbr\u003e    for i in I:\u003cbr\u003e        if type(i) == int or type(i)==float:\u003cbr\u003e            o_I.append(i)\u003cbr\u003e        else:\u003cbr\u003e            keep_looping(i, o_I)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["#B25MT019_q6\u003cbr\u003edef smart_sum(*n):\u003cbr\u003e    total=0\u003cbr\u003e    def sum(l):# to calculate the sum within the list\u003cbr\u003e        csum=0\u003cbr\u003e        if type(l)==list or type(l)==tuple:\u003cbr\u003e            for j in l:\u003cbr\u003e                csum+=sum(j)\u003cbr\u003e        else:\u003cbr\u003e            csum+=l\u003cbr\u003e        return csum\u003cbr\u003e    for i in n:# to calculate the sum of all the items\u003cbr\u003e        total+=sum(i)\u003cbr\u003e    print(total)\u003cbr\u003esmart_sum([1,[2,[3]]])","analysis.embedding.code_embedding"],["def is_disarium(n):\u003cbr\u003e   \"\"\"A Disarium number is one where the sum of its digits\u003cbr\u003e   raised to their respective positions equals the number itself.\u003cbr\u003e   e.g. 175: 1Ë†1 + 7Ë†2 + 5Ë†3 = 175\"\"\"\u003cbr\u003e   count=0\u003cbr\u003e   for i in str(n):\u003cbr\u003e       count+=int(i)**((str(n).index(i)+1))\u003cbr\u003e   if count==n:\u003cbr\u003e       return True\u003cbr\u003e   else:\u003cbr\u003e       return False\u003cbr\u003e       ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total=0\u003cbr\u003e    for x in args:\u003cbr\u003e        if type(x) in [int,float]:\u003cbr\u003e            total=total+x\u003cbr\u003e        elif type(x) in [list,tuple]:\u003cbr\u003e            total=total+smart_sum(*x)\u003cbr\u003e    return total\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e            ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    tot=0\u003cbr\u003e    for arg in args:\u003cbr\u003e        if type(arg)==int or type(arg)==float: \u003cbr\u003e            tot=tot+arg\u003cbr\u003e        elif type(arg)==list or type(arg)==tuple:  \u003cbr\u003e            for x in arg:\u003cbr\u003e                tot=tot+smart_sum(x)  #recursion\u003cbr\u003e    return tot\u003cbr\u003e\"\"\"Calculates sum of all numeric values provided in the input arguments. \u003cbr\u003eThe arguments can be numbers, lists, or tuples, and the function will (recursively) sum \u003cbr\u003eany numbers contained within nested lists or tuples. Non-numeric values are ignored.\"\"\"","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"Sum all numeric inputs, including numbers contained insidelists or tuples (whichthemselves may be nested arbitrarily). Non-numeric valuesare not expected.Return the sum as an int or float.\"\"\"\u003cbr\u003e    total = 0\u003cbr\u003e    def add_numbers(item):\u003cbr\u003e        nonlocal total\u003cbr\u003e        if isinstance(item, (int, float)):\u003cbr\u003e            total += item\u003cbr\u003e        elif isinstance(item, (list, tuple)):\u003cbr\u003e            for sub_item in item:\u003cbr\u003e                add_numbers(sub_item)\u003cbr\u003e    for arg in args:\u003cbr\u003e        add_numbers(arg)\u003cbr\u003e    return total\u003cbr\u003eresult = smart_sum(1, 2, [3, 4], (5, 6))\u003cbr\u003eprint(\"Smart sum is:\", result)","analysis.embedding.code_embedding"],["\u003cbr\u003e\"\"\"\u003cbr\u003eSum all numeric inputs, including numbers contained inside\u003cbr\u003elists or tuples (which\u003cbr\u003ethemselves may be nested arbitrarily). Non-numeric values\u003cbr\u003eare not expected.\u003cbr\u003eReturn the sum as an int or float.\u003cbr\u003e\"\"\"\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    if type(args)==int:\u003cbr\u003e        return args\u003cbr\u003e    if isinstance(args,(list,tuple)):\u003cbr\u003e        sum=0\u003cbr\u003e        for item in args:\u003cbr\u003e            if isinstance(item,(int,float)):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    total = 0\u003cbr\u003e    for a in args:\u003cbr\u003e        if not isinstance(a, int):\u003cbr\u003e            for t in a:\u003cbr\u003e                if not isinstance(t, int): total += smart_sum(t)\u003cbr\u003e                else: total += t\u003cbr\u003e        else:\u003cbr\u003e            total += a\u003cbr\u003e    return total","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e  count=0\u003cbr\u003e  for i in args:\u003cbr\u003e      if type(i)==list or type(i)==tuple:\u003cbr\u003e          count+=sum(i)\u003cbr\u003e      else:\u003cbr\u003e          count+=i\u003cbr\u003e  return count","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    def recursive_sum(thing):\u003cbr\u003e        if isinstance(thing, (int, float)):\u003cbr\u003e            return thing\u003cbr\u003e        elif isinstance(thing, (list, tuple)):\u003cbr\u003e            return sum(recursive_sum(sub_thing) for sub_thing in thing)\u003cbr\u003e        else:\u003cbr\u003e            return 0  # if in case of unexpected non-numeric types\u003cbr\u003e\u003cbr\u003e    return sum(recursive_sum(arg) for arg in args)\u003cbr\u003e","analysis.embedding.code_embedding"],["args=(1, 2, [3, 4], (5, 6))\u003cbr\u003edef smart_sum(args):\u003cbr\u003e    total=0\u003cbr\u003e    def x(item):\u003cbr\u003e        nonlocal total\u003cbr\u003e        if type(item)==int or type(item)==float:\u003cbr\u003e            total+=item\u003cbr\u003e        elif type(item)==list or type(item)== tuple:\u003cbr\u003e            for i in item:\u003cbr\u003e                x(i)\u003cbr\u003e    for arg in args:\u003cbr\u003e        x(arg)\u003cbr\u003e    return total\u003cbr\u003eprint(smart_sum(args))","analysis.embedding.code_embedding"],["s =0\u003cbr\u003edef smart_sum(*args):\u003cbr\u003e    global s\u003cbr\u003e    for a in args:\u003cbr\u003e        if type(a) == list or type(a)==tuple or type(a)==set:\u003cbr\u003e            smart_sum(*a)\u003cbr\u003e        else : s += a\u003cbr\u003e    return s\u003cbr\u003e\u003cbr\u003eprint(smart_sum([5, 4, 2, [11, 1]]))\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e        \u003cbr\u003e        \u003cbr\u003e    ","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Sum all numeric inputs, including numbers contained inside\u003cbr\u003e    lists or tuples (which\u003cbr\u003e    themselves may be nested arbitrarily). Non-numeric values\u003cbr\u003e    are not expected.\u003cbr\u003e    Return the sum as an int or float.\u003cbr\u003e    \"\"\"\u003cbr\u003e    \u003cbr\u003e    sum1=0\u003cbr\u003e\u003cbr\u003e    if len(args)==1 and type(args[0])!=int:\u003cbr\u003e        args=args[0]\u003cbr\u003e    \u003cbr\u003e    for i in args:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def smart_sum(*args):\u003cbr\u003e    s=0\u003cbr\u003e    for i in args:\u003cbr\u003e        if isinstance(i,(int,float)):\u003cbr\u003e            s+=i\u003cbr\u003e        elif isinstance(i,(list,tuple)):\u003cbr\u003e            s+=smart_sum(*i)\u003cbr\u003e    return s\u003cbr\u003e\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e        ","analysis.embedding.code_embedding"]],"hovertemplate":"\u003cb\u003eStudent ID:\u003c\u002fb\u003e %{hovertext}\u003cbr\u003e\u003cb\u003ePass Percentage:\u003c\u002fb\u003e %{marker.color:.2f}%\u003cbr\u003e\u003cb\u003eSource:\u003c\u002fb\u003e %{customdata[1]}\u003cbr\u003e\u003cbr\u003e\u003cb\u003eCode Snippet:\u003c\u002fb\u003e\u003cbr\u003e%{customdata[0]}\u003cextra\u003e\u003c\u002fextra\u003e","hovertext":["B25ee014_q6","B25CS035_q6","\u003cB25CS031\u003e_q6","B25ME032_q6","B25ME054_q6","B25EE051_q6","b25me039_q6","B25EC026_q6","B25ME011_q6","B25EC030_q6","B25CS019_q6","B25MT014_q6","shourya_q6","B25DS006_q6","B25ME033_Q6","B25CS044_Q6","B25CS002_q6","B25EC010_q6","B25EE009_q6","B25EE056_Q6","B25CS030_q6","B25DS010_Q6","B25ME049_q6","B25ME008_Q6","B25DS032_q6","b25MM015_q6","B25MT022_q6","B25DS029_q6","B25ME034_q6","B25EC020_Q6","B25EC007_q6","B25DS043_q6","B25CS037_q6","B25MT009_Q6","B25ME030 Q6","B25EC036_q6","B25EC015.q6","B25DS020_Q6","B25ME002_q6","B25MT011_q6","B25MM002 q6","B25CS023_q6","B25EC032_ABHISHEK UJVAL_Q6","B25ME026_q6","B25CS004_q6","B25EE043_q6","B25DS039_Q6","B25DS025_q6","B25MM017.q6","B25DS004_q6","B25EC042_q6","B25EE048_q6","B25CS009_q6","B25CS016_q6","B25MM006_q6","B25CS047_q6","B25EC009_Q6","B25CS055_q6","B25CS054_q6","B25DS041_q6","B25ME047_Q6","B25EC011_q6","B25EC038_q6.py","B25DS008_q6","B25EE007_q6","B25EC001_q6","B25DS021 q6","B25Me021_q6","B25DS024_Q6","B25EE017_q6","B25EE054_q6","B25EE001_q6","B25MMO14_q6","B25MM004_q6","B25EE044_q6","B25EE037_q6","B25ME010_q6","B25EC035_q6","B25EC039_q6","B25MT015_q6","B25CS046_q6","B25MT020_Q6","B25CS060_q6","B25ME038_Q6","B25EC019_q6","B25EC002_q6","B25MT031_q6","B25DS028_q6","B25EC022_q6","B25ME048_q6","B25ME001_q6","B25EE053_q6","B25EE029_q6","B25EE003.q6","B25ME012_q6","B25EE013_q6","B25ME050_q6","B25MT021_q6","B25MT024_q6","B25ME027_q6","B25ME035_q6","B25ME024_q6","B25ME022_q6(P5,6)","B25MT017_q6","B25MM009 Q6","B25DS027_q6","B25MM020_q6","B25DS018_q6","q6(B25MM016)","B25Me045_q6","B25EC034_q6","B25ME013_q6","B25DS015_q6","B25ME059_q6","B25CS025_q6","B25EC008_ q6","B25CS029_q6","B25EE019_q6","(q6)B25ME017","b25me036_q6","B25MT018_q6","B25EE026_Q6","B25DS040_q6","B25CS020_q6","B25EE057_Q6","B25EE021_q6","B25EE025_q6","B25MM023_q6","B25DS001_q6","b25cs038 q6","B25CS026_q6","B25MT005_q6","B25EC044_Q6","B25ME051_Q6","B25EE058_q6","B25EC027_q6","B25CS011_q6","B25EC018_q6","B25EC014_q6","B25CS027_Q6","B25EC031_q6","B25ME003_q6","s25ma008_q6","B25EE011_q6","B25MT006_q6","B25EE038.Q6","B25CS041_q6","B25ME009_q6","B25CS056_q6","B25ME060_q6","B25MM021_q6","B25MT004_q6","B25MT007_q6","B25EC045_q6","B25EE015_Q6","B25MT032_q6","B25EE042_q6","B25EE036_q6","B25CS021_q6","B25MM008_q6","B25EC017_q6","B25EE034_q6","B25MM025_q6","B25DS034_q6","B25DS007_q6","B25ME029_q6","B25ME028_q6.py","\u003cB25CS024\u003e_q6","B25MT003_q6","B25DS017_q6","B25EE004_q6","B25CS022_q6","B25EC029.q6","B25CS008_Q6","B25MT016_q6","\u003cB25DS005\u003e_q6","B25DS023_q6","B25ME018_q6","B25EC003_Q6","B25MM027_q6","S25MA018_q6","B25CS014_q6","B25EE049_Q6","B25DS014_q6","B25ME007_q6","B25EE060_q6","B25EC006_q6","B25CS007_Q6","B25MM013_q6","B25ME056_q6","B25EE022_q6","B25ME004_Q6.py","B25DS022_Q6","B25ME006_q6","B25EE055_q6","B25EC043_q6","B25MT002_q6","B25ME005_q6","B25DS035_q6","B25EC037_q6","B25CS039_q6","B25MT023\u003cQ6\u003e","\u003cB25CS036\u003e__q6","B25EC041_q6","B25EC021_q6","B25CS005_Q6","B25MT010_q6","B25CS010_q6","B25MM028_q6","B25CS042_Q6","B25Me037_q6","B25EC024_q6","B25CS013_q6","B25DS003_q6","B25CS034_q6","B25DS019_q6","B25ME043_q6","B25EC013_q6","B25DS026.q6","B25ME041_q6","B25CS062_q6","B25EE033.q6","q6_B25ME046","B25mm018_q6","S25MA001_q6","B25EE020_q6","B25CS061_q6","(B25DS042)_(Q6)","B25MT008_q6","B25ME014_q6.py","B25MT027_q6","B25MT026_q6","B25EE045_q6","B25EE031_q6","B25EE023_q6","B25EE050_q6","B25MM007_q6","B25CS033_q6","B25MT019_q6","B25DS030_q6","B25CS051_q6","B25ME058_q6","B25CS045_Q6","B25EE035.Q6","B25DS012_q6","B25DS016_q6","B25EE006 Q6","B25EC033_q6","B25MT029_Q6","B25CS059_q6","B25MM026_q6"],"legendgroup":"","marker":{"color":{"dtype":"f8","bdata":"AAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAADgVUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABJQAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAADAUkAAAAAAAAAAAAAAAAAAwFJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAQE9AAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAwEJAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAASUAAAAAAAAApQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAABAT0AAAAAAAAAAAAAAAAAAAAAAAAAAAADgVUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAElAAAAAAADgVUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAElAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAQE9AAAAAAAAAAAAAAAAAAABZQAAAAAAAADlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAADAQkAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAElAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAADAQkAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAElAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwFJAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAElAAAAAAAAASUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAABJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAASUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAElAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQE9AAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAASUAAAAAAAAApQAAAAAAAAClAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAKUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAADgVUAAAAAAAAAAAAAAAAAAwEJAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAABAT0AAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAOBVQAAAAAAAAElAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQA=="},"coloraxis":"coloraxis","symbol":"circle","line":{"color":"DarkSlateGrey","width":1},"size":12},"mode":"markers","name":"","orientation":"v","showlegend":false,"x":{"dtype":"f4","bdata":"X+JZPlnwt78EO0lBj\u002fk9wJRzPb9gXEpBe7UowNh+KcDMp\u002fC\u002fo\u002fn2v8wDCcBP0zlBSy0DwOtHHsBT94O+QOk9QVYqgMDKSgjAK2TOv1oQSsBELztBtnxAwJsUEj\u002frIkPA4Du4Ph++\u002fT4seVy+ORJMQQToLb\u002fNyum\u002fiYJVvlfnOkFkvzbAixIbwLBN1bsWTdM++BktwDYq6L+e+Se\u002fVyqhP35xPUEhvExBFU9EQSsd37+FaJu\u002fPsv4v3AW+L+x8EtByYEuPzN5HcC+w4LAuL1ewInyRUGSegbApOkuvx7cKcBeLUZBjtdJQcO2E8CpikFBtUmyvqONOEERa4W8FjUXvnXLHcBGLvG\u002fb2A9QTR3DcCCRbu+0KA6QbwHMb9O84M8GSwHv4ySo7+BiCDAoLoIwLlFAMAobThBIwnCv9TBmj46wkNBxN07QR2q6r8XOJ8\u002f37lHQTuUTUFKYjtBgthIQVOHYr+HN0tB3ptCwKFVA77MACPAWmofv+nr278bM6s\u002fItqYvgonjT786Cu+sWkswEaiH8DLbT2\u002f2vkKPgVLBj8z86u++0zWv7v4EcD+gCm\u002f8vTwvhz9C8AqQx7AK1pIQR7ISUGIwd2\u002fD7EDwIgwPEFtgkvASqL7v4BKJsDyxjpBJnEcwHLH+L8JVP8+hs1PwLDdsD8DN0VBG5qTvFDtM8BokkPAUgiOPjXLOEEYOEZB\u002fFcEwOnh1L\u002f0X7W+Yn05QbhtHsCOdwjA6fZGQT\u002fjoz\u002fcxEpBNlcpwHUiO7+K2Wo+0c4HP2Q1SUEdlUlBlOb9vyPqQUFiH5a\u002f0jU6QZKA9L+MaILAseNZwHfOOUGglDDANzY8QZaZRUEQZy3Ar3a5Pq1Jtb9dLkbAFBEYwE4Enb8iXwbAxd0XwLJE5T4Lzq0+ZxUcwFZHgsADxNW\u002fPzVOQX9Vy76YQDZBwFQkPwtVir+0fyDAtKRPQZaqM8DW0mS\u002fVBQiv4kDQ0GiBEdB7Mk1wO8bS79EKyTAC+hQQU+rAsDMA4a\u002fvS1JQXyWgsBzt5k9S+3dv6oyvb7Y0AnAFpUWwG5fQkFttlfAi3k5wGko579SygrAzHJkP05s2D3Q7wPA+RP2v39B77\u002fTtRPAQBJRQd9QrD\u002fC\u002fBDAIA4IwNWsQ0Ei1zA+x6e8v1QNSUEdmXW\u002fOZX3Pu7p8r968ac\u002fntarv9\u002f5gMAg4qg+fWtEvuBLDcA6qqE\u002f5mZZwDaaN7\u002ftK9o+igxOwFzhT0EMxGO9C0E\u002fQSWqOcAPNTvA\u002fTAjwMtCXL+SZFW+TObyv\u002fil3L+L1yfAiVcJwBlImrzP+DhBgXE2QbbPlL\u002f1n1nA9vC+Oypagb+8yey\u002f1ehMQf1HIMA="},"xaxis":"x","y":{"dtype":"f4","bdata":"AgUTwLLJGL\u002fdqLVAreFmv8mhMsB8CehA7jLev11Ekz++fCo\u002ftJ3vP3kxeD85GdhA799pwD\u002fOjT9VPAw+0cWrQFMjgj+reGjAP31OP7Y83r5OjcNA319uvk3gnr9Ip42+zxNlv\u002fA8h79JETDAHvnUQM7SKsBBWVm\u002fpPIxwNbZzUD1U9e\u002fDfh5Py0Fwb5rVPm+TdL\u002fvprFCz8NNjbAxQkuvx4l7ECk7s9A8LCvQIXeL8CmhOw+121cv0eY\u002fb9tPtdAXRCEv8u5K7+i4Jw\u002feOSsP4trwkC8tby+i8rtPpgqAr2kWsFAExrbQKUMvT+po7dAlB42wKa91UCTdIa9MxIvPgQX0j+pRBY+LAjsQNTjZsBV47K\u002fY3epQJcgNsAudCfAYx5RvrsYRsBY3ps\u002fpubpP9ZF07\u002fQfqRA2Pgnv\u002fEFEMC94rlA24LYQBiRZD+VvY4+CfHEQPd31EDyNuVAp2nkQL132L6vntZAGJpZv5x8M8CJi9M\u002f2liyvkIThj+WcLk+o0UFwF5AKL9H8nw9R1i3vws+hb9XODDASY4Lv8Ohlb4iVg+7zXyOP6rcAUA9USw\u002fvX0Yvf4NZcBL+vc\u002f8GG2QM0EskAkVo8\u002fsfufPydUz0DtT4W\u002fiIhlwPv3iz0h5edAA+G\u002fv2qxs7\u002frjsm\u002fpew5vx6EEr+d391AoGOzv+ewwL91KgG\u002fHRcCwKHI00C9Bt1A5Hp8P4Aykb9xXm490x+mQAaMzr57eJI\u002fLwnCQJhLoj7+hONAqR21v848mj7y4RO\u002fMIzJvtSvtEBWnONAnzXPP4beu0B\u002fKyvA+ZLFQF6lZsClu6g\u002fWpBFvxJIp0BVRM2\u002fckzAQL69ukAaNNU\u002fMp+Fv5YCKMBwaZ2+vzr7P4O\u002faj9sdGPA1nHjP6KUdb8VUlW+H6vmPpHYqz8J7Ku\u002fNJ7GQLpy3L6GWqJAD1lLvy33pj\u002fQjcw\u002fe4vaQEGbBL9SV8++RxEIP2Gh30C50NNAKozcv+zkEr+cGe4\u002fv5fZQMaLZsDiptm9Gk3jQJDVoT\u002f6G7a\u002fkfW5PyHKA75oSPA\u002foQKxP4CZ1EAZfL4\u002fODPdvZfuvz\u002frRhBA1dunv6Sqob6DH2y+xoGXPJXBoL\u002fj1q+\u002fL+fdQAwMPb+xMaW\u002fDe9hwLRi2UDI2BvAzbwewAZw3ED+Bri\u002fmNDFvu0pNcDcyCW\u002fOLomwNiyoz+xixXAYOcQvkiEZsANLB6\u002fEF1wv+OJOcAwOT6\u002fJh2Kv3Q+zkB2H+A+E+W3QOsF278uHiS+9uIOP8rQP8A8DyPAcrtFvyuJPD\u002f3Qfy+YoNfwJL8BT8xbMVAna6rQHjzLcBNH6I\u002f03Hdv6Twnz915AQ+oSLPQMrcwr8="},"yaxis":"y","type":"scatter"}],                        {"template":{"data":{"histogram2dcontour":[{"type":"histogram2dcontour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"choropleth":[{"type":"choropleth","colorbar":{"outlinewidth":0,"ticks":""}}],"histogram2d":[{"type":"histogram2d","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"heatmap":[{"type":"heatmap","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"contourcarpet":[{"type":"contourcarpet","colorbar":{"outlinewidth":0,"ticks":""}}],"contour":[{"type":"contour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"surface":[{"type":"surface","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"mesh3d":[{"type":"mesh3d","colorbar":{"outlinewidth":0,"ticks":""}}],"scatter":[{"fillpattern":{"fillmode":"overlay","size":10,"solidity":0.2},"type":"scatter"}],"parcoords":[{"type":"parcoords","line":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolargl":[{"type":"scatterpolargl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"bar":[{"error_x":{"color":"#2a3f5f"},"error_y":{"color":"#2a3f5f"},"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"scattergeo":[{"type":"scattergeo","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolar":[{"type":"scatterpolar","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"scattergl":[{"type":"scattergl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatter3d":[{"type":"scatter3d","line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattermap":[{"type":"scattermap","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattermapbox":[{"type":"scattermapbox","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterternary":[{"type":"scatterternary","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattercarpet":[{"type":"scattercarpet","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"carpet":[{"aaxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"baxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"type":"carpet"}],"table":[{"cells":{"fill":{"color":"#EBF0F8"},"line":{"color":"white"}},"header":{"fill":{"color":"#C8D4E3"},"line":{"color":"white"}},"type":"table"}],"barpolar":[{"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"pie":[{"automargin":true,"type":"pie"}]},"layout":{"autotypenumbers":"strict","colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#2a3f5f"},"hovermode":"closest","hoverlabel":{"align":"left"},"paper_bgcolor":"white","plot_bgcolor":"#E5ECF6","polar":{"bgcolor":"#E5ECF6","angularaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"radialaxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"ternary":{"bgcolor":"#E5ECF6","aaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"baxis":{"gridcolor":"white","linecolor":"white","ticks":""},"caxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"sequential":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"sequentialminus":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]]},"xaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"yaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"scene":{"xaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"yaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"zaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2}},"shapedefaults":{"line":{"color":"#2a3f5f"}},"annotationdefaults":{"arrowcolor":"#2a3f5f","arrowhead":0,"arrowwidth":1},"geo":{"bgcolor":"white","landcolor":"#E5ECF6","subunitcolor":"white","showland":true,"showlakes":true,"lakecolor":"white"},"title":{"x":0.05},"mapbox":{"style":"light"}}},"xaxis":{"anchor":"y","domain":[0.0,1.0],"title":{"text":"UMAP Dim 1"},"gridcolor":"lightgray"},"yaxis":{"anchor":"x","domain":[0.0,1.0],"title":{"text":"UMAP Dim 2"},"gridcolor":"lightgray"},"coloraxis":{"colorbar":{"title":{"text":"Pass %"},"ticks":"outside","dtick":20},"colorscale":[[0.0,"rgb(0,0,0)"],[0.3333333333333333,"rgb(230,0,0)"],[0.6666666666666666,"rgb(255,210,0)"],[1.0,"rgb(255,255,255)"]],"cmin":0,"cmax":100},"legend":{"tracegroupgap":0,"title":{"text":"Pass Percentage"}},"title":{"text":"Code Submission Semantic Map â€” practice5_6_q6 (UMAP)"},"plot_bgcolor":"white","paper_bgcolor":"white"},                        {"responsive": true}                    )                };            </script>        </div>
<script>
(function() {
  const divId = "plot_practice5_6_q6";
  const gd = document.getElementById(divId);
  const xs = [0.21277759969234467, -1.43702232837677, 12.576908111572266, -2.9683568477630615, -0.7400448322296143, 12.647552490234375, -2.6360766887664795, -2.648366928100586, -1.8801207542419434, -1.9294933080673218, -2.1408567428588867, 11.614089012145996, -2.0496394634246826, -2.473139524459839, -0.25774630904197693, 11.86944580078125, -4.0051679611206055, -2.1295647621154785, -1.6124318838119507, -3.157248020172119, 11.699039459228516, -3.0076117515563965, 0.5706269145011902, -3.049006223678589, 0.3598318099975586, 0.4955911338329315, -0.21530598402023315, 12.754448890686035, -0.6793215274810791, -1.826501488685608, -0.2085057646036148, 11.681479454040527, -2.85543155670166, -2.423006772994995, -0.006509505212306976, 0.4126974940299988, -2.704710006713867, -1.8137881755828857, -0.656152606010437, 1.259104609489441, 11.840208053588867, 12.795929908752441, 12.269307136535645, -1.7430776357650757, -1.2141271829605103, -1.9437024593353271, -1.9381847381591797, 12.746262550354004, 0.6816678643226624, -2.460522413253784, -4.086394309997559, -3.4803295135498047, 12.371712684631348, -2.101231098175049, -0.6832525730133057, -2.654059886932373, 12.386075973510742, 12.61512565612793, -2.308029890060425, 12.096352577209473, -0.3482185900211334, 11.534579277038574, -0.01628640480339527, -0.1476634442806244, -2.465543031692505, -1.8842246532440186, 11.836043357849121, -2.2104005813598633, -0.36576467752456665, 11.664260864257812, -0.6915242671966553, 0.016107227653265, -0.5280166268348694, -1.277909755706787, -2.508331537246704, -2.1363906860351562, -2.004255533218384, 11.526649475097656, -1.5159038305282593, 0.30226004123687744, 12.234918594360352, 11.741641998291016, -1.833316445350647, 1.2438992261886597, 12.482878684997559, 12.848689079284668, 11.711496353149414, 12.552858352661133, -0.8848773837089539, 12.701056480407715, -3.0407633781433105, -0.12825633585453033, -2.5469236373901367, -0.6227165460586548, -1.7181369066238403, 1.3374971151351929, -0.2985392212867737, 0.2756884694099426, -0.16788095235824585, -2.693950891494751, -2.494279384613037, -0.7399565577507019, 0.13571873307228088, 0.5245822072029114, -0.3358398377895355, -1.6742242574691772, -2.280806303024292, -0.662124514579773, -0.4706187844276428, -2.187323570251465, -2.4728493690490723, 12.522013664245605, 12.611356735229492, -1.732468605041504, -2.0576817989349365, 11.761848449707031, -3.179835557937622, -1.9658901691436768, -2.598297119140625, 11.67357063293457, -2.444406032562256, -1.9435865879058838, 0.4986880123615265, -3.2469191551208496, 1.381765365600586, 12.32593059539795, -0.01801781915128231, -2.811359405517578, -3.0558109283447266, 0.2774072289466858, 11.54961109161377, 12.388694763183594, -2.0678701400756836, -1.6631442308425903, -0.35424768924713135, 11.593111038208008, -2.4754467010498047, -2.1322970390319824, 12.435280799865723, 1.2803725004196167, 12.67306137084961, -2.6459479331970215, -0.7309945225715637, 0.22934547066688538, 0.5304995179176331, 12.57553482055664, 12.598904609680176, -1.9835991859436035, 12.119662284851074, -1.172832727432251, 11.638139724731445, -1.9101736545562744, -4.075262069702148, -3.404522180557251, 11.612906455993652, -2.7590713500976562, 11.763236045837402, 12.349996566772461, -2.7094154357910156, 0.36223360896110535, -1.4163109064102173, -3.0965797901153564, -2.376042366027832, -1.226693868637085, -2.0995564460754395, -2.372910737991333, 0.44778972864151, 0.33946260809898376, -2.4388062953948975, -4.0712080001831055, -1.6700443029403687, 12.887999534606934, -0.3971366584300995, 11.390769958496094, 0.6419181823730469, -1.08072030544281, -2.5077943801879883, 12.977710723876953, -2.8072867393493652, -0.8938421010971069, -0.6331226825714111, 12.188363075256348, 12.438631057739258, -2.840449333190918, -0.7933949828147888, -2.565140724182129, 13.05665111541748, -2.041705846786499, -1.0469908714294434, 12.5736665725708, -4.080869674682617, 0.07505693286657333, -1.7338041067123413, -0.3695271611213684, -2.153371810913086, -2.3528494834899902, 12.148298263549805, -3.370509386062622, -2.898043394088745, -1.8059207201004028, -2.1685986518859863, 0.8923766613006592, 0.10567532479763031, -2.061511993408203, -1.9224845170974731, -1.869186282157898, -2.3079726696014404, 13.06695556640625, 1.3462179899215698, -2.2654271125793457, -2.1258621215820312, 12.229695320129395, 0.17269566655158997, -1.4738701581954956, 12.565753936767578, -0.959367573261261, 0.48356035351753235, -1.897763967514038, 1.3120567798614502, -1.342487096786499, -4.030501842498779, 0.3298501968383789, -0.1918162852525711, -2.2077560424804688, 1.263007402420044, -3.3969054222106934, -0.7171968221664429, 0.42611637711524963, -3.219515323638916, 12.99251937866211, -0.05560688674449921, 11.95337963104248, -2.9010097980499268, -2.9251134395599365, -2.5498650074005127, -0.8603941798210144, -0.2083914577960968, -1.8976531028747559, -1.7238149642944336, -2.622530698776245, -2.145967721939087, -0.018833206966519356, 11.560744285583496, 11.402710914611816, -1.1625888347625732, -3.40038800239563, 0.005827064625918865, -1.0105640888214111, -1.8499064445495605, 12.806843757629395, -2.5043938159942627];
  const ys = [-2.297180652618408, -0.5968276262283325, 5.676863193511963, -0.9018810391426086, -2.7911245822906494, 7.251157760620117, -1.735929250717163, 1.1505237817764282, 0.6659659147262573, 1.8720002174377441, 0.9695048928260803, 6.753078937530518, -3.6542928218841553, 1.1078566312789917, 0.13694889843463898, 5.3678975105285645, 1.0167030096054077, -3.6323649883270264, 0.8065986037254333, -0.43405693769454956, 6.11099910736084, -0.2327875941991806, -1.2412201166152954, -0.27666687965393066, -0.894833505153656, -1.0565471649169922, -2.7510550022125244, 6.655409812927246, -2.669116497039795, -0.8490181565284729, -2.7804346084594727, 6.4328413009643555, -1.682249665260315, 0.9764412045478821, -0.3769926130771637, -0.4869721829891205, -0.49965134263038635, 0.5459839105606079, -2.8470489978790283, -0.6798365712165833, 7.379530906677246, 6.497880935668945, 5.490348815917969, -2.7479565143585205, 0.46194952726364136, -0.8610510230064392, -1.981209635734558, 6.726370334625244, -1.0317493677139282, -0.6708037257194519, 1.2256052494049072, 1.350722312927246, 6.07562780380249, -0.36857402324676514, 0.4644359052181244, -0.03177890181541443, 6.042314529418945, 6.846932888031006, 1.4769483804702759, 5.738728046417236, -2.845616340637207, 6.679400444030762, -0.065652035176754, 0.17096786201000214, 1.6413273811340332, 0.14674629271030426, 7.375997543334961, -3.6076555252075195, -1.3975626230239868, 5.295823574066162, -2.8457391262054443, -2.6164660453796387, -0.20421747863292694, -3.095259428024292, 1.2177228927612305, 1.8273513317108154, -1.6505687236785889, 5.140480041503906, -0.6561408042907715, -2.2503626346588135, 5.8089280128479, 6.7659735679626465, 0.8928389549255371, 0.278790146112442, 6.154423236846924, 6.639644145965576, 7.162957191467285, 7.13789701461792, -0.42278853058815, 6.7068705558776855, -0.8500075340270996, -2.80448055267334, 1.6526957750320435, -0.3483341336250305, 1.0474627017974854, 0.36218708753585815, -2.0823752880096436, -0.6572321653366089, 0.0617544911801815, -1.432381510734558, -1.040955901145935, -2.753438711166382, -0.5451398491859436, -0.29224976897239685, -0.002187140751630068, 1.113183617591858, 2.0290932655334473, 0.6731145977973938, -0.03722928836941719, -3.578979015350342, 1.9373258352279663, 5.699455261230469, 5.563086032867432, 1.1198163032531738, 1.2498685121536255, 6.47902250289917, -1.0415016412734985, -3.586458206176758, 0.06834407895803452, 7.246719837188721, -1.4990543127059937, -1.4038517475128174, -1.5746740102767944, -0.7262671589851379, -0.5723284482955933, 6.933546543121338, -1.4014778137207031, -1.5053986310958862, -0.5045540928840637, -2.032660722732544, 6.618240833282471, 6.9070725440979, 0.9862501621246338, -1.1343536376953125, 0.058195535093545914, 5.191384792327881, -0.4034120440483093, 1.1443017721176147, 6.0636210441589355, 0.3169829845428467, 7.109984397888184, -1.414967656135559, 0.30124515295028687, -0.5776664018630981, -0.3936476707458496, 5.646463394165039, 7.1128339767456055, 1.6188238859176636, 5.870913505554199, -2.674529790878296, 6.174190998077393, -3.6038432121276855, 1.3182264566421509, -0.7717338800430298, 5.227547645568848, -1.6036478281021118, 6.009331703186035, 5.835661888122559, 1.6656525135040283, -1.0439207553863525, -2.6251578330993652, -0.30744504928588867, 1.9627302885055542, 0.9169847369194031, -3.553980827331543, 1.7769114971160889, -0.9592992067337036, -0.20832093060016632, 0.45052430033683777, 1.3425465822219849, -1.343140721321106, 6.206811904907227, -0.4305627942085266, 5.073550224304199, -0.7943276762962341, 1.3044182062149048, 1.5980777740478516, 6.829526424407959, -0.5179939866065979, -0.40496307611465454, 0.5315136313438416, 6.988449573516846, 6.619228839874268, -1.7230274677276611, -0.573805570602417, 1.860156536102295, 6.799773693084717, -3.602281093597412, -0.10627533495426178, 7.103161811828613, 1.2643299102783203, -1.4227287769317627, 1.4528065919876099, -0.12870074808597565, 1.8772096633911133, 1.3828927278518677, 6.64373779296875, 1.4881621599197388, -0.10800784826278687, 1.4994686841964722, 2.254328489303589, -1.3113962411880493, -0.3157550096511841, -0.23058895766735077, 0.01849449798464775, -1.255907654762268, -1.373745322227478, 6.9344706535339355, -0.7384650707244873, -1.2905789613723755, -3.5302155017852783, 6.793298721313477, -2.4351062774658203, -2.480273485183716, 6.888674736022949, -1.437713384628296, -0.38635706901550293, -2.830683946609497, -0.6475961208343506, -2.6051158905029297, 1.278895378112793, -2.336651086807251, -0.14150762557983398, -3.6018238067626953, -0.6178596615791321, -0.9389200210571289, -2.899040937423706, -0.7430601119995117, -1.079014539718628, 6.445123672485352, 0.4377400279045105, 5.746713161468506, -1.7111181020736694, -0.16027137637138367, 0.5581506490707397, -2.9971184730529785, -2.547804832458496, -0.7723914384841919, 0.7364680171012878, -0.492690771818161, -3.492393970489502, 0.5233851671218872, 6.169456958770752, 5.365065097808838, -2.717985153198242, 1.2665802240371704, -1.7300361394882202, 1.2495312690734863, 0.12977774441242218, 6.472977161407471, -1.5223629474639893];
  const ids = ["B25ee014_q6", "B25CS035_q6", "<B25CS031>_q6", "B25ME032_q6", "B25ME054_q6", "B25EE051_q6", "b25me039_q6", "B25EC026_q6", "B25ME011_q6", "B25EC030_q6", "B25CS019_q6", "B25MT014_q6", "shourya_q6", "B25DS006_q6", "B25ME033_Q6", "B25CS044_Q6", "B25CS002_q6", "B25EC010_q6", "B25EE009_q6", "B25EE056_Q6", "B25CS030_q6", "B25DS010_Q6", "B25ME049_q6", "B25ME008_Q6", "B25DS032_q6", "b25MM015_q6", "B25MT022_q6", "B25DS029_q6", "B25ME034_q6", "B25EC020_Q6", "B25EC007_q6", "B25DS043_q6", "B25CS037_q6", "B25MT009_Q6", "B25ME030 Q6", "B25EC036_q6", "B25EC015.q6", "B25DS020_Q6", "B25ME002_q6", "B25MT011_q6", "B25MM002 q6", "B25CS023_q6", "B25EC032_ABHISHEK UJVAL_Q6", "B25ME026_q6", "B25CS004_q6", "B25EE043_q6", "B25DS039_Q6", "B25DS025_q6", "B25MM017.q6", "B25DS004_q6", "B25EC042_q6", "B25EE048_q6", "B25CS009_q6", "B25CS016_q6", "B25MM006_q6", "B25CS047_q6", "B25EC009_Q6", "B25CS055_q6", "B25CS054_q6", "B25DS041_q6", "B25ME047_Q6", "B25EC011_q6", "B25EC038_q6.py", "B25DS008_q6", "B25EE007_q6", "B25EC001_q6", "B25DS021 q6", "B25Me021_q6", "B25DS024_Q6", "B25EE017_q6", "B25EE054_q6", "B25EE001_q6", "B25MMO14_q6", "B25MM004_q6", "B25EE044_q6", "B25EE037_q6", "B25ME010_q6", "B25EC035_q6", "B25EC039_q6", "B25MT015_q6", "B25CS046_q6", "B25MT020_Q6", "B25CS060_q6", "B25ME038_Q6", "B25EC019_q6", "B25EC002_q6", "B25MT031_q6", "B25DS028_q6", "B25EC022_q6", "B25ME048_q6", "B25ME001_q6", "B25EE053_q6", "B25EE029_q6", "B25EE003.q6", "B25ME012_q6", "B25EE013_q6", "B25ME050_q6", "B25MT021_q6", "B25MT024_q6", "B25ME027_q6", "B25ME035_q6", "B25ME024_q6", "B25ME022_q6(P5,6)", "B25MT017_q6", "B25MM009 Q6", "B25DS027_q6", "B25MM020_q6", "B25DS018_q6", "q6(B25MM016)", "B25Me045_q6", "B25EC034_q6", "B25ME013_q6", "B25DS015_q6", "B25ME059_q6", "B25CS025_q6", "B25EC008_ q6", "B25CS029_q6", "B25EE019_q6", "(q6)B25ME017", "b25me036_q6", "B25MT018_q6", "B25EE026_Q6", "B25DS040_q6", "B25CS020_q6", "B25EE057_Q6", "B25EE021_q6", "B25EE025_q6", "B25MM023_q6", "B25DS001_q6", "b25cs038 q6", "B25CS026_q6", "B25MT005_q6", "B25EC044_Q6", "B25ME051_Q6", "B25EE058_q6", "B25EC027_q6", "B25CS011_q6", "B25EC018_q6", "B25EC014_q6", "B25CS027_Q6", "B25EC031_q6", "B25ME003_q6", "s25ma008_q6", "B25EE011_q6", "B25MT006_q6", "B25EE038.Q6", "B25CS041_q6", "B25ME009_q6", "B25CS056_q6", "B25ME060_q6", "B25MM021_q6", "B25MT004_q6", "B25MT007_q6", "B25EC045_q6", "B25EE015_Q6", "B25MT032_q6", "B25EE042_q6", "B25EE036_q6", "B25CS021_q6", "B25MM008_q6", "B25EC017_q6", "B25EE034_q6", "B25MM025_q6", "B25DS034_q6", "B25DS007_q6", "B25ME029_q6", "B25ME028_q6.py", "<B25CS024>_q6", "B25MT003_q6", "B25DS017_q6", "B25EE004_q6", "B25CS022_q6", "B25EC029.q6", "B25CS008_Q6", "B25MT016_q6", "<B25DS005>_q6", "B25DS023_q6", "B25ME018_q6", "B25EC003_Q6", "B25MM027_q6", "S25MA018_q6", "B25CS014_q6", "B25EE049_Q6", "B25DS014_q6", "B25ME007_q6", "B25EE060_q6", "B25EC006_q6", "B25CS007_Q6", "B25MM013_q6", "B25ME056_q6", "B25EE022_q6", "B25ME004_Q6.py", "B25DS022_Q6", "B25ME006_q6", "B25EE055_q6", "B25EC043_q6", "B25MT002_q6", "B25ME005_q6", "B25DS035_q6", "B25EC037_q6", "B25CS039_q6", "B25MT023<Q6>", "<B25CS036>__q6", "B25EC041_q6", "B25EC021_q6", "B25CS005_Q6", "B25MT010_q6", "B25CS010_q6", "B25MM028_q6", "B25CS042_Q6", "B25Me037_q6", "B25EC024_q6", "B25CS013_q6", "B25DS003_q6", "B25CS034_q6", "B25DS019_q6", "B25ME043_q6", "B25EC013_q6", "B25DS026.q6", "B25ME041_q6", "B25CS062_q6", "B25EE033.q6", "q6_B25ME046", "B25mm018_q6", "S25MA001_q6", "B25EE020_q6", "B25CS061_q6", "(B25DS042)_(Q6)", "B25MT008_q6", "B25ME014_q6.py", "B25MT027_q6", "B25MT026_q6", "B25EE045_q6", "B25EE031_q6", "B25EE023_q6", "B25EE050_q6", "B25MM007_q6", "B25CS033_q6", "B25MT019_q6", "B25DS030_q6", "B25CS051_q6", "B25ME058_q6", "B25CS045_Q6", "B25EE035.Q6", "B25DS012_q6", "B25DS016_q6", "B25EE006 Q6", "B25EC033_q6", "B25MT029_Q6", "B25CS059_q6", "B25MM026_q6"];
  let searchTraceIndex = null;

  function updateSearch(query) {
    // remove prior search trace
    if (searchTraceIndex !== null && gd.data && gd.data[searchTraceIndex]) {
      Plotly.deleteTraces(gd, searchTraceIndex);
      searchTraceIndex = null;
    }
    query = (query || "").toLowerCase().trim();
    if (!query) return;
    const hits = [];
    for (let i=0; i<ids.length; i++) {
      if ((ids[i] || "").toLowerCase().includes(query)) {
        hits.push(i);
      }
    }
    if (!hits.length) return;
    const trace = {
      x: hits.map(i => xs[i]),
      y: hits.map(i => ys[i]),
      mode: 'markers+text',
      text: hits.map(i => ids[i]),
      textposition: 'top center',
      marker: {
        symbol: 'star',
        size: 20,
        color: 'rgba(0,0,0,0)',
        line: { color: 'red', width: 3 }
      },
      name: 'Search',
      hoverinfo: 'skip'
    };
    Plotly.addTraces(gd, [trace]).then(idxs => {
      searchTraceIndex = idxs[0];
    });
  }

  function initControls() {
    const input = document.getElementById('searchBox');
    const btn = document.getElementById('searchBtn');
    if (!input || !btn) return;

    // Click button triggers search
    btn.addEventListener('click', () => updateSearch(input.value));

    // Pressing Enter in input triggers search
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        btn.click();
      }
    });
  }

  // Wait until Plotly figure is ready, then init controls
  if (gd) {
    if (gd._fullLayout) {
      initControls();
    } else {
      gd.addEventListener('plotly_afterplot', initControls, { once: true });
    }
  }
})();
</script>
</body></html>
<!DOCTYPE html><html><head><meta charset='utf-8'><title>csl100_q18 Embeddings</title></head><body>
<div style="margin: 8px 0; display:flex; gap:12px; align-items:center; flex-wrap: wrap;">
  <label><b>Search Roll No:</b></label>
  <input id="searchBox" type="text" placeholder="e.g., B25DS024" style="padding:6px 8px; width:220px;">
  <button id="searchBtn" style="padding:6px 12px; cursor:pointer;">Search</button>
  <span style="color:#666;">(Click Search to highlight matches on the plot)</span>
</div>
<div>                        <script type="text/javascript">window.PlotlyConfig = {MathJaxConfig: 'local'};</script>
        <script charset="utf-8" src="https://cdn.plot.ly/plotly-3.0.1.min.js" integrity="sha256-oy6Be7Eh6eiQFs5M7oXuPxxm9qbJXEtTpfSI93dW16Q=" crossorigin="anonymous"></script>                <div id="plot_csl100_q18" class="plotly-graph-div" style="height:100%; width:100%;"></div>            <script type="text/javascript">                window.PLOTLYENV=window.PLOTLYENV || {};                                if (document.getElementById("plot_csl100_q18")) {                    Plotly.newPlot(                        "plot_csl100_q18",                        [{"customdata":[["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    if subset_sum(nums[1:],target-nums[0]):\u003cbr\u003e        return True\u003cbr\u003e    if subset_sum(nums[1:],target):\u003cbr\u003e        return True\u003cbr\u003e    return False\u003cbr\u003e    \u003cbr\u003e#example\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))\u003cbr\u003eprint(subset_sum([],0))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    \u003cbr\u003e    return include or exclude","analysis.embedding.code_embedding"],["def subset_sum(nums, target): \u003cbr\u003e    if len(nums) == 0:\u003cbr\u003e        return 0 == target\u003cbr\u003e    \u003cbr\u003e    for i in range(len(nums)):\u003cbr\u003e        if subset_sum(nums[i+1:], target - nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e    return False","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e\u003cbr\u003e    k = [i for i in nums if i &lt;= target]\u003cbr\u003e    if not k or target &lt; 0:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    # Include first element of filtered list\u003cbr\u003e    if subset_sum(k[1:], target - k[0]):\u003cbr\u003e        return True\u003cbr\u003e\u003cbr\u003e    # Exclude first element\u003cbr\u003e    if subset_sum(k[1:], target):\u003cbr\u003e        return True\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    if subset_sum(nums[1:], target - nums[0]):\u003cbr\u003e        return True\u003cbr\u003e    if subset_sum(nums[1:], target):\u003cbr\u003e        return True\u003cbr\u003e    return False\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \u003cbr\u003e    # Base cases\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    # Recursive choice:\u003cbr\u003e    # 1️⃣ Include the first element\u003cbr\u003e    # 2️⃣ Exclude the first element\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e    return include or exclude\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    first=nums[0]\u003cbr\u003e    rest=nums[1:]\u003cbr\u003e    exclude=subset_sum(rest,target)\u003cbr\u003e    include=subset_sum(rest,target-first)\u003cbr\u003e    if include or exclude:\u003cbr\u003e        return True\u003cbr\u003e    else:\u003cbr\u003e        return False","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True          \u003cbr\u003e    if not nums:\u003cbr\u003e        return False              \u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e    return include or exclude\u003cbr\u003enums=[3,34,4,12,5,2]\u003cbr\u003etarget=9\u003cbr\u003eprint(subset_sum(nums, target))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    memo = {}\u003cbr\u003e    def helper(i, t):\u003cbr\u003e        if t == 0:\u003cbr\u003e            return True\u003cbr\u003e        if i == len(nums):\u003cbr\u003e            return False\u003cbr\u003e        key = (i, t)\u003cbr\u003e        if key in memo:\u003cbr\u003e            return memo[key]\u003cbr\u003e\u003cbr\u003e        if nums[i] &lt;= t and helper(i+1, t - nums[i]):\u003cbr\u003e            memo[key] = True\u003cbr\u003e            return True\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\u003cbr\u003edef fac(n):\u003cbr\u003e    if n==0 or n==1:\u003cbr\u003e        return 1\u003cbr\u003e    elif n&gt;1:\u003cbr\u003e        return n*fac(n-1)\u003cbr\u003e\u003cbr\u003eimport random\u003cbr\u003edef subset_sum(nums , target):\u003cbr\u003e    sumL=[]\u003cbr\u003e    n=len(nums)\u003cbr\u003e    temp=[]\u003cbr\u003e    for i in range(1,len(nums)+1):\u003cbr\u003e        for j in range(int(fac(n)\u002f(fac(n-i)*fac(i)))):\u003cbr\u003e            newL=[]\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(numbers, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not numbers:\u003cbr\u003e        return False\u003cbr\u003e    include_first = subset_sum(numbers[1:], target - numbers[0])\u003cbr\u003e    exclude_first = subset_sum(numbers[1:], target)\u003cbr\u003e    return include_first or exclude_first","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of ’nums’ sums exactly to ’\u003cbr\u003e    target’.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    def backtrack(i,sum):\u003cbr\u003e        if sum == target: # Base case: target achieved\u003cbr\u003e            return True\u003cbr\u003e        if i == len(nums) or sum &gt; target: # Base case: end of list or sum exceeded\u003cbr\u003e            return False\u003cbr\u003e        if backtrack(i + 1, sum + nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        return backtrack(i + 1,sum) # Exclude current number\u003cbr\u003e    return backtrack(0, 0)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e \u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    # Recursive cases:\u003cbr\u003e    # 1. Include the last element\u003cbr\u003e    # 2. Exclude the last element\u003cbr\u003e    taking = subset_sum(nums[:-1], target - nums[-1])\u003cbr\u003e    Not_taking = subset_sum(nums[:-1], target)\u003cbr\u003e    \u003cbr\u003e    return taking or Not_taking\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    last_num= nums[-1]\u003cbr\u003e    return subset_sum(nums[:-1],target) or subset_sum(nums[:-1],target-last_num)\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9)) #True\u003cbr\u003eprint(subset_sum([1,2,3],7)) #False\u003cbr\u003eprint(subset_sum([],0)) #True","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \u003cbr\u003e    def helper(i, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if i == len(nums):\u003cbr\u003e            return False\u003cbr\u003e        \u003cbr\u003e        if helper(i + 1, current_sum + nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e        return helper(i + 1, current_sum)\u003cbr\u003e    \u003cbr\u003e    return helper(0, 0)\u003cbr\u003eprint(subset_sum([3, 34, 4, 12, 5, 2], 9))   \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if  nums==[]:\u003cbr\u003e        return False\u003cbr\u003e    first=nums[0]\u003cbr\u003e    rest=nums[1:]\u003cbr\u003e    return subset_sum(rest,target-first) or subset_sum(rest,target)\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    if nums[-1] &lt;= target:\u003cbr\u003e        return subset_sum(nums[:-1], target - nums[-1]) or subset_sum(nums[:-1], target)\u003cbr\u003e    else:\u003cbr\u003e        return subset_sum(nums[:-1], target)\u003cbr\u003eprint(subset_sum([3, 34, 4, 12, 5, 2], 9)) \u003cbr\u003eprint(subset_sum([3, 34, 4, 12, 5, 2], 30))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e        if index == len(nums) or current_sum &gt; target:\u003cbr\u003e            return False\u003cbr\u003e            \u003cbr\u003e        if backtrack(index + 1, current_sum + nums[index]):\u003cbr\u003e            return True\u003cbr\u003e            \u003cbr\u003e        if backtrack(index + 1, current_sum):\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e        return False\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of `nums` sums exactly to `target`.\u003cbr\u003e    Uses recursion (backtracking).\u003cbr\u003e    \"\"\"\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    if nums[0] &gt; target:\u003cbr\u003e        return subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    leave_last = subset_sum(nums[:-1], target)\u003cbr\u003e    take_last = subset_sum(nums[:-1], target=target-nums[-1])\u003cbr\u003e\u003cbr\u003e    return leave_last or take_last\u003cbr\u003e\u003cbr\u003esubset_sum([3,34,4,12,5,2], 9) # True\u003cbr\u003esubset_sum([1,2,3], 7) # False\u003cbr\u003esubset_sum([], 0) # True","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    first=nums[0]\u003cbr\u003e    if subset_sum(nums[1:], target-first):\u003cbr\u003e        return True\u003cbr\u003e    if subset_sum(nums[1:], target):\u003cbr\u003e        return True\u003cbr\u003e    return False","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    first=nums[0]\u003cbr\u003e    if subset_sum(nums[1:], target-first):\u003cbr\u003e        return True\u003cbr\u003e    if subset_sum(nums[1:], target):\u003cbr\u003e        return True\u003cbr\u003e    return False","analysis.embedding.code_embedding"],["\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    d1 = {}\u003cbr\u003e\u003cbr\u003e    def l(i, t):\u003cbr\u003e        if t == 0:\u003cbr\u003e            return True\u003cbr\u003e        if i == len(nums):\u003cbr\u003e            return False\u003cbr\u003e        key = (i, t)\u003cbr\u003e        if key in d1:\u003cbr\u003e            return d1[key]\u003cbr\u003e        take = False\u003cbr\u003e        if nums[i] &lt;= t:\u003cbr\u003e            take = l(i + 1, t - nums[i])\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subsets(lst,current=[],index=0):\u003cbr\u003e    if index==len(lst):\u003cbr\u003e            return [current]\u003cbr\u003e    a=subsets(lst,current+[lst[index]],index+1)\u003cbr\u003e    b=subsets(lst,current,index+1)\u003cbr\u003e    return a+b\u003cbr\u003edef subset_sum(n,target):\u003cbr\u003e    s=0\u003cbr\u003e    for j in n:\u003cbr\u003e        s=s+j\u003cbr\u003e    if s&lt;target:\u003cbr\u003e        return(\"False\")\u003cbr\u003e    if target in n:\u003cbr\u003e        return(\"True\")\u003cbr\u003e    if n==[] and target==0:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e \"\"\"\u003cbr\u003e ReturnTrueifsomesubsetof’nums’sumsexactlyto’\u003cbr\u003e target’.\u003cbr\u003e Userecursionorbacktracking.\u003cbr\u003e \"\"\"\u003cbr\u003e def track(i, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if i == len(nums) or current_sum &gt; target:\u003cbr\u003e            return False\u003cbr\u003e        if track(i + 1, current_sum + nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        return track(i + 1, current_sum)\u003cbr\u003e    \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    last_no=nums[-1]\u003cbr\u003e    if subset_sum(nums[:-1],target-last_no):\u003cbr\u003e        return True\u003cbr\u003e    if subset_sum(nums[:-1], target):\u003cbr\u003e        return True\u003cbr\u003e    return False\u003cbr\u003e    \u003cbr\u003e        \u003cbr\u003e     \u003cbr\u003e    \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums or target &lt; 0:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    # simple recursive backtracking\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    # try including first element\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    if include:\u003cbr\u003e        return True\u003cbr\u003e    # try excluding first element\u003cbr\u003e    return subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))\u003cbr\u003eprint(subset_sum([1,2,3], 7))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(nums[1:], target) or subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    pass\u003cbr\u003eprint(subset_sum([3,4,5],9))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0 :\u003cbr\u003e        return True\u003cbr\u003e    \u003cbr\u003e    if len(nums)==0 :\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    if subset_sum(nums[1:], target - nums[0]) :\u003cbr\u003e        return True\u003cbr\u003e    \u003cbr\u003e    if subset_sum(nums[1:], target) :\u003cbr\u003e        return True\u003cbr\u003e    \u003cbr\u003e    return False\u003cbr\u003e    \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        if target==0:\u003cbr\u003e            return True\u003cbr\u003e        else:\u003cbr\u003e            return False\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e    if len(nums)==1:\u003cbr\u003e        if target==nums[0]:\u003cbr\u003e            return True\u003cbr\u003e        else:\u003cbr\u003e            return False\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    n = len(nums)\u003cbr\u003e    r = [[False] * (target + 1) for _ in range(n + 1)]\u003cbr\u003e\u003cbr\u003e    for x in range(n + 1):\u003cbr\u003e        r[x][0] = True\u003cbr\u003e        \u003cbr\u003e    for i in range(1, n + 1):\u003cbr\u003e        for j in range(1, target + 1):\u003cbr\u003e            if nums[i - 1] &gt; j:\u003cbr\u003e                \u003cbr\u003e                r[i][j] = r[i - 1][j]\u003cbr\u003e            else:\u003cbr\u003e                \u003cbr\u003e                r[i][j] = r[i - 1][j] or r[i - 1][j - nums[i - 1]]\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        \u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e        \u003cbr\u003e        if current_sum &gt; target or index &gt;= len(nums):\u003cbr\u003e            return False\u003cbr\u003e        \u003cbr\u003e        \u003cbr\u003e        if backtrack(index + 1, current_sum + nums[index]):\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    first=nums[0]\u003cbr\u003e    include=subset_sum(nums[1:],target-first)\u003cbr\u003e    exclude=subset_sum(nums[1:],target)\u003cbr\u003e    return include or exclude\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \u003cbr\u003e    def check(i, curr_sum):\u003cbr\u003e        \u003cbr\u003e        if curr_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e        if i &gt;= len(nums) or curr_sum &gt; target:\u003cbr\u003e            return False\u003cbr\u003e        \u003cbr\u003e\u003cbr\u003e        return check(i + 1, curr_sum + nums[i]) or check(i + 1, curr_sum)\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e    return check(0, 0)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if len(nums) == 0 and target == 0:\u003cbr\u003e        return True\u003cbr\u003e    lis = []\u003cbr\u003e    for n in nums :\u003cbr\u003e        if n&lt;= target:\u003cbr\u003e            lis.append(n)\u003cbr\u003e    add = 0\u003cbr\u003e    for m in lis :\u003cbr\u003e        add += m\u003cbr\u003e    if add == target:\u003cbr\u003e        return True\u003cbr\u003e    else:\u003cbr\u003e        for i in lis:\u003cbr\u003e            lis1 = lis[:]\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)\u003cbr\u003eprint(subset_sum([3, 34, 4, 12, 5, 2], 9))  \u003cbr\u003eprint(subset_sum([1, 2, 3], 7))             \u003cbr\u003eprint(subset_sum([], 0))                    ","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    \u003cbr\u003e    if nums == []:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    inc = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    exc = subset_sum(nums[1:], target)\u003cbr\u003e    \u003cbr\u003e    if inc:\u003cbr\u003e        return True\u003cbr\u003e    if exc:\u003cbr\u003e        return True\u003cbr\u003e    return False\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to\u003cbr\u003e    'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if sum(nums)== target:\u003cbr\u003e        return True\u003cbr\u003e    else:\u003cbr\u003e        if len(nums)==0:\u003cbr\u003e            return False\u003cbr\u003e        else:\u003cbr\u003e            l=[]\u003cbr\u003e            for i in range(len(nums)):\u003cbr\u003e                l_= nums.copy()\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(m,n):\u003cbr\u003e    if  n==0:\u003cbr\u003e        return True\u003cbr\u003e    if not m:\u003cbr\u003e        return False\u003cbr\u003e    if subset_sum(m[1:],n-m[0]):\u003cbr\u003e        return True\u003cbr\u003e    if subset_sum(m[1:],n):\u003cbr\u003e        return True\u003cbr\u003e    return False\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))\u003cbr\u003eprint(subset_sum([],0))","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    all_subsets = []\u003cbr\u003e    \u003cbr\u003e    def backtracking(i, sub):\u003cbr\u003e        if i == len(nums):\u003cbr\u003e            all_subsets.append(sub[:])\u003cbr\u003e            return\u003cbr\u003e        \u003cbr\u003e        sub.append(nums[i])                 # first case, including i th number\u003cbr\u003e        backtracking(i + 1, sub)\u003cbr\u003e        \u003cbr\u003e        sub.pop()                           # second case, excluding i th number \u003cbr\u003e        backtracking(i + 1, sub)\u003cbr\u003e    \u003cbr\u003e    backtracking(0, [])\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    first = nums[0]\u003cbr\u003e    if first &lt;= target and subset_sum(nums[1:], target - first):\u003cbr\u003e        return True\u003cbr\u003e    return subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e\u003cbr\u003e    # Base cases\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True   # subset found\u003cbr\u003e    if not nums or target &lt; 0:\u003cbr\u003e        return False  # no elements left or target overshot\u003cbr\u003e    \u003cbr\u003e    # Include the first element\u003cbr\u003e    # Exclude the first element\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\"\"\"\u003cbr\u003eReturn True if some subset of ’nums’ sums exactly to ’\u003cbr\u003etarget’.\u003cbr\u003eUse recursion or backtracking.\u003cbr\u003e\"\"\"\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if len(nums) == 0:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    first = nums[0]\u003cbr\u003e    rest = nums[1:]\u003cbr\u003e    \u003cbr\u003e    if subset_sum(rest, target - first):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        if target==0:\u003cbr\u003e            return True\u003cbr\u003e        else:\u003cbr\u003e            return False\u003cbr\u003e\u003cbr\u003e    if len(nums)==1:\u003cbr\u003e        if target==nums[0]:\u003cbr\u003e            return True\u003cbr\u003e        else:\u003cbr\u003e            return False\u003cbr\u003e\u003cbr\u003e    for i in range(len(nums)):\u003cbr\u003e        if subset_sum(nums[i+1:], target-nums[i]):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True          \u003cbr\u003e    if not nums:\u003cbr\u003e        return False         \u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e    return include or exclude\u003cbr\u003e#one example\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9)) #output- True","analysis.embedding.code_embedding"],["''' question no. 18 '''\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    for i in nums :\u003cbr\u003e        if i != target :\u003cbr\u003e            print(False)\u003cbr\u003e\u003cbr\u003e        else: i += subset_sum(nums,target)\u003cbr\u003e        if i== target :\u003cbr\u003e            print(True)\u003cbr\u003e\u003cbr\u003e        else: print(False)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003esubset_sum([3,34,4,12,5,2], 9)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    if subset_sum(nums[1:], target - nums[0]):\u003cbr\u003e        return True\u003cbr\u003e    return subset_sum(nums[1:], target)\u003cbr\u003e#print(subset_sum([3,34,4,12,5,2], 9))","analysis.embedding.code_embedding"],["#Q18\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003edef subset_sum(num, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not num:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(num[1:], target - num[0]) or subset_sum(num[1:], target)\u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    i = subset_sum(nums[:-1],target-nums[-1])\u003cbr\u003e    j = subset_sum(nums[:-1], target)\u003cbr\u003e    return i or j\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))\u003cbr\u003eprint(subset_sum([1,2,3], 7))\u003cbr\u003eprint(subset_sum([], 0))","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    possible_sums ={0} \u003cbr\u003e    for num in nums:\u003cbr\u003e        new_sums = set()\u003cbr\u003e        for s in possible_sums:\u003cbr\u003e            new_sums.add(s + num) \u003cbr\u003e        possible_sums |= new_sums #merging sets\u003cbr\u003e\u003cbr\u003e    return target in possible_sums\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3, 34, 4, 12, 5, 2], 9))  \u003cbr\u003eprint(subset_sum([1, 2, 3], 7))           \u003cbr\u003eprint(subset_sum([], 0))                 \u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if(target==0):\u003cbr\u003e        return True\u003cbr\u003e    if(len(nums)==0):\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    return (subset_sum(nums[1:],target-nums[0]) or subset_sum(nums[1:],target))","analysis.embedding.code_embedding"],[" \"\"\"\u003cbr\u003e ReturnTrueifsomesubsetof’nums’sumsexactlyto’\u003cbr\u003e target’.\u003cbr\u003e \u003cbr\u003e Userecursionorbacktracking.\u003cbr\u003e \"\"\"\u003cbr\u003edef subset_sum(nums,target):\u003cbr\u003e    if nums==[]:\u003cbr\u003e        return False\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    a=nums[-1]\u003cbr\u003e    b=subset_sum(nums[:-1],target-a)\u003cbr\u003e    c=subset_sum(nums[:-1],target)\u003cbr\u003e    return b or c","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if (target == 0):\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    l=nums[0]\u003cbr\u003e    m=nums[1:]\u003cbr\u003e\u003cbr\u003e    include=subset_sum(m, target - l)\u003cbr\u003e    exclude=subset_sum(m, target)\u003cbr\u003e    return include or exclude\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums: list[int], target: int) -&gt; bool:\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e        \u003cbr\u003e    current_num = nums[0]\u003cbr\u003e    remaining_nums = nums[1:]\u003cbr\u003e    \u003cbr\u003e    with_current = subset_sum(remaining_nums, target - current_num)\u003cbr\u003e    \u003cbr\u003e    without_current = subset_sum(remaining_nums, target)\u003cbr\u003e    return with_current or without_current","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if len(nums) == 0:\u003cbr\u003e        return (0 == target)\u003cbr\u003e    \u003cbr\u003e    for j in range(len(nums)):\u003cbr\u003e\u003cbr\u003e        if subset_sum(nums[j + 1], -(nums[j] - target)):\u003cbr\u003e\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e\u003cbr\u003e    return False","analysis.embedding.code_embedding"],["def subset_sum(n, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'n' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not n:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(n[1:], target- n[0]) or subset_sum(n[1:], target)\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))\u003cbr\u003eprint(subset_sum([],0))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    result = [[]]  # start with an empty subset\u003cbr\u003e\u003cbr\u003e    for num in nums:\u003cbr\u003e        new_subsets = []\u003cbr\u003e        for subset in result:\u003cbr\u003e            new_subsets.append(subset + [num])\u003cbr\u003e        result.extend(new_subsets)\u003cbr\u003e\u003cbr\u003e    # check all subsets AFTER building them\u003cbr\u003e    for subset in result:\u003cbr\u003e        if sum(subset) == target:\u003cbr\u003e            return True\u003cbr\u003e    return False\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    # Include current number or exclude it\u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    # base cases\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    # choose to include the first number or skip it\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True  # every set has a null subset in it\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    first=nums[0]\u003cbr\u003e    include=subset_sum(nums[1:],target-first)\u003cbr\u003e    exclude=subset_sum(nums[1:],target)\u003cbr\u003e    return include or exclude","analysis.embedding.code_embedding"],["def subset_sum(nums, target ) :\u003cbr\u003e    def backtrack(index, sums) :\u003cbr\u003e        if sums==target :\u003cbr\u003e            return True\u003cbr\u003e        if index==len(nums) or sums &gt; target :\u003cbr\u003e            return False\u003cbr\u003e        if backtrack(index + 1, sums + nums[index]) :\u003cbr\u003e            return True\u003cbr\u003e        if backtrack(index + 1, sums) :\u003cbr\u003e            return True\u003cbr\u003e        return False\u003cbr\u003e    return backtrack(0, 0)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if nums == []:\u003cbr\u003e        return False\u003cbr\u003e    last = nums[-1]\u003cbr\u003e    if subset_sum(nums[:-1], target - last):\u003cbr\u003e        return True\u003cbr\u003e\u003cbr\u003e    return subset_sum(nums[:-1], target)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Uses recursion (backtracking).\u003cbr\u003e    \"\"\"\u003cbr\u003e\u003cbr\u003e    \u003cbr\u003e    def backtrack(index, Csum):\u003cbr\u003e        if Csum == target:\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e        if index == len(nums) or Csum &gt; target:\u003cbr\u003e            return False\u003cbr\u003e\u003cbr\u003e        include_current = backtrack(index + 1, Csum + nums[index])\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(nums[:-1], target) or subset_sum(nums[:-1], target - nums[-1])","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    def helper(i, current):\u003cbr\u003e        if current == target:\u003cbr\u003e            return True\u003cbr\u003e        if i == len(nums) or (current &gt; target and all(n &gt;= 0 for n in nums[i:])):\u003cbr\u003e            return False\u003cbr\u003e        if helper(i+1, current + nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        if helper(i+1, current):\u003cbr\u003e            return True\u003cbr\u003e        return False\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    return helper(0, 0)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if(target==0):\u003cbr\u003e        return True\u003cbr\u003e    if(len(nums)==0):\u003cbr\u003e        return False\u003cbr\u003e    include=subset_sum(nums[:-1],target-nums[-1])\u003cbr\u003e    exclude=subset_sum(nums[:-1],target)\u003cbr\u003e    return include or exclude","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    # Base cases\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    # Choice: include or exclude the first element\u003cbr\u003e    # If we include nums[0], reduce the target by nums[0]\u003cbr\u003e    # If we exclude it, move to the next element\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if len(nums) == 0:\u003cbr\u003e        if target == 0:\u003cbr\u003e            return True\u003cbr\u003e        else:\u003cbr\u003e            return False\u003cbr\u003e    for i in range(len(nums)):\u003cbr\u003e        if subset_sum(nums[i+1:], target - nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e    return False\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e    return include or exclude\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))  \u003cbr\u003eprint(subset_sum([1,2,3], 7))\u003cbr\u003eprint(subset_sum([], 0))              ","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e\u003cbr\u003e    def combination(index, curr_sum):\u003cbr\u003e        if curr_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e        if index == len(nums):\u003cbr\u003e            return False\u003cbr\u003e        \u003cbr\u003e        return (combination(index + 1, curr_sum + nums[index]) or combination(index + 1, curr_sum))\u003cbr\u003e\u003cbr\u003e    return combination(0, 0)\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    less_lst=[]\u003cbr\u003e    count=0\u003cbr\u003e    if len(nums)==0 and target!=0:\u003cbr\u003e        return False\u003cbr\u003e    elif len(nums)==0 and target==0:\u003cbr\u003e        return True\u003cbr\u003e    for i in nums:\u003cbr\u003e        if i&lt;=target:\u003cbr\u003e            less_lst.append(i)\u003cbr\u003e    if len(less_lst)==0:\u003cbr\u003e        return False\u003cbr\u003e    less_lst.sort(reverse=True)\u003cbr\u003e    for i in less_lst:\u003cbr\u003e        if target-i==0:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    l=nums[-1]\u003cbr\u003e    inc=subset_sum(nums[:-1],target-l)\u003cbr\u003e    exc=subset_sum(nums[:-1],target)\u003cbr\u003e    return inc or exc","analysis.embedding.code_embedding"],["def subset_sum(num,target):\u003cbr\u003e    \"\"\"\u003cbr\u003eReturn True if some subset of ’nums’ sums exactly to ’\u003cbr\u003etarget’.\u003cbr\u003eUse recursion or backtracking.\u003cbr\u003e\"\"\"\u003cbr\u003e    boo = False\u003cbr\u003e    list1 = [[]]\u003cbr\u003e    perm = []\u003cbr\u003e    for i in range (len(num)):\u003cbr\u003e        perm = [s + [num[i]] for s in list1]\u003cbr\u003e        list1 = perm + list1   \u003cbr\u003e    for items in list1:\u003cbr\u003e        if sum(items) == target:\u003cbr\u003e            boo = True\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    last = nums[-1]\u003cbr\u003e    include = subset_sum(nums[:-1], target - last)\u003cbr\u003e    exclude = subset_sum(nums[:-1], target)\u003cbr\u003e    return include or exclude\u003cbr\u003e    pass\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))   \u003cbr\u003eprint(subset_sum([1,2,3], 7))           \u003cbr\u003eprint(subset_sum([], 0))            \u003cbr\u003e\u003cbr\u003e       ","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    sum1={0}\u003cbr\u003e    for i in nums:\u003cbr\u003e        sum2={i+s for s in sum1}\u003cbr\u003e        sum1|=sum2\u003cbr\u003e    return target in sum1\u003cbr\u003eprint(subset_sum([1,2,3,4,5],5))\u003cbr\u003eprint(subset_sum([1,2,3],7))\u003cbr\u003eprint(subset_sum([1],0))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    res = []\u003cbr\u003e    def backtracking(n =0, lst = []):\u003cbr\u003e        if(len(lst) == k):\u003cbr\u003e            res.append(lst[:])\u003cbr\u003e        else:\u003cbr\u003e            for i in range(n, len(nums)):\u003cbr\u003e                lst.append(nums[i])\u003cbr\u003e                backtracking(i+1,lst)\u003cbr\u003e                lst.pop()\u003cbr\u003e    for k in range(len(nums)+1):\u003cbr\u003e        backtracking(0,[])\u003cbr\u003e    for i in res:\u003cbr\u003e        if(sum(i) == target):\u003cbr\u003e            return True\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    first = nums[0]\u003cbr\u003e    rest = nums[1:]\u003cbr\u003e    include = subset_sum(rest, target - first)\u003cbr\u003e    exclude = subset_sum(rest, target)\u003cbr\u003e    return include or exclude","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e\u003cbr\u003e    if len(nums) == 0:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    last = nums[-1]\u003cbr\u003e    remaining = nums[:-1]\u003cbr\u003e\u003cbr\u003e    if subset_sum(remaining, target - last):\u003cbr\u003e        return True\u003cbr\u003e\u003cbr\u003e    if subset_sum(remaining, target):\u003cbr\u003e        return True\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    exclude = subset_sum(nums[:-1], target)\u003cbr\u003e    include = subset_sum(nums[:-1], target - nums[-1])\u003cbr\u003e\u003cbr\u003e    return exclude or include\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    last=nums[-1]\u003cbr\u003e    include=subset_sum(nums[:-1],target-last)\u003cbr\u003e    exclude=subset_sum(nums[:-1],target)\u003cbr\u003e    return include or exclude","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    include = subset_sum(nums[1:], target-nums[0])\u003cbr\u003e    exclude = subset_sum(nums[1:],target)\u003cbr\u003e    return include or exclude\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))\u003cbr\u003eprint(subset_sum([],0))\u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if nums==[]:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    for i in range(len(nums)):\u003cbr\u003e        if nums[i] &lt;= target:\u003cbr\u003e            if subset_sum(nums[i+1:], target - nums[i]):\u003cbr\u003e                return True\u003cbr\u003e    return False","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if current_sum &gt; target or index &gt;= len(nums):\u003cbr\u003e            return False\u003cbr\u003e        if backtrack(index + 1, current_sum + nums[index]):\u003cbr\u003e            return True\u003cbr\u003e        if backtrack(index + 1, current_sum):\u003cbr\u003e            return True\u003cbr\u003e        return False\u003cbr\u003e    return backtrack(0,0)\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))\u003cbr\u003eprint(subset_sum([1,2,3], 7))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    last = nums[-1]\u003cbr\u003e\u003cbr\u003e    include = subset_sum(nums[:-1], target - last)\u003cbr\u003e    exclude = subset_sum(nums[:-1], target)\u003cbr\u003e\u003cbr\u003e    return include or exclude","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    last = nums[-1]\u003cbr\u003e    \u003cbr\u003e    include = subset_sum(nums[:-1], target-last)\u003cbr\u003e    \u003cbr\u003e    exclude = subset_sum(nums[:-1], target)\u003cbr\u003e    \u003cbr\u003e    return include or exclude\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to '\u003cbr\u003e    target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    j=nums[-1]\u003cbr\u003e    h=subset_sum(nums[:-1],target-j)\u003cbr\u003e    g=subset_sum(nums[:-1],target)\u003cbr\u003e    return h or g\u003cbr\u003e    pass\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    # IF taregt is zero\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:                           # if no nums are left\u003cbr\u003e        return False\u003cbr\u003e        \u003cbr\u003e    first_num = nums[0]\u003cbr\u003e    rest_nums = nums[1:]\u003cbr\u003e    \u003cbr\u003e    with_1 = subset_sum(rest_nums, target - first_num)        # by recursion first it tests with the 1st num included if not then removes the num and tests agin and again\u003cbr\u003e    \u003cbr\u003e    without = subset_sum(rest_nums, target)\u003cbr\u003e    \u003cbr\u003e    return with_1 or without","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of ’nums’ sums exactly to ’\u003cbr\u003e    target’.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    return True if (target in nums or target == 0) else [subset_sum(nums[:i] + nums[i+1:],target - nums[i]) for i in range(len(nums))].count(True) &gt; 0","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e\u003cbr\u003e    if nums==[] and target==0:\u003cbr\u003e        return True\u003cbr\u003e        \u003cbr\u003e    for item in nums:\u003cbr\u003e        \u003cbr\u003e        X = target - item\u003cbr\u003e        if X in nums:\u003cbr\u003e            return True\u003cbr\u003e    return False\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))\u003cbr\u003eprint(subset_sum([1,2,3], 7))\u003cbr\u003eprint(subset_sum([], 0))","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    s=''\u003cbr\u003e    for i in range(0,len(nums)):\u003cbr\u003e        s=''\u003cbr\u003e        k=nums[i]\u003cbr\u003e        for j in range(i+1,len(nums)):\u003cbr\u003e            if k+nums[j]&lt;=target:\u003cbr\u003e                k=k+nums[j]\u003cbr\u003e                    \u003cbr\u003e        if k==target:\u003cbr\u003e            s=\"True\"\u003cbr\u003e            break\u003cbr\u003e        else:\u003cbr\u003e            continue\u003cbr\u003e    if s==\"True\":\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    include = subset_sum(nums[1:], target-nums[0])\u003cbr\u003e    exclude = subset_sum(nums[1:],target)\u003cbr\u003e    return include or exclude\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))\u003cbr\u003eprint(subset_sum([],0))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    if nums[0] &lt;= target:\u003cbr\u003e        if subset_sum(nums[1:], target - nums[0]):\u003cbr\u003e            return True\u003cbr\u003e    return subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))  # True\u003cbr\u003eprint(subset_sum([1,2,3],7))          # False\u003cbr\u003eprint(subset_sum([],0))               # True","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums or target&lt;0:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(nums[1:],target-nums[0]) or subset_sum(nums[1:],target)\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e\u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if index == len(nums) or current_sum &gt; target:\u003cbr\u003e            return False\u003cbr\u003e        if backtrack(index + 1, current_sum + nums[index]):\u003cbr\u003e            return True\u003cbr\u003e        return backtrack(index + 1, current_sum)\u003cbr\u003e\u003cbr\u003e    return backtrack(0, 0)\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3, 34, 4, 12, 5, 2], 9))  # True\u003cbr\u003eprint(subset_sum([1, 2, 3], 7))            # False\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["import itertools\u003cbr\u003e\u003cbr\u003edef subset_sum(nums,target):\u003cbr\u003e    if nums==[] and target==0:\u003cbr\u003e        return True\u003cbr\u003e    else:\u003cbr\u003e        all_subsets = []\u003cbr\u003e\u003cbr\u003e        for r in range(len(nums) + 1):\u003cbr\u003e            combinations_at_length_r = itertools.combinations(nums, r)\u003cbr\u003e            \u003cbr\u003e            for combo in combinations_at_length_r:\u003cbr\u003e                all_subsets.append(list(combo))\u003cbr\u003e        \u003cbr\u003e        for i in all_subsets:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def permute(t):\u003cbr\u003e    if len(t) == 0:          # &lt;-- base case\u003cbr\u003e        return [[]]\u003cbr\u003e    res = []\u003cbr\u003e    for i in range(len(t)):  # &lt;-- loop over all elements\u003cbr\u003e        rest = t[:i] + t[i+1:]    # smaller list (one element removed)\u003cbr\u003e        perms = permute(rest)     # recursive call on smaller list\u003cbr\u003e        for p in perms:\u003cbr\u003e            res.append([t[i]] + p)\u003cbr\u003e    return res\u003cbr\u003e\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of ’nums’ sums exactly to ’\u003cbr\u003e    target’.\"\"\"\u003cbr\u003e    if sum(nums) &lt; target:\u003cbr\u003e        return False\u003cbr\u003e    elif sum (nums) == target:\u003cbr\u003e        return True\u003cbr\u003e    elif any([subset_sum(nums[:i] + nums[i+1:], target) for i in range(len(nums))]):\u003cbr\u003e        return True","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if len(nums) == 0:\u003cbr\u003e        if target == 0:\u003cbr\u003e            return True\u003cbr\u003e        else:\u003cbr\u003e            return False\u003cbr\u003e    for i in range(len(nums)):\u003cbr\u003e        if subset_sum(nums[i+1:], target - nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e    return False\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))","analysis.embedding.code_embedding"],["#B25CS044_Q18\u003cbr\u003e\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    \u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        # Base case: if current sum equals target\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e        # Base case: if we've processed all elements\u003cbr\u003e        if index &gt;= len(nums):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    for i in nums:\u003cbr\u003e        if sum(nums)==target:\u003cbr\u003e            return True\u003cbr\u003e        else:\u003cbr\u003e            return False","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    # Base cases\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e# takes the last element\u003cbr\u003e    last=nums[-1]\u003cbr\u003e# 1st way, include the last number in the subset\u003cbr\u003e    include=subset_sum(nums[:-1], target - last)\u003cbr\u003e# 2nd way, exclude the last number\u003cbr\u003e    exclude=subset_sum(nums[:-1], target)\u003cbr\u003e    return include or exclude #if either works subset exists\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(nums[1:], target) or subset_sum(nums[1:], target - nums[0])","analysis.embedding.code_embedding"],["\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    \u003cbr\u003e    def helper(i, target):\u003cbr\u003e        \u003cbr\u003e        if target == 0:\u003cbr\u003e            return True\u003cbr\u003e        if i == len(nums):\u003cbr\u003e            return False\u003cbr\u003e\u003cbr\u003e        if helper(i + 1, target - nums[i]):\u003cbr\u003e            return True\u003cbr\u003e\u003cbr\u003e        return helper(i + 1, target)\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    l=[i for i in nums if i&lt;=target]\u003cbr\u003e    if l!=[]:\u003cbr\u003e          target-=max(l)\u003cbr\u003e          l.remove(max(l))\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    elif target&lt;0 or len(l)==0:\u003cbr\u003e        return False\u003cbr\u003e    else:\u003cbr\u003e        return subset_sum(l,target)\u003cbr\u003e        \u003cbr\u003e    \u003cbr\u003e     ","analysis.embedding.code_embedding"],["def sub_set_sum(nums,targ):\u003cbr\u003e    if targ == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    last = nums[-1]\u003cbr\u003e    return subset_sum(nums[:-1],targ) or subset_sum(nums[:-1],targ-last)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    # include or exclude first element\u003cbr\u003e    if nums[0] &lt;= target:\u003cbr\u003e        if subset_sum(nums[1:], target - nums[0]):\u003cbr\u003e            return True\u003cbr\u003e    return subset_sum(nums[1:], target)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:  \u003cbr\u003e        return False\u003cbr\u003e    last = nums[-1]\u003cbr\u003e    return subset_sum(nums[:-1], target - last) or subset_sum(nums[:-1], target)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    last = nums[-1]\u003cbr\u003e    return subset_sum(nums[:-1],target) or subset_sum(nums[:-1],target-last)\u003cbr\u003eprint(subset_sum([3, 34, 4, 12, 5, 2], 9))\u003cbr\u003eprint(subset_sum([1,2,3],7)) \u003cbr\u003eprint(subset_sum([],0))","analysis.embedding.code_embedding"],["\"\"\"\u003cbr\u003eReturnTrueifsomesubsetof’nums’sumsexactlyto’\u003cbr\u003etarget’.\u003cbr\u003eUserecursionorbacktracking.\u003cbr\u003e\"\"\"\u003cbr\u003e#  pass\u003cbr\u003e#  Input: nums: list[int],target: int Output: bool\u003cbr\u003e#  Examples:\u003cbr\u003e#  subset_sum([3,34,4,12,5,2],9) #True\u003cbr\u003e#  subset_sum([1,2,3],7) #False\u003cbr\u003e#  subset_sum([],0) #True\u003cbr\u003edef subset_sum(nums,target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    current = nums[0]\u003cbr\u003e    remaining = nums[1:]\u003cbr\u003e\u003cbr\u003e    return subset_sum(remaining, target) or subset_sum(remaining, target - current)\u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    present=nums[0]\u003cbr\u003e    rem=nums[1:]\u003cbr\u003e    if subset_sum(rem,target-present):\u003cbr\u003e        return True\u003cbr\u003e    if subset_sum(rem,target):\u003cbr\u003e        return True\u003cbr\u003e    return False\u003cbr\u003eprint(spiral_order([[1,2,3],[4,5,6],[7,8,9]]))  # [1,2,3,6,9,8,7,4,5]\u003cbr\u003eprint(spiral_order([[1,2],[3,4]]))             # [1,2,4,3]\u003cbr\u003e   ","analysis.embedding.code_embedding"],["def subsets_sum(nums, target):\u003cbr\u003e    result = [[]] \u003cbr\u003e    \u003cbr\u003e    for num in nums:\u003cbr\u003e        new_subsets = []\u003cbr\u003e        for subset in result:\u003cbr\u003e            new_subsets.append(subset + [num]) \u003cbr\u003e        result += new_subsets \u003cbr\u003e    \u003cbr\u003e    for sub in result:\u003cbr\u003e        sum =0\u003cbr\u003e        for i in sub:\u003cbr\u003e            sum += i\u003cbr\u003e        if sum == target:\u003cbr\u003e            return True\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True       \u003cbr\u003e    if not nums:\u003cbr\u003e        return False        \u003cbr\u003e\u003cbr\u003e    \u003cbr\u003e    first = nums[0]\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e    include = subset_sum(nums[1:], target - first)\u003cbr\u003e    \u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    # simple recursive backtracking\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    # try including first element\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    if include:\u003cbr\u003e        return True\u003cbr\u003e    # try excluding first element\u003cbr\u003e    return subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))\u003cbr\u003eprint(subset_sum([1,2,3], 7))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    include=subset_sum(nums[:-1],target-nums[-1])\u003cbr\u003e    exclude=subset_sum(nums[:-1],target)\u003cbr\u003e    return include or exclude\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))\u003cbr\u003eprint(subset_sum([],0))","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    include=subset_sum(nums[1:],target-nums[0])\u003cbr\u003e    exclude=subset_sum(nums[1:],target)\u003cbr\u003e    \u003cbr\u003e    return include or exclude","analysis.embedding.code_embedding"],["\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    def index_combos(n):\u003cbr\u003e        global d\u003cbr\u003e        d = {}\u003cbr\u003e\u003cbr\u003e        def backtrack(start, path):\u003cbr\u003e            if path:\u003cbr\u003e                l = len(path)\u003cbr\u003e                if l not in d:\u003cbr\u003e                    d[l] = []\u003cbr\u003e                d[l].append(path[:])\u003cbr\u003e            for i in range(start, n):\u003cbr\u003e                path.append(i)\u003cbr\u003e                backtrack(i + 1, path)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    if nums[0] &lt;= target:\u003cbr\u003e        if subset_sum(nums[1:], target - nums[0]):\u003cbr\u003e            return True\u003cbr\u003e    return subset_sum(nums[1:], target)","analysis.embedding.code_embedding"],["\u003cbr\u003e\u003cbr\u003e\u003cbr\u003edef subset_sum(nums,target):\u003cbr\u003e    L=[]\u003cbr\u003e    L1=[]\u003cbr\u003e    for i in nums:\u003cbr\u003e        if i&lt;=target:\u003cbr\u003e            L.append(i)\u003cbr\u003e    def combinations(lst):\u003cbr\u003e        if not lst:\u003cbr\u003e            return [[]]\u003cbr\u003e        first = lst[0]\u003cbr\u003e        rest = combinations(lst[1:])\u003cbr\u003e        return rest + [[first] + r for r in rest]\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    total = [0]   \u003cbr\u003e    nums.sort()\u003cbr\u003e    for num in nums:\u003cbr\u003e        new_sums = []\u003cbr\u003e        for s in total:\u003cbr\u003e            new_sums.append(num + s)\u003cbr\u003e        total += new_sums\u003cbr\u003e        if target in total:\u003cbr\u003e            return True\u003cbr\u003e    return False   \u003cbr\u003e\u003cbr\u003e\u003cbr\u003e      \u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if target==0: # if target is 0, this means we found a subset summing to original target\u003cbr\u003e        return True\u003cbr\u003e    else:\u003cbr\u003e        a=nums.copy() # creating a copy to avoid modifying original list used in loop\u003cbr\u003e        for i in nums:\u003cbr\u003e            a.remove(i) # removing current element to avoid reusing it\u003cbr\u003e            if i&lt;=target and subset_sum(a, target - i)==True: # checking if including current element helps reach target and recurs on remaining elements\u003cbr\u003e                return True \u003cbr\u003e        else:\u003cbr\u003e            return False","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    first = nums[0]\u003cbr\u003e    if subset_sum(nums[1:], target-first):\u003cbr\u003e        return True\u003cbr\u003e    if subset_sum(nums[1:], target):\u003cbr\u003e        return True\u003cbr\u003e\u003cbr\u003e    return False\u003cbr\u003e\u003cbr\u003e#example\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    a=0\u003cbr\u003e    flag=1\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    for i in nums:\u003cbr\u003e        nums.remove(i)\u003cbr\u003e        for j in nums:\u003cbr\u003e            a=i+j\u003cbr\u003e            if a==target:\u003cbr\u003e                return True\u003cbr\u003e            else:\u003cbr\u003e                flag=0\u003cbr\u003e    if flag==0:\u003cbr\u003e        return False\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target ==0 :\u003cbr\u003e        return True\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    l=nums[0]\u003cbr\u003e    i=subset_sum(nums[1:],target-l)\u003cbr\u003e    j=subset_sum(nums[1:],target)\u003cbr\u003e    return i or j\u003cbr\u003e    ","analysis.embedding.code_embedding"],["# Q18\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if index == len(nums) or current_sum &gt; target:\u003cbr\u003e            return False\u003cbr\u003e\u003cbr\u003e        if backtrack(index + 1, current_sum + nums[index]):\u003cbr\u003e            return True\u003cbr\u003e        if backtrack(index + 1, current_sum):\u003cbr\u003e            return True\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    return backtrack(0, 0)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if sum(nums)==target:\u003cbr\u003e        return True\u003cbr\u003e    elif sum(nums)&lt;target:\u003cbr\u003e        return False\u003cbr\u003e    else:\u003cbr\u003e        total=0\u003cbr\u003e        while total&lt;target:\u003cbr\u003e            total+=min(nums)\u003cbr\u003e            nums.remove(min(nums))\u003cbr\u003e        if total==target:\u003cbr\u003e            return True","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    res = []\u003cbr\u003e    def backtracking(n =0, lst = []):\u003cbr\u003e        if(len(lst) == k):\u003cbr\u003e            res.append(lst[:])\u003cbr\u003e        else:\u003cbr\u003e            for i in range(n, len(nums)):\u003cbr\u003e                lst.append(nums[i])\u003cbr\u003e                backtracking(i+1,lst)\u003cbr\u003e                lst.pop()\u003cbr\u003e    for k in range(len(nums)+1):\u003cbr\u003e        backtracking(0,[])\u003cbr\u003e    for i in res:\u003cbr\u003e        if(sum(i) == target):\u003cbr\u003e            return True\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)","analysis.embedding.code_embedding"],["def subset_sum(num, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not num:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(num[1:], target - num[0]) or subset_sum(num[1:], target)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    for i in range(len(nums)):\u003cbr\u003e        for j in range(i + 1, len(nums)):\u003cbr\u003e            if nums[i] + nums[j] == target:\u003cbr\u003e                return True\u003cbr\u003e    return False\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e#test cases\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))\u003cbr\u003eprint(subset_sum([1,2,3], 7)) \u003cbr\u003eprint(subset_sum([], 0))","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    if nums[-1]&gt;target:\u003cbr\u003e        return subset_sum(nums[:-1],target)\u003cbr\u003e    return subset_sum(nums[:-1],target) or subset_sum(nums[:-1],target-nums[-1])\u003cbr\u003esubset_sum([3,34,4,12,5,2], 9)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    first = nums[0]\u003cbr\u003e    if subset_sum(nums[1:], target - first):\u003cbr\u003e        return True\u003cbr\u003e\u003cbr\u003e    if subset_sum(nums[1:], target):\u003cbr\u003e        return True\u003cbr\u003e\u003cbr\u003e    return False","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        if target == 0:\u003cbr\u003e            return True\u003cbr\u003e        else:\u003cbr\u003e            return False\u003cbr\u003e    \u003cbr\u003e    if len(nums) == 1:\u003cbr\u003e        if target == nums[0]:\u003cbr\u003e            return True\u003cbr\u003e        else:\u003cbr\u003e            return False\u003cbr\u003e    \u003cbr\u003e    for i in range(len(nums)):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    def helper(index,current_sum):\u003cbr\u003e        if current_sum==target:\u003cbr\u003e            return True\u003cbr\u003e        if index==len(nums) or current_sum&gt;target:\u003cbr\u003e            return False\u003cbr\u003e        return helper(index+1,current_sum+nums[index]) or helper(index+1,current_sum)\u003cbr\u003e    return helper(0, 0)\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3, 34, 4, 12, 5, 2], 9))  \u003cbr\u003eprint(subset_sum([1, 2, 3], 7))            \u003cbr\u003eprint(subset_sum([], 0))                   ","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums or target &lt; 0:\u003cbr\u003e        return False\u003cbr\u003e    if subset_sum(nums[1:], target - nums[0]):\u003cbr\u003e        return True\u003cbr\u003e    \u003cbr\u003e    if subset_sum(nums[1:], target):\u003cbr\u003e        return True\u003cbr\u003e    return False\u003cbr\u003e\"\"\"\u003cbr\u003eReturn True if some subset of ’nums’ sums exactly to ’\u003cbr\u003etarget’.\u003cbr\u003eUse recursion or backtracking.\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True     \u003cbr\u003e    if not nums:\u003cbr\u003e        return False       \u003cbr\u003e\u003cbr\u003e    last = nums[-1]\u003cbr\u003e    if subset_sum(nums[:-1], target - last):\u003cbr\u003e        return True\u003cbr\u003e    if subset_sum(nums[:-1], target):\u003cbr\u003e        return True\u003cbr\u003e    return False","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    # include or exclude first number\u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    if nums[0] &gt; target:\u003cbr\u003e        return subset_sum(nums[1:], target)\u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)\u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    \"\"\"Given a list of integers and a target integer, return True if any subset of the list sums to the target.\"\"\"\u003cbr\u003e    n = len(nums)\u003cbr\u003e    for i in range(1 &lt;&lt; n):\u003cbr\u003e        subset_sum = 0\u003cbr\u003e        for j in range(n):\u003cbr\u003e            if (i &amp; (1 &lt;&lt; j)) &gt; 0:\u003cbr\u003e                subset_sum += nums[j]\u003cbr\u003e        if subset_sum == target:\u003cbr\u003e            return True\u003cbr\u003e    return False","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if sum(nums)==target:\u003cbr\u003e        return True\u003cbr\u003e    elif sum(nums)&lt;target:\u003cbr\u003e        return False\u003cbr\u003e    else:\u003cbr\u003e        total=0\u003cbr\u003e        while total&lt;target:\u003cbr\u003e            total+=min(nums)\u003cbr\u003e            nums.remove(min(nums))\u003cbr\u003e        if total==target:\u003cbr\u003e            return True\u003cbr\u003e            \u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    n = len(nums)\u003cbr\u003e\u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        \u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if current_sum &gt; target or index == n:\u003cbr\u003e            return False\u003cbr\u003e        if backtrack(index + 1, current_sum + nums[index]):\u003cbr\u003e            return True\u003cbr\u003e\u003cbr\u003e        if backtrack(index + 1, current_sum):\u003cbr\u003e            return True\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \u003cbr\u003e    \"\"\"\u003cbr\u003e    def backtrack(i,sum1):\u003cbr\u003e        \u003cbr\u003e        if index == len(nums):#if the numbers have all been used\u003cbr\u003e            return sum1==target\u003cbr\u003e        if backtrack(i+1,sum1+nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e        if backtrack(index + 1, current_sum):#removing the existing number\u003cbr\u003e            return True\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True               \u003cbr\u003e    if len(nums) == 0:\u003cbr\u003e        return False               \u003cbr\u003e    last = nums[-1]\u003cbr\u003e    return (subset_sum(nums[:-1], target - last) or subset_sum(nums[:-1], target))\u003cbr\u003eprint(subset_sum([3, 34, 4, 12, 5, 2], 9))  ","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    last = nums[-1]\u003cbr\u003e    inc = subset_sum(nums[:-1], target - last)\u003cbr\u003e    exc = subset_sum(nums[:-1], target)\u003cbr\u003e    return inc or exc\u003cbr\u003e\u003cbr\u003e","analysis.embedding.code_embedding"],["#B25MT019_q18\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    \u003cbr\u003e    if len(nums) == 0:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    first = nums[0]\u003cbr\u003e    rest = nums[1:]\u003cbr\u003e    \u003cbr\u003e    # Try INCLUDING first element\u003cbr\u003e    if first &lt;= target:\u003cbr\u003e        if subset_sum(rest, target - first):\u003cbr\u003e            return True\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subsets(list):\u003cbr\u003e    if len(list)==0:\u003cbr\u003e        return [[]]\u003cbr\u003e    else:\u003cbr\u003e        x=list[0]\u003cbr\u003e        all=subsets(list[1:])\u003cbr\u003e        return all+[[x]+subset for subset in all]\u003cbr\u003e\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    subset=subsets(nums)\u003cbr\u003e    for i in subset:\u003cbr\u003e        val=0\u003cbr\u003e        for j in i:\u003cbr\u003e            val+=j \u003cbr\u003e        if val==target:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    result = nums[::]\u003cbr\u003e    for i in nums:\u003cbr\u003e        if i &gt; target:\u003cbr\u003e            result.remove(i)\u003cbr\u003e    if sum(result) &lt; target:\u003cbr\u003e        return False\u003cbr\u003e    elif sum(result) == target:\u003cbr\u003e        return True\u003cbr\u003e    else:\u003cbr\u003e        for i in range(len(result)):\u003cbr\u003e            for j in range(i+1,len(result)+1):\u003cbr\u003e                if sum(result[i:j]) == target:\u003cbr\u003e                    return True","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True          \u003cbr\u003e    if not nums:\u003cbr\u003e        return False         \u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e    return include or exclude\u003cbr\u003e#one example\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9)) #output- True","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    n=len(nums)\u003cbr\u003e    if (n==0 and target==0):\u003cbr\u003e        return True\u003cbr\u003e    for i in range(0,n):\u003cbr\u003e        if nums[i]==target:\u003cbr\u003e            return True\u003cbr\u003e        break\u003cbr\u003e        for j in range(i+1,n):\u003cbr\u003e            if (nums[i]+nums[j])==target:\u003cbr\u003e                return True\u003cbr\u003e            break\u003cbr\u003e            for k in range(j+1,n):\u003cbr\u003e                if (nums[i]+nums[j]+nums[k])==target:\u003cbr\u003e                    return True\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of ’nums’ sums exactly to ’target’.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    #If the target is 0, we found a valid subset\u003cbr\u003e    if target ==0:\u003cbr\u003e        return True\u003cbr\u003e    #If no element is left and the target is not 0\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    #Option 1: We include the first element (nums[0]) in the subset\u003cbr\u003e    #We reduce the target by that value and move to the remaining elements\u003cbr\u003e    include = subset_sum(nums[1:], target -nums[0])\u003cbr\u003e    \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(nums[1:], target) or subset_sum(nums[1:], target - nums[0])\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9)) #True\u003cbr\u003eprint(subset_sum([1,2,3],7)) #False\u003cbr\u003eprint(subset_sum([],0)) #True","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    subsets = [[]]\u003cbr\u003e    for i in nums:\u003cbr\u003e        new_set = []\u003cbr\u003e        for j in subsets:\u003cbr\u003e            new_set.append(j + [i])\u003cbr\u003e        subsets += new_set\u003cbr\u003e    \u003cbr\u003e    for subset in subsets:\u003cbr\u003e        total = 0\u003cbr\u003e        for i in subset:\u003cbr\u003e            total += i\u003cbr\u003e        if total == target:\u003cbr\u003e            return True\u003cbr\u003e    return False","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if sum(nums) == target:\u003cbr\u003e        return True\u003cbr\u003e    else:\u003cbr\u003e        for i in range(len(nums)):\u003cbr\u003e            copy = nums[:i] + nums[i+1:]  \u003cbr\u003e            if sum(copy)&gt;=target:\u003cbr\u003e                print(copy)\u003cbr\u003e                if subset_sum(copy, target):\u003cbr\u003e                    return True\u003cbr\u003e    return False\u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    if nums[0] &gt; target:\u003cbr\u003e        return subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    \u003cbr\u003e    return include or exclude","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    first = nums[0]\u003cbr\u003e    if first &lt;= target and subset_sum(nums[1:], target - first):\u003cbr\u003e        return True\u003cbr\u003e    return subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion with backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    def dfs(i, current):\u003cbr\u003e        if current == target:\u003cbr\u003e            return True\u003cbr\u003e        if i &gt;= len(nums) or current &gt; target:\u003cbr\u003e            return False\u003cbr\u003e        # choose nums[i]\u003cbr\u003e        if dfs(i + 1, current + nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        # skip nums[i]\u003cbr\u003e        if dfs(i + 1, current):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subsets(nums):\u003cbr\u003e    results=[[]]\u003cbr\u003e    for i in nums:\u003cbr\u003e        results+=[j+[i] for j in results]\u003cbr\u003e    return results\u003cbr\u003eprint(subsets([1,2,3]))\u003cbr\u003e\u003cbr\u003edef subset_sum(nums,target):\u003cbr\u003e    p=subsets(nums)\u003cbr\u003e    for i in p:\u003cbr\u003e        if sum(i)==target:\u003cbr\u003e            return True\u003cbr\u003eprint(subset_sum([], 0))","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    include = subset_sum(nums[1:], target-nums[0])\u003cbr\u003e    exclude = subset_sum(nums[1:],target)\u003cbr\u003e    return include or exclude\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))\u003cbr\u003eprint(subset_sum([],0))","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    lst=[]\u003cbr\u003e    for j in range(len(nums)-1):\u003cbr\u003e        for i in range(j+1,len(nums)-1):\u003cbr\u003e            k=nums[j]+nums[i]\u003cbr\u003e            lst.append(k)\u003cbr\u003e    if target==0 and lst==[]:\u003cbr\u003e        return True        \u003cbr\u003e    if target in lst:\u003cbr\u003e        return True\u003cbr\u003e    if target not in lst:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    first = nums[0]\u003cbr\u003e    rest = nums[1:]\u003cbr\u003e    include = subset_sum(rest, target - first)\u003cbr\u003e    exclude = subset_sum(rest, target)\u003cbr\u003e    return include or exclude","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    p = nums[0]\u003cbr\u003e    include = subset_sum(nums[1:],target-p)\u003cbr\u003e    exclude = subset_sum(nums[1:],target)\u003cbr\u003e    return include or exclude\u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of ’nums’ sums exactly to ’\u003cbr\u003e    target’.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    def backtrack(index, remaining_target):\u003cbr\u003e        if remaining_target == 0:\u003cbr\u003e            return True\u003cbr\u003e        if remaining_target &lt; 0:\u003cbr\u003e            return False\u003cbr\u003e        if index == len(nums):\u003cbr\u003e            return False\u003cbr\u003e        include_this_num = backtrack(index + 1, remaining_target - nums[index])\u003cbr\u003e        exclude_this_num = backtrack(index + 1, remaining_target)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \u003cbr\u003e    n = len(nums)\u003cbr\u003e    dp = [[False] * (target + 1) for _ in range(n + 1)]\u003cbr\u003e\u003cbr\u003e    for i in range(n + 1):\u003cbr\u003e        dp[i][0] = True\u003cbr\u003e    for i in range(1, n + 1):\u003cbr\u003e        for j in range(1, target + 1):\u003cbr\u003e            if nums[i - 1] &lt;= j:\u003cbr\u003e                \u003cbr\u003e               dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\u003cbr\u003e            else:\u003cbr\u003e                \u003cbr\u003e                dp[i][j] = dp[i - 1][j]\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["target_possible = False\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        if target==0: return True\u003cbr\u003e        else: return False\u003cbr\u003e\u003cbr\u003e    global target_possible\u003cbr\u003e    target_possible = False\u003cbr\u003e\u003cbr\u003e    s = [False for i in range (len(nums))]\u003cbr\u003e\u003cbr\u003e    helper(nums, target, s)\u003cbr\u003e\u003cbr\u003e    return target_possible\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\"\"\"\u003cbr\u003eReturn True if some subset of ’nums’ sums exactly to ’\u003cbr\u003etarget’.\u003cbr\u003eUse recursion or backtracking.\u003cbr\u003e\"\"\"\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    if sum(nums)==target:\u003cbr\u003e        return True\u003cbr\u003e    elif sum(nums)&lt;target:\u003cbr\u003e        return False\u003cbr\u003e    else:\u003cbr\u003e        total=0\u003cbr\u003e        while total&lt;target:\u003cbr\u003e            total+=min(nums)\u003cbr\u003e            nums.remove(min(nums))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def combinations(arr, r):\u003cbr\u003e    result = []\u003cbr\u003e    def backtrack(start, path):\u003cbr\u003e        if len(path) == r:\u003cbr\u003e            result.append(path[:])\u003cbr\u003e            return\u003cbr\u003e        for i in range(start, len(arr)):\u003cbr\u003e            path.append(arr[i])\u003cbr\u003e            backtrack(i + 1, path)\u003cbr\u003e            path.pop()\u003cbr\u003e    backtrack(0, [])\u003cbr\u003e    return result\u003cbr\u003e\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    for i in range(1,len(nums)):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    sume=0\u003cbr\u003e    if len(nums)==0 and target==0:\u003cbr\u003e        return(True)\u003cbr\u003e    if target in nums:\u003cbr\u003e        return(True)\u003cbr\u003e    for i in nums:\u003cbr\u003e        if i&lt;target:\u003cbr\u003e            counted=nums.copy()\u003cbr\u003e            counted.remove(i)\u003cbr\u003e            if target-i in counted:\u003cbr\u003e                sume=1\u003cbr\u003e                return(True)\u003cbr\u003e            else:\u003cbr\u003e                target=target-i\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    # Choose last element\u003cbr\u003e    last = nums[-1]\u003cbr\u003e    \u003cbr\u003e    exclude = subset_sum(nums[:-1], target) # last element excluded and rest are compared with target\u003cbr\u003e    \u003cbr\u003e    include = subset_sum(nums[:-1], target-last) # last element is included and then the rest are compared\u003cbr\u003e    \u003cbr\u003e    return include or exclude\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    if nums[0]&lt;= target:\u003cbr\u003e        if subset_sum(nums[1:len(nums)],target-nums[0]):\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e    return subset_sum(nums[1:len(nums)],target)\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Uses recursion\u002fbacktracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    def backtrack(i, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if i == len(nums) or current_sum &gt; target:\u003cbr\u003e            return False\u003cbr\u003e        \u003cbr\u003e        if backtrack(i + 1, current_sum + nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e        return backtrack(i + 1, current_sum)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum_alt(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums or target &lt; 0:\u003cbr\u003e        return False\u003cbr\u003e    return (subset_sum_alt(nums[1:], target - nums[0]) or subset_sum_alt(nums[1:], target))\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e\u003cbr\u003e    \u003cbr\u003eprint(subset_sum_alt([1,2,3,4,5],12))\u003cbr\u003e               \u003cbr\u003e ","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    elif len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    a=nums[0]\u003cbr\u003e    nums.pop(0)\u003cbr\u003e    if a&lt;=target:\u003cbr\u003e        return subset_sum(nums,target-a)\u003cbr\u003e    else:   \u003cbr\u003e        return subset_sum(nums,target)  \u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))\u003cbr\u003eprint(subset_sum([1,2,3], 7)) \u003cbr\u003eprint(subset_sum([], 0))                 \u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \u003cbr\u003e    def helper(i, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if i == len(nums):\u003cbr\u003e            return False\u003cbr\u003e        \u003cbr\u003e        if helper(i + 1, current_sum + nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e        return helper(i + 1, current_sum)\u003cbr\u003e    \u003cbr\u003e    return helper(0, 0)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Iterative dynamic programming (using loops).\u003cbr\u003e    \"\"\"\u003cbr\u003e    n = len(nums)\u003cbr\u003e    dp = [[False] * (target + 1) for i in range(n + 1)]\u003cbr\u003e\u003cbr\u003e    \u003cbr\u003e    for i in range(n + 1):\u003cbr\u003e        dp[i][0] = True\u003cbr\u003e\u003cbr\u003e    \u003cbr\u003e    for i in range(1, n + 1):\u003cbr\u003e        for j in range(1, target + 1):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    num=nums[0]\u003cbr\u003e    if subset_sum(nums[1:],target-num) or subset_sum(nums[1:],target):\u003cbr\u003e        return True\u003cbr\u003e    return False\u003cbr\u003esubset_sum([3, 34, 4, 12, 5, 2], 9)\u003cbr\u003esubset_sum([1, 2, 3], 7)              \u003cbr\u003esubset_sum([], 0)\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def sub_set_sum(nums,target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    last = nums[-1]\u003cbr\u003e    return subset_sum(nums[:-1],target) or subset_sum(nums[:-1],target-last)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if index == len(nums) or current_sum &gt; target:\u003cbr\u003e            return False\u003cbr\u003e        if backtrack(index + 1, current_sum + nums[index]):\u003cbr\u003e            return True\u003cbr\u003e        if backtrack(index + 1, current_sum):\u003cbr\u003e            return True\u003cbr\u003e        return False\u003cbr\u003e    return backtrack(0, 0)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True       \u003cbr\u003e    if not nums:\u003cbr\u003e        return False        \u003cbr\u003e\u003cbr\u003e    \u003cbr\u003e    first = nums[0]\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e    include = subset_sum(nums[1:], target - first)\u003cbr\u003e    \u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["#name: anki reddy palli obula reddy\u003cbr\u003e#ID NUmber: B25EC005\u003cbr\u003e#Question number:18\u003cbr\u003e\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    last = nums[-1]\u003cbr\u003e    include = subset_sum(nums[:-1], target - last)\u003cbr\u003e    exclude = subset_sum(nums[:-1], target)\u003cbr\u003e    return include or exclude\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def powerset(lst):\u003cbr\u003e    \"\"\"This Function returns the powerset of a list as a list of lists.\"\"\"\u003cbr\u003e    if not lst:\u003cbr\u003e        return [[]]\u003cbr\u003e    first = lst[0]\u003cbr\u003e    rest_subsets = powerset(lst[1:])\u003cbr\u003e    with_first = [[first] + subset for subset in rest_subsets]\u003cbr\u003e    return rest_subsets + with_first\u003cbr\u003e\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of ’nums’ sums exactly to ’\u003cbr\u003e    target’.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e    return include or exclude\u003cbr\u003eprint(subset_sum([3,4,6],7))","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    sum_subset=[]\u003cbr\u003e    sub_set=[[]]\u003cbr\u003e    for i in nums:\u003cbr\u003e        sub_set+=[j+[i] for j in sub_set]\u003cbr\u003e    if {target} in sub_set:\u003cbr\u003e        return True\u003cbr\u003e    else:\u003cbr\u003e        alist=[]\u003cbr\u003e        for i in sub_set:\u003cbr\u003e            sum=0\u003cbr\u003e            for j in i:\u003cbr\u003e                sum+=j\u003cbr\u003e            alist.append(sum)\u003cbr\u003e        if target in alist:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    # Include current number or exclude it\u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    def backtrack(i, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if i == len(nums) or current_sum &gt; target:\u003cbr\u003e            return False\u003cbr\u003e        if backtrack(i+1, current_sum + nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        if backtrack(i+1, current_sum):\u003cbr\u003e            return True\u003cbr\u003e        return False\u003cbr\u003e    return backtrack(0, 0)\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))  \u003cbr\u003eprint(subset_sum([1,2,3], 7))          \u003cbr\u003eprint(subset_sum([], 0))","analysis.embedding.code_embedding"],["def subset_sum(nums, target, index=None):\u003cbr\u003e    if index is None:\u003cbr\u003e        index = len(nums) - 1\u003cbr\u003e    \u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    \u003cbr\u003e    if index &lt; 0 or target &lt; 0:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    # Case 1: Include the current number\u003cbr\u003e    include_current = subset_sum(nums, target - nums[index], index - 1)\u003cbr\u003e    \u003cbr\u003e    # Case 2: Exclude the current number\u003cbr\u003e    exclude_current = subset_sum(nums, target, index - 1)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums or target &lt; 0:\u003cbr\u003e        return False\u003cbr\u003e    firstel = nums[0]\u003cbr\u003e    others = nums[1:]\u003cbr\u003e    rec1 = subset_sum(others, target - firstel)\u003cbr\u003e    rec2 = subset_sum(others, target)\u003cbr\u003e    return rec1 or rec2\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))\u003cbr\u003eprint(subset_sum([],0))\u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums, target, index=None):\u003cbr\u003e    if index is None:\u003cbr\u003e        index = len(nums) - 1\u003cbr\u003e    \u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    \u003cbr\u003e    if index &lt; 0 or target &lt; 0:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    # Case 1: Include the current number\u003cbr\u003e    include_current = subset_sum(nums, target - nums[index], index - 1)\u003cbr\u003e    \u003cbr\u003e    # Case 2: Exclude the current number\u003cbr\u003e    exclude_current = subset_sum(nums, target, index - 1)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["#Q18\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003edef subset_sum(num, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not num:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(num[1:], target - num[0]) or subset_sum(num[1:], target)\u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if index == len(nums) or current_sum &gt; target:\u003cbr\u003e            return False\u003cbr\u003e        include = backtrack(index + 1, current_sum + nums[index])\u003cbr\u003e        exclude = backtrack(index + 1, current_sum)\u003cbr\u003e        return include or exclude\u003cbr\u003e    return backtrack(0, 0)\u003cbr\u003eprint(subset_sum([2, 4, 8], 6))   \u003cbr\u003eprint(subset_sum([1, 2, 3, 9], 5))  \u003cbr\u003eprint(subset_sum([1, 2, 7, 1, 5], 10)) \u003cbr\u003eprint(subset_sum([1, 3, 5, 9], 2))  \u003cbr\u003e","analysis.embedding.code_embedding"],["def power_set(nums):\u003cbr\u003e    if nums == []:\u003cbr\u003e        return [[]]\u003cbr\u003e    elif len(nums) == 1:\u003cbr\u003e        return [[], nums]\u003cbr\u003e    pset = power_set(nums[:-1])\u003cbr\u003e    for i in power_set(nums[:-1]):\u003cbr\u003e        i.append(nums[-1])\u003cbr\u003e        pset.append(i)\u003cbr\u003e    return pset\u003cbr\u003e\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of ’nums’ sums exactly to ’\u003cbr\u003e    target’.\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    # base cases\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    first = nums[0]\u003cbr\u003e    include = subset_sum(nums[1: ], target - first)\u003cbr\u003e    exclude = subset_sum(nums[1: ], target)\u003cbr\u003e    return include or exclude\u003cbr\u003e\u003cbr\u003e# test cases\u003cbr\u003eprint(subset_sum([1, 2, 3], 7))\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return (\"True\")\u003cbr\u003e    for i in nums:\u003cbr\u003e        if i==target:\u003cbr\u003e            return (\"True\")\u003cbr\u003e            break\u003cbr\u003e        for j in range(1,len(nums)):\u003cbr\u003e            if i+nums[j]==target:\u003cbr\u003e                return (\"True\")\u003cbr\u003e                break\u003cbr\u003e    else:\u003cbr\u003e        return (\"False\")\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))\u003cbr\u003eprint( subset_sum([1,2,3],7))\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    def backtrack(start, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if current_sum &gt; target or start == len(nums):\u003cbr\u003e            return False\u003cbr\u003e        return (backtrack(start + 1, current_sum + nums[start]) or\u003cbr\u003e                backtrack(start + 1, current_sum))\u003cbr\u003e    return backtrack(0, 0)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if nums==[]:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(nums[1:],target-nums[0]) or subset_sum(nums[1:],target)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e   is_subset_sum=False\u003cbr\u003e   for  i in range(len(nums)):\u003cbr\u003e        for j in range(i+1,len(nums)):\u003cbr\u003e            sum=nums[i]+nums[j]\u003cbr\u003e            if sum==target:\u003cbr\u003e                is_subset_sum=True\u003cbr\u003e                break\u003cbr\u003e        if is_subset_sum:\u003cbr\u003e            break\u003cbr\u003e   return is_subset_sum","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    a = subset_sum(nums[1:], target)\u003cbr\u003e    b = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e\u003cbr\u003e    return a or b\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3, 34, 4, 12, 5, 2], 9)) \u003cbr\u003eprint(subset_sum([1, 2, 3], 7))             \u003cbr\u003eprint(subset_sum([], 0))                    \u003cbr\u003e","analysis.embedding.code_embedding"],["# Q18\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if index == len(nums) or current_sum &gt; target:\u003cbr\u003e            return False\u003cbr\u003e\u003cbr\u003e        if backtrack(index + 1, current_sum + nums[index]):\u003cbr\u003e            return True\u003cbr\u003e        if backtrack(index + 1, current_sum):\u003cbr\u003e            return True\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    return backtrack(0, 0)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(m,n):\u003cbr\u003e    if  n==0:\u003cbr\u003e        return True\u003cbr\u003e    if not m:\u003cbr\u003e        return False\u003cbr\u003e    if subset_sum(m[1:],n-m[0]):\u003cbr\u003e        return True\u003cbr\u003e    if subset_sum(m[1:],n):\u003cbr\u003e        return True\u003cbr\u003e    return False\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2],9))\u003cbr\u003eprint(subset_sum([1,2,3],7))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True \u003cbr\u003e    if not nums:\u003cbr\u003e        return False \u003cbr\u003e    last = nums[-1]\u003cbr\u003e    return subset_sum(nums[:-1], target - last) or subset_sum(nums[:-1], target)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    # what i am thinking of is creating a power set of the elements with numbers only consisting of those which are less than target\u003cbr\u003e    new_nums=[req for req in nums if req&lt;=target]\u003cbr\u003e    \u003cbr\u003e    #now to create all possible subsets of a set let's try backtracking\u003cbr\u003e    def powerset(lst):\u003cbr\u003e        res=[]\u003cbr\u003e        sol=[]\u003cbr\u003e        n=len(lst)\u003cbr\u003e        def backtrack(i):\u003cbr\u003e            if i==n:\u003cbr\u003e                res.append(sol[:])\u003cbr\u003e                return\u003cbr\u003e            #pick number\u003cbr\u003e            sol.append(lst[i])\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    l=getSubsets(nums)\u003cbr\u003e    for i in l:\u003cbr\u003e        s=0\u003cbr\u003e        for j in i:\u003cbr\u003e            s+=j\u003cbr\u003e        if s==target:\u003cbr\u003e            return True\u003cbr\u003e    return False\u003cbr\u003edef getSubsets(nums): #RECURSIVE METHOD TO FIND SUBSETS\u003cbr\u003e    if nums==[]:\u003cbr\u003e        return [[]]\u003cbr\u003e    s=getSubsets(nums[1:])\u003cbr\u003e    return (s+[[nums[0]]+i for i in s])\u003cbr\u003e","analysis.embedding.code_embedding"],["def integerToPaddedBinary(integer, length):\u003cbr\u003e\u003cbr\u003e    bits = decimalToBinary(integer)\u003cbr\u003e    while len(bits) &lt; length:\u003cbr\u003e        bits = \"0\" + bits\u003cbr\u003e\u003cbr\u003e    return bits\u003cbr\u003e\u003cbr\u003e\u003cbr\u003edef decimalToBinary(num):\u003cbr\u003e    \"\"\"Calculates binary using recursion\"\"\"\u003cbr\u003e    \u003cbr\u003e    if num == 0:\u003cbr\u003e        return \"\"\u003cbr\u003e    elif num == 1:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    power_set=[]\u003cbr\u003e    flag=False\u003cbr\u003e    def subset(id, sub):\u003cbr\u003e        if id == len(nums):\u003cbr\u003e            power_set.append(sub)\u003cbr\u003e            return\u003cbr\u003e        subset(id+1,sub)\u003cbr\u003e        subset(id+1,sub + [nums[id]])\u003cbr\u003e    subset(0,[])\u003cbr\u003e    for i in range(0,len(power_set)):\u003cbr\u003e        sum=0\u003cbr\u003e        for j in range (0,len(power_set[i])):\u003cbr\u003e            sum=sum+power_set[i][j]\u003cbr\u003e        if sum==target:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(numbers, goal):\u003cbr\u003e    if goal == 0:\u003cbr\u003e        return True\u003cbr\u003e    if numbers == []:\u003cbr\u003e        return False\u003cbr\u003e    first = numbers[0]\u003cbr\u003e    rest = numbers[1:]\u003cbr\u003e    if first &gt; goal:\u003cbr\u003e        return subset_sum(rest, goal)\u003cbr\u003e    return subset_sum(rest, goal - first) or subset_sum(rest, goal)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    leave_last = subset_sum(nums[:-1], target)\u003cbr\u003e    take_last = subset_sum(nums[:-1], target=target-nums[-1])\u003cbr\u003e\u003cbr\u003e    return leave_last or take_last","analysis.embedding.code_embedding"],["# pehle target se chhote numbers ka list banao then usko sort karo then do for laga ke sum dekhlo\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    new_list=[]\u003cbr\u003e    if len(nums)==0 and target==0:\u003cbr\u003e        return True\u003cbr\u003e    for i in nums:\u003cbr\u003e        if i==target:\u003cbr\u003e            return True\u003cbr\u003e\u003cbr\u003e        if i&lt;target:\u003cbr\u003e            new_list.append(i)\u003cbr\u003e\u003cbr\u003e    new_list.sort()\u003cbr\u003e\u003cbr\u003e    for i in range (len(new_list)-1):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3, 34, 4, 12, 5, 2], 9))","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"Return True if some subset of ’nums’ sums exactly to ’\u003cbr\u003e    target’.\u003cbr\u003e    Use recursion or backtracking.\"\"\"\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    f=nums[0]\u003cbr\u003e    r=nums[1:]\u003cbr\u003e    return subset_sum(r,target-f) or subset_sum(r,target)\u003cbr\u003e# print(subset_sum([3,34,4,12,5,2], 9)) # True\u003cbr\u003e# print(subset_sum([1,2,3], 7)) # False\u003cbr\u003e# print(subset_sum([], 0)) # True","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    def solve(i, s):\u003cbr\u003e        if s == target:\u003cbr\u003e            return True\u003cbr\u003e        if i == len(nums) or s &gt; target:\u003cbr\u003e            return False\u003cbr\u003e        return solve(i + 1, s + nums[i]) or solve(i + 1, s)\u003cbr\u003e        \u003cbr\u003e    return solve(0, 0)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e        \u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e        \u003cbr\u003e    n = nums[0]\u003cbr\u003e    rest = nums[1:]\u003cbr\u003e    \u003cbr\u003e    include = subset_sum(rest, target - n)\u003cbr\u003e    \u003cbr\u003e    exclude = subset_sum(rest, target)\u003cbr\u003e    \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\"\"\" Return True if some subset of ’nums’ sums exactly to target\u003cbr\u003eUse recursion or backtracking\u003cbr\u003esubset_sum([3,34,4,12,5,2], 9) # True\u003cbr\u003esubset_sum([1,2,3], 7) # False\u003cbr\u003esubset_sum([], 0) # True  \"\"\"\u003cbr\u003e\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    n = len(nums)\u003cbr\u003e    new = []\u003cbr\u003e    for i in range(2 ** n):\u003cbr\u003e        subset = [nums[j] for j in range(n) if (i &gt;&gt; j) &amp; 1]\u003cbr\u003e        new.append(subset)\u003cbr\u003e    for element in new:\u003cbr\u003e        if sum(element)==target:\u003cbr\u003e            return True\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    possible_sums = {0}  # we can always make sum = 0 with empty subset\u003cbr\u003e\u003cbr\u003e    for num in nums:\u003cbr\u003e        new_sums = set()\u003cbr\u003e        for s in possible_sums:\u003cbr\u003e            new_sums.add(s + num)  # include current num\u003cbr\u003e        possible_sums |= new_sums  # merge new sums into existing ones\u003cbr\u003e\u003cbr\u003e        if target in possible_sums:\u003cbr\u003e            return True  # early stop if we reached target\u003cbr\u003e\u003cbr\u003e    return target in possible_sums\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9)) # True\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    first=nums[0]\u003cbr\u003e    if subset_sum(nums[1:], target-first):\u003cbr\u003e        return True\u003cbr\u003e    if subset_sum(nums[1:], target):\u003cbr\u003e        return True\u003cbr\u003e    return False","analysis.embedding.code_embedding"],["perm=[]\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    n=len(nums)\u003cbr\u003e\u003cbr\u003e    if len(perm) &gt;= (2**n):\u003cbr\u003e        for i in perm:\u003cbr\u003e            s=sum(i)\u003cbr\u003e            if(s==target):\u003cbr\u003e                return True\u003cbr\u003e        return False\u003cbr\u003e        \u003cbr\u003e    if not perm:                    \u003cbr\u003e        perm.append([])\u003cbr\u003e        for i in nums:\u003cbr\u003e            perm.append([i])\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of ’nums’ sums exactly to ’\u003cbr\u003e    target’.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    possible_sums = {0}\u003cbr\u003e    for num in nums:\u003cbr\u003e        new_sums = set()\u003cbr\u003e        for s in possible_sums:\u003cbr\u003e            new_sums.add(s + num)\u003cbr\u003e        possible_sums.update(new_sums)\u003cbr\u003e    return target in possible_sums","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    def helper(index,current_sum):\u003cbr\u003e        if current_sum==target:\u003cbr\u003e            return True\u003cbr\u003e        if index==len(nums) or current_sum&gt;target:\u003cbr\u003e            return False\u003cbr\u003e        return helper(index+1,current_sum+nums[index]) or helper(index+1,current_sum)\u003cbr\u003e    return helper(0, 0)\u003cbr\u003e\u003cbr\u003e                  \u003cbr\u003e\u003cbr\u003e    \u003cbr\u003e    ","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    def subsets(lst):\u003cbr\u003e        if lst == []:\u003cbr\u003e            return [[]]\u003cbr\u003e    \u003cbr\u003e        rest_subsets = subsets(lst[1:])\u003cbr\u003e        new_subsets = []\u003cbr\u003e    \u003cbr\u003e        for s in rest_subsets:\u003cbr\u003e            new_subsets.append([lst[0]] + s)\u003cbr\u003e        a=rest_subsets + new_subsets\u003cbr\u003e    \u003cbr\u003e        return a\u003cbr\u003e\u003cbr\u003e  \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        if current_sum == 0:\u003cbr\u003e            return True\u003cbr\u003e        if index == len(nums):\u003cbr\u003e            return False\u003cbr\u003e        if backtrack(index + 1, current_sum - nums[index]):\u003cbr\u003e            return True\u003cbr\u003e        if backtrack(index + 1, current_sum):\u003cbr\u003e            return True\u003cbr\u003e        return False\u003cbr\u003e    if not nums:\u003cbr\u003e        return target == 0\u003cbr\u003e    return backtrack(0, target)","analysis.embedding.code_embedding"],["##q18\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    ","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    for i in power_set(nums):\u003cbr\u003e        if sum(i) == target:\u003cbr\u003e            return True\u003cbr\u003e    return False\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e\u003cbr\u003edef power_set(nums):\u003cbr\u003e    if not nums:\u003cbr\u003e        return [[]]\u003cbr\u003e    first = nums[0]\u003cbr\u003e    rest_power_set = power_set(nums[1:])\u003cbr\u003e    with_first = []\u003cbr\u003e    for subset in rest_power_set:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    new_list=[]\u003cbr\u003e    if len(nums)==0 and target==0:\u003cbr\u003e        return True\u003cbr\u003e    for i in nums:\u003cbr\u003e        if i==target:\u003cbr\u003e            return True\u003cbr\u003e\u003cbr\u003e        if i&lt;target:\u003cbr\u003e            new_list.append(i)\u003cbr\u003e\u003cbr\u003e    new_list.sort()\u003cbr\u003e\u003cbr\u003e    for i in range (len(new_list)-1):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums or target &lt; 0:\u003cbr\u003e        return False\u003cbr\u003e    if subset_sum(nums[1:], target - nums[0]):\u003cbr\u003e        return True\u003cbr\u003e    \u003cbr\u003e    if subset_sum(nums[1:], target):\u003cbr\u003e        return True\u003cbr\u003e    return False","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        return False\u003cbr\u003e    last=nums[-1]\u003cbr\u003e    include=subset_sum(nums[:-1],target-last)\u003cbr\u003e    exclude=subset_sum(nums[:-1],target)\u003cbr\u003e    return include or exclude\u003cbr\u003e\u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))\u003cbr\u003eprint(subset_sum([1,2,3], 7))\u003cbr\u003eprint(subset_sum([], 0))\u003cbr\u003e    \u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    last=nums[-1]\u003cbr\u003e    a=subset_sum(nums[:-1],target-last)\u003cbr\u003e    b=subset_sum(nums[:-1],target)\u003cbr\u003e    return a or b","analysis.embedding.code_embedding"],["def subset_sum(nums, target): \u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking. \u003cbr\u003e    \"\"\"\u003cbr\u003e    if len(nums) == 0:\u003cbr\u003e        return 0 == target\u003cbr\u003e    \u003cbr\u003e    for i in range(len(nums)):\u003cbr\u003e        if subset_sum(nums[i+1:], target - nums[i]):\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e    return False","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True      # agar target 0 ho gaya, matlab subset mil gaya\u003cbr\u003e    if not nums:\u003cbr\u003e        return False     # agar list khatam ho gayi, aur target nahi mila\u003cbr\u003e\u003cbr\u003e    # Option 1: include first element\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e\u003cbr\u003e    # Option 2: exclude first element\u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e    return include or exclude   # agar dono me se koi True hai, to True\u003cbr\u003e\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["\u003cbr\u003e\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    \u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        # Base case: if current sum equals target\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        \u003cbr\u003e        # Base case: if we've processed all elements\u003cbr\u003e        if index &gt;= len(nums):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e# Base cases\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e# Choice 1: include the first element\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    \u003cbr\u003e# Choice 2: exclude the first element\u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e    return include or exclude","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    p = nums[0]\u003cbr\u003e    include = subset_sum(nums[1:],target-p)\u003cbr\u003e    exclude = subset_sum(nums[1:],target)\u003cbr\u003e    return include or exclude\u003cbr\u003e","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    def backtrack(index, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if index == len(nums) or current_sum &gt; target:\u003cbr\u003e            return False\u003cbr\u003e        if backtrack(index + 1, current_sum + nums[index]):\u003cbr\u003e            return True\u003cbr\u003e        return backtrack(index + 1, current_sum)\u003cbr\u003e\u003cbr\u003e    return backtrack(0, 0)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    if nums[0] &gt; target:\u003cbr\u003e        return subset_sum(nums[1:], target)\u003cbr\u003e    return subset_sum(nums[1:], target - nums[0]) or subset_sum(nums[1:], target)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    last=nums[-1]\u003cbr\u003e    include=subset_sum(nums[:-1],target-last)\u003cbr\u003e    exclude=subset_sum(nums[:-1],target)\u003cbr\u003e    return include or exclude","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    last = nums[-1]\u003cbr\u003e    remaining = nums[:-1]\u003cbr\u003e    no_last = subset_sum(remaining,target)\u003cbr\u003e    inc_last = False\u003cbr\u003e    if target&gt;=last:\u003cbr\u003e        inc_last = subset_sum(remaining,target-last)\u003cbr\u003e    return inc_last or no_last","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \u003cbr\u003e    if target == 0:\u003cbr\u003e        \u003cbr\u003e        return True\u003cbr\u003e    \u003cbr\u003e    if len(nums) == 0:\u003cbr\u003e        \u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    last_num = nums[-1]\u003cbr\u003e    \u003cbr\u003e    remaining_nums = nums[:-1]\u003cbr\u003e    \u003cbr\u003e    return subset_sum(remaining_nums, target - last_num) or subset_sum(remaining_nums, target)\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["target_possible = False\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        if target==0: return True\u003cbr\u003e        else: return False\u003cbr\u003e\u003cbr\u003e    global target_possible\u003cbr\u003e    target_possible = False\u003cbr\u003e\u003cbr\u003e    used = [False for i in range (len(nums))]\u003cbr\u003e\u003cbr\u003e    helper(nums, target, used)\u003cbr\u003e\u003cbr\u003e    return target_possible\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target, memo=None):\u003cbr\u003e    \"\"\"\u003cbr\u003e    returning True if some subset of 'nums' sums exactly to'target'\u003cbr\u003e    \u003cbr\u003e    \"\"\"\u003cbr\u003e    if memo is None:\u003cbr\u003e        memo = {}\u003cbr\u003e    if (len(nums), target) in memo:\u003cbr\u003e        return memo[(len(nums), target)]\u003cbr\u003e\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    \u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    first = nums[0]\u003cbr\u003e\u003cbr\u003e    return subset_sum(nums[1: ], target - first) or subset_sum(nums[1 :], target) \u003cbr\u003e\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9))\u003cbr\u003eprint(subset_sum([1,2,3], 7))\u003cbr\u003eprint(subset_sum([], 0))","analysis.embedding.code_embedding"],["c = 0\u003cbr\u003edef subset_sum(nums,target):\u003cbr\u003e    l = nums.copy()\u003cbr\u003e    subsets = list()\u003cbr\u003e    for i in l:\u003cbr\u003e        if i == target:\u003cbr\u003e            return True\u003cbr\u003e    for i in l:\u003cbr\u003e        i += nums[c]\u003cbr\u003e        \u003cbr\u003e    ","analysis.embedding.code_embedding"],["def subset_sum(nums,target):\u003cbr\u003e    if target==0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e    present=nums[0]\u003cbr\u003e    rem=nums[1:]\u003cbr\u003e    if subset_sum(rem,target-present):\u003cbr\u003e        return True\u003cbr\u003e    if subset_sum(rem,target):\u003cbr\u003e        return True\u003cbr\u003e    return False\u003cbr\u003eprint(spiral_order([[1,2,3],[4,5,6],[7,8,9]]))  # [1,2,3,6,9,8,7,4,5]\u003cbr\u003eprint(spiral_order([[1,2],[3,4]]))             # [1,2,4,3]\u003cbr\u003e   ","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of ’nums’ sums exactly to ’\u003cbr\u003e    target’.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    a =[x for x in nums if x &lt;= target]\u003cbr\u003e    \u003cbr\u003e    if target ==0 and len(nums) ==0:\u003cbr\u003e        return True\u003cbr\u003e    if target ==0 and len(nums) !=0:\u003cbr\u003e        return False\u003cbr\u003e    \u003cbr\u003e    \u003cbr\u003e    def rotate(list1):\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to 'target'.\u003cbr\u003e    Use recursion or backtracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    # base cases\u003cbr\u003e    if target == 0:\u003cbr\u003e        return True\u003cbr\u003e    if not nums:\u003cbr\u003e        return False\u003cbr\u003e\u003cbr\u003e    # choose to include the first number or skip it\u003cbr\u003e    include = subset_sum(nums[1:], target - nums[0])\u003cbr\u003e    exclude = subset_sum(nums[1:], target)\u003cbr\u003e\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["count = 0\u003cbr\u003edef subset_sum(nums, target):\u003cbr\u003e    \"\"\"\u003cbr\u003e    Return True if some subset of 'nums' sums exactly to'target'.\u003cbr\u003e    Use recursion or back tracking.\u003cbr\u003e    \"\"\"\u003cbr\u003e    global count\u003cbr\u003e    \u003cbr\u003e    l=nums\u003cbr\u003e    if l==[] and target==0:\u003cbr\u003e        return True\u003cbr\u003e    elif l==0 and target!=0:\u003cbr\u003e        return False\u003cbr\u003e    for x in l:\u003cbr\u003e        if x==target:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums,target): \u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        print('0')\u003cbr\u003e    else:\u003cbr\u003e        a=nums.pop(0)\u003cbr\u003e        target=target-a\u003cbr\u003e    b=len(nums)\u003cbr\u003e    if target==0:\u003cbr\u003e        print(\"true\") \u003cbr\u003e    else:\u003cbr\u003e        print(\"false\")\u003cbr\u003e    if len(nums)==0:\u003cbr\u003e        if target==0:\u003cbr\u003e            print('final true')\u003cbr\u003e        else:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    def all_subsets(lst):\u003cbr\u003e        subsets = []\u003cbr\u003e        n = len(lst)\u003cbr\u003e        for i in range(2 ** n):\u003cbr\u003e            subset = []\u003cbr\u003e            for j in range(len(lst)):\u003cbr\u003e                a = (i \u002f\u002f (2 ** j)) % 2   \u003cbr\u003e                if a == 1:\u003cbr\u003e                    subset.append(lst[j])\u003cbr\u003e            subsets.append(subset)\u003cbr\u003e        return subsets\u003cbr\u003e    \u003cbr\u003e    for i in all_subsets(nums):\u003cbr\u003e        if sum(i)==target:\u003cbr\u003e... (truncated)","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    for i in range(len(nums)-1):\u003cbr\u003e        for j in range(len(nums)-1):\u003cbr\u003e            if i != j and nums[i]+nums[j] == target:\u003cbr\u003e                return True\u003cbr\u003e    else:\u003cbr\u003e        return False\u003cbr\u003e    if not nums and target == 0:\u003cbr\u003e        return True\u003cbr\u003eprint(subset_sum([3,34,4,12,5,2], 9)) # True","analysis.embedding.code_embedding"],["def subset_sum(nums, target):\u003cbr\u003e    \"\"\"Return True if some subset of 'nums' sums exactly to 'target'. Use recursion or backtracking. Input: nums: list[int], target: int Output: bool\"\"\"\u003cbr\u003e    def recurse(index, current_sum):\u003cbr\u003e        if current_sum == target:\u003cbr\u003e            return True\u003cbr\u003e        if current_sum &gt; target or index &gt;= len(nums):\u003cbr\u003e            return False\u003cbr\u003e        return recurse(index + 1, current_sum + nums[index]) or recurse(index + 1, current_sum)\u003cbr\u003e    \u003cbr\u003e    return recurse(0, 0)","analysis.embedding.code_embedding"]],"hovertemplate":"\u003cb\u003eStudent ID:\u003c\u002fb\u003e %{hovertext}\u003cbr\u003e\u003cb\u003ePass Percentage:\u003c\u002fb\u003e %{marker.color:.2f}%\u003cbr\u003e\u003cb\u003eSource:\u003c\u002fb\u003e %{customdata[1]}\u003cbr\u003e\u003cbr\u003e\u003cb\u003eCode Snippet:\u003c\u002fb\u003e\u003cbr\u003e%{customdata[0]}\u003cextra\u003e\u003c\u002fextra\u003e","hovertext":["B25EE030-q18","B25EE016_q18","B25DS001_q18","B25DS036_q18","B25ME035_Q18","B25EE033_q18","b25me058_q18","B25ME033_Q18","B25EE051_q18","B25MM006_q18","B25MT003_q18","B25CS026_q18","B25DS010_q18","B25ME046_q18","B25ME016_q18","B25DS031_q18","B25EE043_q18","S25MA001__q18","B25EC019_q18","B25ME031_q18","B25ME041_q18","B25CS022_q18","S25MA014_q18","B25EC020_q18","B25EC015_q18","B25CS009_q18","B25CS060_q18","B25ME024_q18","B25MT021_q18","B25MT020_Q18","B25DS011_q18","B25CS012_q18","B25ME060_q18","B25MM015_Q18","B25CS045_Q18","B25ME027_Q18","B25DS004_q18","B25DS026.q18","B25EE036_q18","B25CS055_q18","B25MM009(q18)","B25CS029_q18","B25MT004_q18","B25ME056_q18","B25ME009_q18","B25EE058_q18","B25ME003_q18","(B25DS042)_Q18","B25EE029_q18","{B25MM017}_q18","B25DS008_q18","B25ME012_q18","B25CS004_q18","B25EE026_q18","B25MM004_q18","B25EE053_q18","B25ME029_q18","S25MA004_q18","B25MT032_q18","B25ME037_q18","B25DS029_q18","B25EE007_q18","B25ME043_q18","B25DS028_q18","B25ME048_q18","B25ME057_q18","B25EC010_q18","B25CS039_q18","Q18 B25MM007","B25EE060_q18","B25CS042_Q18","B25DS018_q18","B25EC043_q18","B25DS014_q18","B25CS036_q18","B25CS028_q18","B25ME006_Q18","B25CS017_Q18","B25CS050_q18","B25MT025_q18","B25EE021_q18","B25EE046_q18","B25MM030_Q18","B25EE042_q18","B25DS032_q18","B25EC039_q18","B25EC025_q18","B25ME014 _q18.py","B25EE001_q18","B25CS010_q18","B25DS037_Q18.py","B25DS035_q18","B25MM008_Q18","B25MT006_Q18","B25MM018_q18","B25CS019_q18","B25EE044_q18","B25EE004_q18","B25CS035_q18","B25CS005_q18","B25CS044_Q18","B25EE045_q18","B25ME004_q18","q18","B25DS034_q18","B25DS030_q18","B25EC001_q18","B25ME023 q18","B25MT018_q18","B25ME030_q18","B25EE006.Q18","B25EE034_q18","B25CS062_q18","B25MT029_Q18","B25MM012_Q18","B25CS034_q18","B25ME051_q18","B25MM013_q18","B25EC004_Q18","B25ME002_q18","B25EC034_q18","B25EC044_Q18","B25EC036_q18","B25DS025_q18","B25EE025_q18","S25MA008  Q18","B25EE024_q18.py","B25CS007_q18","B25EE017_q18","B25EC045_q18","B25DS038_q18","B25CS043-q18","B25ME028_q18","B25MM023_q18","B25ME034_q18","B25EC009_q18","B25EE011_q18","B25MT027_q18","B25EE050_q18","B25EE039_q18","B25EC012_q18","B25EE023_q18","B25ME019_q18","B25ME049_q18","B25MT002_q18","B25EC033_q18","B25EC021_q18","B25MT019_q18","B25CS025_q18","B25CS037_q18","B25MM026_q18","B25EE002_q18","B25ME018_q18","b25cs049_q18","B25MT008_q18","B25ME010_q18","B25DS012_Q18","B25CS051_q18","B25DS017_q18","B25EC011-Q18","B25EE009_q18","B25DS033_Q18","B25DS016_q18","B25EE012_q18","B25DS024_Q18","B25CS041_q18","B25CS038-Q18","B25ME039_q18","B25EE035_Q18","B25EC035_q18","B25MT010_q18","B25CS030_q18","B25CS020_q18","B25CS023_Q18","B25MM020_q18","B25DS013_Q18","B25EE054_q18","B25EE015_Q18","B25ME007_q18","B25ME017_q18","B25CS061_q18","B25DS007_Q18","B25EC005_Q18","B25EC031_q18","B25CS014_q18","B25DS020_Q18","B25ME021_q18","B25ME050_q18","B25EE019_q18","B25EE031_q18","B25MT014_q18","{B25CS013}_q18","B25MM027_q18","B25CS033_q18","B25EE018_Q18","B25MM028_q18","B25MT017_q18","B25CS059_q18","B25DS019_q18","B25CS047_q18","\u003cB25CS024\u003e_q18","B25MM016_Q18","B25MT024_q18","B25EC037_q18","B25EC026_q18","B25MT026_q18","B25ME013_q18","B25DS021_q18","B25ME008_Q18","B25ME045_q18","B25EC022_q18","B25EE027_Q18","b25me047_q18","B25EC008_q18","B25EE013_q18","B25EE037_q18","S25MA011_q18","B25EC017_q18","B25CS048_q18","B25ME026_q18","B25EC027_q18","B25DS006_q18","B25EE003_q18","B25EC038_Q18","B25CS008_Q18","B25EC007_q18","B25EC041_q18","B25EC032_Q18","B25DS039_Q18","B25CS016_q18","B25MT023 Q 18","B25MT001_Q18","B25EE059_q18","B25MT022_q18","B25DS015_q18","B25DS027_q18","B25MM002_q18","B25EE049_q18","B25EE020_q18","B25DS041_q18","B25CS054_q18","B25ME011_q18","B25EC024_q18","B25MT009_Q18","B25MT007_q18","B25EC014_q18","B25MT005_q18","B25EC006_q18","B25MM025_q18","B25DS023_q18","B25EE028_q18","B25DS043_q18"],"legendgroup":"","marker":{"color":{"dtype":"f8","bdata":"AAAAAAAAAAAAAAAAAABZQFZVVVVV1VRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABWVVVVVdVUQAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAVlVVVVXVVEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQKqqqqqqqjBAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVlVVVVXVVEAAAAAAAAAAAFZVVVVV1VRAAAAAAAAAAAAAAAAAAABZQKqqqqqqqkBAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAVlVVVVXVVEAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAFZVVVVV1VRAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKqqqqqqqlBAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAVlVVVVXVVEAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUCqqqqqqqowQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQKqqqqqqqlBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAqqqqqqqqUEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQFZVVVVV1VRAAAAAAAAAAAAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlAVlVVVVXVVEAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUBWVVVVVdVUQAAAAAAAAAAAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAFlAAAAAAAAAWUAAAAAAAABZQAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAAAAqqqqqqqqMEAAAAAAAAAAAFZVVVVV1VRAAAAAAAAAWUBWVVVVVdVUQAAAAAAAAAAAAAAAAAAAWUAAAAAAAAAAAAAAAAAAAFlA"},"coloraxis":"coloraxis","symbol":"circle","line":{"color":"DarkSlateGrey","width":1},"size":12},"mode":"markers","name":"","orientation":"v","showlegend":false,"x":{"dtype":"f4","bdata":"N5MCQSZbMEHxlgpBj\u002fksQQ+1E0G1OjRBgVIsQZFBGEGwBh1BTuEBQaRkMkFNsI9AAXsTQSnyBkGVTq5A4ZwgQXGaE0FbEIdAmSyGQPzSDEEPgCFBXYySQLLmHkFaxh1Bf8sOQfDCk0D8XxNBNBwjQaXgHUFcUyRBIgYKQQ9P\u002fUA0ACNBceqWQNFLD0GNbxlBgjgQQbJmEUGnZhZBnTabQKEMCkG+7\u002ftAAMcZQYXZhECv8ZNAFOwSQQMFGkHyOQZBtMMRQYnKK0GmWQRBVvQEQcPbF0GKeZZApEkVQfbdKEElrw1Bmw4TQYde\u002fEAfKC1BP02GQFdtGUGR3YhArZ4TQUAegkBckSRB4BwdQajnFkHgXoBA7ZAPQYoJGUHj0ZtADsURQSMhFEG\u002feK9Af\u002fsQQVyDAUG4\u002fPtAX\u002fQvQRg7EkHu8jJBNH4XQbeqD0FrvxJBQLOZQDuwGEFmLRNB1JOVQDfbLkG24JJAJBYJQVk\u002fBUGAcBBB0WIUQX5zBEEqzpJAel0CQVCR7EBlFp9A550MQTq\u002fiUCYegVBN98QQSXbJUG0mRlBraQQQSpzFkFe0zJB+dQTQU0CB0FPRpZAB1UlQZZqAUG+HfdALJgvQb\u002fPCUHGhx5BoGsNQVrtFkHR1gVBrkwjQQpM9EDE7ghBcJGYQFFvHUHcWgBBLdoTQfe9m0CucRBBZ\u002fT8QAivJEHSxSxBt\u002fMHQatdBEHkyCVBSHAUQZ30oUDCliBBflITQeJ4hkBbLiRBuFcHQQKUEUEs+ZVAUa2CQBrdDkHdUxZBbywcQQNP9kCtvg5BgvQYQVvqBUFLNYFAV+UQQUan+0DFFQ1BmRIlQWM4MkHB+htBxGyCQPNm+EC3GRBBfXMBQQDXMEFU6BdBlsiBQDBMIUFQeQ1BN4KUQKjo6UC41P5Ai7kTQaKNF0FM9oRA4aogQdwSBkGqSxdBsKUfQWP\u002fAEGLQRdBdrKFQFNNMUEQ+gpB7d\u002fkQMbUiEAydP9A1+orQQvTlkDCaIFAAgkbQQZIfkBY9C1B18OWQFcH4kD\u002fyjNB4bwGQZ6tiEC9pBZBOE0FQWKjEUHr65dAhbMJQSa8E0FLBetAP3v6QDFx4UBXiOdAcJEcQQdQEkHZ\u002fRBBRcETQWSwm0BL+RhBbAswQQSnl0BAnAVBYLkfQSdwA0EbLKFAoUmaQC\u002f8+kDhVYFAReUmQUiUC0HcMu1ApSsPQe78IUHwBwxBeEYWQYJpi0Ag0xpB1O2EQMj4I0Gq\u002fzJBvZ0XQXvbiEDGBSdBbl8YQYQsFkG5gxBBF3oOQQ3WFkGwMRpBLTkEQU8V\u002f0CEJq9AxH+EQDZAqkDRShVBhM3yQDQIBkEkR4JA"},"xaxis":"x","y":{"dtype":"f4","bdata":"i7gGQGhKzUD8C6lAFd21QD3mQUCvb9lA4RzjQEFBNT\u002f\u002fYqBAQf66QBeD3UCWdatA1QSRP82D2D9ryj5AlQHeQNLJEkCMYUpAtCi7QJSIvz9ayttA0OvAQI+U20CTT6pAnqzEP\u002fUhrkAFtAtBQnSkQJ6bB0CCoJJAdv8iQBRCKUCfQYJA3NxCQBMEgT60hKRAhtTLQN9+JEC\u002fmdk\u002ff5bDQIXU+j\u002fDop1AXVksQNEYvkD277NAESvSQIf5Vz+dV0VArERDQMZQm0DneQtAY8Y2QBT01EAW27FARtblQMJQtEBwjKpA6+gLQIG\u002fpEAMOL5AzJS9QJZW70DTUVJABjwPQfeJlUDmrLFA5yejQH82+UChtrxAaYdhQFeZfT9r1DZAznbLQK8h\u002fEBfFL1ANiKFP2FpPkCqK41AWn3iQJuYD0GS9slAskQCQUsX1j7UwqRAOwlNQIoHDEHz444\u002fHEzCQHZI5ED9zMBAV95JQM4pWEA10b4+szQaQADPDUDUVTlAD8ugQKHHtEBs0MJALUdhQA9PjED5bpZAh5aAP4lEskB16KBAy5vUQN2FCEHxstNAd7wOQb8c0T+rLbFAg4GtQEQEBkAmTqFANnrjQJXml0AWf\u002fw\u002fNLSgPrLJ80B7SaFA7RKhQBEnh0CaEaBAjunHQPDHGEADW1FA7MvfQB1AR0Apc5lAHBOSQGCQsEBi6JlA899qQOxF2j+xa9tA34HMQD6DP0BjJZxAFFcQQZotvkBeIKFAqOKlQO4DaUDgFkxACI2FQBOq3T9sQA5B4+0jQPUWr0B9XZpA48hAP\u002fWYkECoNMNA2WggQDZzoUAHY6FAKFqhQNoBzEBfWyxAQFaiQIDQp0AghMg+EH5+QLvL4EBOg\u002fBAKOyYQLlUd0AMB0NArz+yQNjHiECk31lAuraZP0rJ0kDYAZ9AnF2QQLyvHECFkadAvCJoQI88FUALhgdBaldQQKc74kB7YEQ\u002fQYuoQAo0v0CwXJhA8XW7QGquPUC00E1AvdEaQGMyRUBmUJlABLRCQIcPrECJKt9AwWBUQCsMR0DnTd5ApICKQHOMK0CXOERApVYAQAK\u002fDkFdqaRAuCSxQFr5qUCcvadA1bopQMjfDUFSb8NA0Ek0QLUCukC77p1AHVnSQGdru0ArPTpAq0neQC08vUBAaMJAeglLQFIWrkBy70xAHo2wQPeymkAmLqhA0lu\u002fQAzwnUBJ7z8\u002fiyMDQeraykCcpD4\u002fKYKUQGkOrUAbotlAY+7uQApGR0DHbqZAYYcGQVsiCUE19hFAhTFKQLLwcT9TMilA55W3QOnuBUCwTcVAab69QBBqyEB8id1AgdejQIkNdkDGy5tA"},"yaxis":"y","type":"scatter"}],                        {"template":{"data":{"histogram2dcontour":[{"type":"histogram2dcontour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"choropleth":[{"type":"choropleth","colorbar":{"outlinewidth":0,"ticks":""}}],"histogram2d":[{"type":"histogram2d","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"heatmap":[{"type":"heatmap","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"contourcarpet":[{"type":"contourcarpet","colorbar":{"outlinewidth":0,"ticks":""}}],"contour":[{"type":"contour","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"surface":[{"type":"surface","colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]]}],"mesh3d":[{"type":"mesh3d","colorbar":{"outlinewidth":0,"ticks":""}}],"scatter":[{"fillpattern":{"fillmode":"overlay","size":10,"solidity":0.2},"type":"scatter"}],"parcoords":[{"type":"parcoords","line":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolargl":[{"type":"scatterpolargl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"bar":[{"error_x":{"color":"#2a3f5f"},"error_y":{"color":"#2a3f5f"},"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"scattergeo":[{"type":"scattergeo","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterpolar":[{"type":"scatterpolar","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"scattergl":[{"type":"scattergl","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatter3d":[{"type":"scatter3d","line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattermap":[{"type":"scattermap","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattermapbox":[{"type":"scattermapbox","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scatterternary":[{"type":"scatterternary","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"scattercarpet":[{"type":"scattercarpet","marker":{"colorbar":{"outlinewidth":0,"ticks":""}}}],"carpet":[{"aaxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"baxis":{"endlinecolor":"#2a3f5f","gridcolor":"white","linecolor":"white","minorgridcolor":"white","startlinecolor":"#2a3f5f"},"type":"carpet"}],"table":[{"cells":{"fill":{"color":"#EBF0F8"},"line":{"color":"white"}},"header":{"fill":{"color":"#C8D4E3"},"line":{"color":"white"}},"type":"table"}],"barpolar":[{"marker":{"line":{"color":"#E5ECF6","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"pie":[{"automargin":true,"type":"pie"}]},"layout":{"autotypenumbers":"strict","colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#2a3f5f"},"hovermode":"closest","hoverlabel":{"align":"left"},"paper_bgcolor":"white","plot_bgcolor":"#E5ECF6","polar":{"bgcolor":"#E5ECF6","angularaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"radialaxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"ternary":{"bgcolor":"#E5ECF6","aaxis":{"gridcolor":"white","linecolor":"white","ticks":""},"baxis":{"gridcolor":"white","linecolor":"white","ticks":""},"caxis":{"gridcolor":"white","linecolor":"white","ticks":""}},"coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"sequential":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"sequentialminus":[[0.0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1.0,"#f0f921"]],"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]]},"xaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"yaxis":{"gridcolor":"white","linecolor":"white","ticks":"","title":{"standoff":15},"zerolinecolor":"white","automargin":true,"zerolinewidth":2},"scene":{"xaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"yaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2},"zaxis":{"backgroundcolor":"#E5ECF6","gridcolor":"white","linecolor":"white","showbackground":true,"ticks":"","zerolinecolor":"white","gridwidth":2}},"shapedefaults":{"line":{"color":"#2a3f5f"}},"annotationdefaults":{"arrowcolor":"#2a3f5f","arrowhead":0,"arrowwidth":1},"geo":{"bgcolor":"white","landcolor":"#E5ECF6","subunitcolor":"white","showland":true,"showlakes":true,"lakecolor":"white"},"title":{"x":0.05},"mapbox":{"style":"light"}}},"xaxis":{"anchor":"y","domain":[0.0,1.0],"title":{"text":"UMAP Dim 1"},"gridcolor":"lightgray"},"yaxis":{"anchor":"x","domain":[0.0,1.0],"title":{"text":"UMAP Dim 2"},"gridcolor":"lightgray"},"coloraxis":{"colorbar":{"title":{"text":"Pass %"},"ticks":"outside","dtick":20},"colorscale":[[0.0,"rgb(0,0,0)"],[0.3333333333333333,"rgb(230,0,0)"],[0.6666666666666666,"rgb(255,210,0)"],[1.0,"rgb(255,255,255)"]],"cmin":0,"cmax":100},"legend":{"tracegroupgap":0,"title":{"text":"Pass Percentage"}},"title":{"text":"Code Submission Semantic Map — csl100_q18 (UMAP)"},"plot_bgcolor":"white","paper_bgcolor":"white"},                        {"responsive": true}                    )                };            </script>        </div>
<script>
(function() {
  const divId = "plot_csl100_q18";
  const gd = document.getElementById(divId);
  const xs = [8.160941123962402, 11.022253036499023, 8.661850929260254, 10.810927391052246, 9.231703758239746, 11.26433277130127, 10.770142555236816, 9.516007423400879, 9.814132690429688, 8.11750602722168, 11.14957046508789, 4.490271091461182, 9.217530250549316, 8.434121131896973, 5.447092533111572, 10.038300514221191, 9.225205421447754, 4.2207465171813965, 4.192944049835205, 8.801509857177734, 10.093764305114746, 4.579634189605713, 9.93132209777832, 9.860925674438477, 8.924681663513184, 4.617546081542969, 9.210933685302734, 10.194385528564453, 9.867344856262207, 10.27035140991211, 8.626497268676758, 7.915900707244873, 10.187549591064453, 4.716118335723877, 8.956009864807129, 9.589734077453613, 9.013795852661133, 9.08757209777832, 9.40006160736084, 4.850416660308838, 8.628083229064941, 7.873015403747559, 9.611083984375, 4.151552677154541, 4.6232523918151855, 9.182636260986328, 9.62622356414795, 8.38914680480957, 9.110279083251953, 10.736947059631348, 8.271886825561523, 8.309652328491211, 9.4911527633667, 4.702336311340332, 9.33047866821289, 10.554189682006836, 8.855259895324707, 9.191065788269043, 7.886538982391357, 10.822295188903809, 4.196929454803467, 9.589194297790527, 4.2770466804504395, 9.226239204406738, 4.066192626953125, 10.28548812866211, 9.819549560546875, 9.431556701660156, 4.0115814208984375, 8.972882270812988, 9.564828872680664, 4.869370937347412, 9.11060905456543, 9.258090019226074, 5.483489513397217, 9.061400413513184, 8.09457015991211, 7.874599456787109, 10.997160911560059, 9.139427185058594, 11.184309005737305, 9.468311309814453, 8.979178428649902, 9.171732902526855, 4.803131103515625, 9.543025016784668, 9.198583602905273, 4.674295425415039, 10.928519248962402, 4.589930534362793, 8.56790542602539, 8.32796573638916, 9.0274658203125, 9.274125099182129, 8.278196334838867, 4.5876665115356445, 8.147821426391602, 7.392738342285156, 4.9714837074279785, 8.78855037689209, 4.304593086242676, 8.342430114746094, 9.054495811462402, 10.366002082824707, 9.600025177001953, 9.040204048156738, 9.403116226196289, 11.176603317260742, 9.239495277404785, 8.438061714172363, 4.696082592010498, 10.333258628845215, 8.088521957397461, 7.722380638122559, 10.974651336669922, 8.613219261169434, 9.908147811889648, 8.838775634765625, 9.432947158813477, 8.364945411682129, 10.206220626831055, 7.634282112121582, 8.558292388916016, 4.767753601074219, 9.839676856994629, 8.02218246459961, 9.240765571594238, 4.866939067840576, 9.027753829956055, 7.904834270477295, 10.292732238769531, 10.798295974731445, 8.497000694274902, 8.272868156433105, 10.36154556274414, 9.277412414550781, 5.061110019683838, 10.036806106567383, 9.207639694213867, 4.202256202697754, 10.261317253112793, 8.458915710449219, 9.098634719848633, 4.686666488647461, 4.0836567878723145, 8.928979873657227, 9.395474433898926, 9.760848045349121, 7.697144985198975, 8.921551704406738, 9.559694290161133, 8.369715690612793, 4.037755489349365, 9.055991172790527, 7.864169120788574, 8.817814826965332, 10.31704044342041, 11.138766288757324, 9.748719215393066, 4.075777053833008, 7.762567043304443, 9.006278038024902, 8.09069538116455, 11.052490234375, 9.494220733642578, 4.0557355880737305, 10.081100463867188, 8.842117309570312, 4.640895366668701, 7.309650421142578, 7.963466644287109, 9.23279857635498, 9.472078323364258, 4.155065536499023, 10.041718482971191, 8.37960433959961, 9.455972671508789, 9.977951049804688, 8.062350273132324, 9.45350170135498, 4.178034782409668, 11.081377983093262, 8.686050415039062, 7.152334690093994, 4.275973320007324, 7.98293399810791, 10.744833946228027, 4.71326208114624, 4.044037818908691, 9.689699172973633, 3.9731459617614746, 10.872154235839844, 4.711406230926514, 7.063395977020264, 11.237059593200684, 8.421113014221191, 4.271193504333496, 9.4152193069458, 8.331352233886719, 9.102388381958008, 4.747548580169678, 8.606328010559082, 9.233434677124023, 7.344396114349365, 7.827544689178467, 7.045067310333252, 7.235393047332764, 9.785507202148438, 9.144537925720215, 9.06197452545166, 9.234684944152832, 4.86528205871582, 9.56086254119873, 11.002788543701172, 4.739137649536133, 8.35064697265625, 9.982757568359375, 8.21488094329834, 5.0366339683532715, 4.821487903594971, 7.8432841300964355, 4.041733264923096, 10.430974006652832, 8.723701477050781, 7.412458419799805, 8.948155403137207, 10.124250411987305, 8.751937866210938, 9.392204284667969, 4.356629371643066, 9.676544189453125, 4.154031753540039, 10.248237609863281, 11.187417984008789, 9.4760103225708, 4.276792049407959, 10.438909530639648, 9.523298263549805, 9.385868072509766, 9.032158851623535, 8.904807090759277, 9.427258491516113, 9.637130737304688, 8.263958930969238, 7.971351146697998, 5.473451614379883, 4.140596389770508, 5.320338249206543, 9.330765724182129, 7.587587356567383, 8.377002716064453, 4.071184158325195];
  const ys = [2.105013608932495, 6.415332794189453, 5.282712936401367, 5.683237552642822, 3.029677629470825, 6.7948832511901855, 7.097275257110596, 0.7080269455909729, 5.012084484100342, 5.843536853790283, 6.922252178192139, 5.3581037521362305, 1.1329599618911743, 1.691522240638733, 2.981104612350464, 6.937693119049072, 2.2935681343078613, 3.162203788757324, 5.848718643188477, 1.4963555335998535, 6.868451118469238, 6.028785705566406, 6.861884593963623, 5.322213649749756, 1.536517858505249, 5.44164514541626, 8.731450080871582, 5.139191627502441, 2.118873119354248, 4.582093238830566, 2.546842098236084, 2.644658088684082, 4.070510387420654, 3.0447301864624023, 0.25198420882225037, 5.141199111938477, 6.369692802429199, 2.5702435970306396, 1.7000044584274292, 6.112121105194092, 1.9596105813980103, 4.92611837387085, 2.6929543018341064, 5.9405293464660645, 5.623042106628418, 6.5677571296691895, 0.8436512351036072, 3.083472490310669, 3.0510663986206055, 4.853610038757324, 2.1793153285980225, 2.855858564376831, 6.654794692993164, 5.5579938888549805, 7.182406425476074, 5.634858131408691, 5.329643249511719, 2.186091184616089, 5.148376941680908, 5.944341659545898, 5.924413681030273, 7.4793195724487305, 3.2862441539764404, 8.952154159545898, 4.673091411590576, 5.552355766296387, 5.098620891571045, 7.787902355194092, 5.897293567657471, 3.5238897800445557, 0.990621030330658, 2.856714963912964, 6.35825252532959, 7.8791117668151855, 5.908736705780029, 1.0401065349578857, 2.975181818008423, 4.4115800857543945, 7.077801704406738, 8.974757194519043, 6.311348915100098, 8.14177131652832, 0.4181464612483978, 5.148782730102539, 3.203688383102417, 8.751840591430664, 1.1163314580917358, 6.07179069519043, 7.133845329284668, 6.025022983551025, 3.154195547103882, 3.377551555633545, 0.3726898729801178, 2.409466505050659, 2.21575927734375, 2.8958635330200195, 5.024787425994873, 5.649368762969971, 6.087942123413086, 3.5199692249298096, 4.384650707244873, 4.701046466827393, 1.0045937299728394, 5.570866107940674, 5.02837610244751, 6.644017696380615, 8.532681465148926, 6.615593433380127, 8.921011924743652, 1.6336897611618042, 5.536824703216553, 5.422059535980225, 2.094010353088379, 5.040789604187012, 7.108668327331543, 4.746897220611572, 1.9726283550262451, 0.31387484073638916, 7.61837100982666, 5.040219783782959, 5.033560276031494, 4.2235188484191895, 5.002148628234863, 6.247260093688965, 2.3872032165527344, 3.2711799144744873, 6.993642807006836, 3.113288164138794, 4.795307636260986, 4.56483268737793, 5.5176239013671875, 4.809617042541504, 3.6699187755584717, 1.705258846282959, 6.856895923614502, 6.390853404998779, 2.9923853874206543, 4.879563808441162, 9.021259307861328, 5.943066596984863, 5.035201072692871, 5.183917999267578, 3.640864849090576, 3.1888961791992188, 4.173465728759766, 1.7317527532577515, 8.890727996826172, 2.561394453048706, 5.47155237197876, 4.823912143707275, 0.753065288066864, 4.51867151260376, 6.100177764892578, 2.506399393081665, 5.045313835144043, 5.043338298797607, 5.042255401611328, 6.375226020812988, 2.6930768489837646, 5.073028564453125, 5.24420166015625, 0.3916330337524414, 3.9764442443847656, 7.024869441986084, 7.51602840423584, 4.778827667236328, 3.864546060562134, 3.047305107116699, 5.5702738761901855, 4.274394989013672, 3.4042749404907227, 1.2008888721466064, 6.587071418762207, 4.968975067138672, 4.51142692565918, 2.448225975036621, 5.236513614654541, 3.627120018005371, 2.3318212032318115, 8.47022533416748, 3.2553353309631348, 7.06978178024292, 0.7670971751213074, 5.266998767852783, 5.975102424621582, 4.761314392089844, 5.858147144317627, 2.9637703895568848, 3.2158632278442383, 2.4190514087677, 3.081200361251831, 4.791064262390137, 3.0422372817993164, 5.376895427703857, 6.973942279815674, 3.3184053897857666, 3.1101176738739014, 6.947009563446045, 4.328203201293945, 2.6804473400115967, 3.0659539699554443, 2.0052883625030518, 8.921632766723633, 5.145674228668213, 5.535732269287109, 5.311688423156738, 5.24189567565918, 2.6520283222198486, 8.867134094238281, 6.107338905334473, 2.817005157470703, 5.812830448150635, 4.935391902923584, 6.573378086090088, 5.856860637664795, 2.9099833965301514, 6.946492671966553, 5.913595676422119, 6.075225830078125, 3.1724534034729004, 5.440224647521973, 3.2021145820617676, 5.517226219177246, 4.834346294403076, 5.255633354187012, 5.979958534240723, 4.935552597045898, 0.7497449517250061, 8.19617748260498, 6.3392229080200195, 0.744699239730835, 4.640888690948486, 5.408009052276611, 6.8010382652282715, 7.466599941253662, 3.113649845123291, 5.201022624969482, 8.408051490783691, 8.570887565612793, 2.2806522846221924, 3.1592724323272705, 0.94507896900177, 2.6436965465545654, 5.737048625946045, 2.0927069187164307, 6.165733337402344, 5.929493427276611, 6.262947082519531, 6.923032760620117, 5.120056629180908, 3.844576120376587, 4.868624687194824];
  const ids = ["B25EE030-q18", "B25EE016_q18", "B25DS001_q18", "B25DS036_q18", "B25ME035_Q18", "B25EE033_q18", "b25me058_q18", "B25ME033_Q18", "B25EE051_q18", "B25MM006_q18", "B25MT003_q18", "B25CS026_q18", "B25DS010_q18", "B25ME046_q18", "B25ME016_q18", "B25DS031_q18", "B25EE043_q18", "S25MA001__q18", "B25EC019_q18", "B25ME031_q18", "B25ME041_q18", "B25CS022_q18", "S25MA014_q18", "B25EC020_q18", "B25EC015_q18", "B25CS009_q18", "B25CS060_q18", "B25ME024_q18", "B25MT021_q18", "B25MT020_Q18", "B25DS011_q18", "B25CS012_q18", "B25ME060_q18", "B25MM015_Q18", "B25CS045_Q18", "B25ME027_Q18", "B25DS004_q18", "B25DS026.q18", "B25EE036_q18", "B25CS055_q18", "B25MM009(q18)", "B25CS029_q18", "B25MT004_q18", "B25ME056_q18", "B25ME009_q18", "B25EE058_q18", "B25ME003_q18", "(B25DS042)_Q18", "B25EE029_q18", "{B25MM017}_q18", "B25DS008_q18", "B25ME012_q18", "B25CS004_q18", "B25EE026_q18", "B25MM004_q18", "B25EE053_q18", "B25ME029_q18", "S25MA004_q18", "B25MT032_q18", "B25ME037_q18", "B25DS029_q18", "B25EE007_q18", "B25ME043_q18", "B25DS028_q18", "B25ME048_q18", "B25ME057_q18", "B25EC010_q18", "B25CS039_q18", "Q18 B25MM007", "B25EE060_q18", "B25CS042_Q18", "B25DS018_q18", "B25EC043_q18", "B25DS014_q18", "B25CS036_q18", "B25CS028_q18", "B25ME006_Q18", "B25CS017_Q18", "B25CS050_q18", "B25MT025_q18", "B25EE021_q18", "B25EE046_q18", "B25MM030_Q18", "B25EE042_q18", "B25DS032_q18", "B25EC039_q18", "B25EC025_q18", "B25ME014 _q18.py", "B25EE001_q18", "B25CS010_q18", "B25DS037_Q18.py", "B25DS035_q18", "B25MM008_Q18", "B25MT006_Q18", "B25MM018_q18", "B25CS019_q18", "B25EE044_q18", "B25EE004_q18", "B25CS035_q18", "B25CS005_q18", "B25CS044_Q18", "B25EE045_q18", "B25ME004_q18", "q18", "B25DS034_q18", "B25DS030_q18", "B25EC001_q18", "B25ME023 q18", "B25MT018_q18", "B25ME030_q18", "B25EE006.Q18", "B25EE034_q18", "B25CS062_q18", "B25MT029_Q18", "B25MM012_Q18", "B25CS034_q18", "B25ME051_q18", "B25MM013_q18", "B25EC004_Q18", "B25ME002_q18", "B25EC034_q18", "B25EC044_Q18", "B25EC036_q18", "B25DS025_q18", "B25EE025_q18", "S25MA008  Q18", "B25EE024_q18.py", "B25CS007_q18", "B25EE017_q18", "B25EC045_q18", "B25DS038_q18", "B25CS043-q18", "B25ME028_q18", "B25MM023_q18", "B25ME034_q18", "B25EC009_q18", "B25EE011_q18", "B25MT027_q18", "B25EE050_q18", "B25EE039_q18", "B25EC012_q18", "B25EE023_q18", "B25ME019_q18", "B25ME049_q18", "B25MT002_q18", "B25EC033_q18", "B25EC021_q18", "B25MT019_q18", "B25CS025_q18", "B25CS037_q18", "B25MM026_q18", "B25EE002_q18", "B25ME018_q18", "b25cs049_q18", "B25MT008_q18", "B25ME010_q18", "B25DS012_Q18", "B25CS051_q18", "B25DS017_q18", "B25EC011-Q18", "B25EE009_q18", "B25DS033_Q18", "B25DS016_q18", "B25EE012_q18", "B25DS024_Q18", "B25CS041_q18", "B25CS038-Q18", "B25ME039_q18", "B25EE035_Q18", "B25EC035_q18", "B25MT010_q18", "B25CS030_q18", "B25CS020_q18", "B25CS023_Q18", "B25MM020_q18", "B25DS013_Q18", "B25EE054_q18", "B25EE015_Q18", "B25ME007_q18", "B25ME017_q18", "B25CS061_q18", "B25DS007_Q18", "B25EC005_Q18", "B25EC031_q18", "B25CS014_q18", "B25DS020_Q18", "B25ME021_q18", "B25ME050_q18", "B25EE019_q18", "B25EE031_q18", "B25MT014_q18", "{B25CS013}_q18", "B25MM027_q18", "B25CS033_q18", "B25EE018_Q18", "B25MM028_q18", "B25MT017_q18", "B25CS059_q18", "B25DS019_q18", "B25CS047_q18", "<B25CS024>_q18", "B25MM016_Q18", "B25MT024_q18", "B25EC037_q18", "B25EC026_q18", "B25MT026_q18", "B25ME013_q18", "B25DS021_q18", "B25ME008_Q18", "B25ME045_q18", "B25EC022_q18", "B25EE027_Q18", "b25me047_q18", "B25EC008_q18", "B25EE013_q18", "B25EE037_q18", "S25MA011_q18", "B25EC017_q18", "B25CS048_q18", "B25ME026_q18", "B25EC027_q18", "B25DS006_q18", "B25EE003_q18", "B25EC038_Q18", "B25CS008_Q18", "B25EC007_q18", "B25EC041_q18", "B25EC032_Q18", "B25DS039_Q18", "B25CS016_q18", "B25MT023 Q 18", "B25MT001_Q18", "B25EE059_q18", "B25MT022_q18", "B25DS015_q18", "B25DS027_q18", "B25MM002_q18", "B25EE049_q18", "B25EE020_q18", "B25DS041_q18", "B25CS054_q18", "B25ME011_q18", "B25EC024_q18", "B25MT009_Q18", "B25MT007_q18", "B25EC014_q18", "B25MT005_q18", "B25EC006_q18", "B25MM025_q18", "B25DS023_q18", "B25EE028_q18", "B25DS043_q18"];
  let searchTraceIndex = null;

  function updateSearch(query) {
    // remove prior search trace
    if (searchTraceIndex !== null && gd.data && gd.data[searchTraceIndex]) {
      Plotly.deleteTraces(gd, searchTraceIndex);
      searchTraceIndex = null;
    }
    query = (query || "").toLowerCase().trim();
    if (!query) return;
    const hits = [];
    for (let i=0; i<ids.length; i++) {
      if ((ids[i] || "").toLowerCase().includes(query)) {
        hits.push(i);
      }
    }
    if (!hits.length) return;
    const trace = {
      x: hits.map(i => xs[i]),
      y: hits.map(i => ys[i]),
      mode: 'markers+text',
      text: hits.map(i => ids[i]),
      textposition: 'top center',
      marker: {
        symbol: 'star',
        size: 20,
        color: 'rgba(0,0,0,0)',
        line: { color: 'red', width: 3 }
      },
      name: 'Search',
      hoverinfo: 'skip'
    };
    Plotly.addTraces(gd, [trace]).then(idxs => {
      searchTraceIndex = idxs[0];
    });
  }

  function initControls() {
    const input = document.getElementById('searchBox');
    const btn = document.getElementById('searchBtn');
    if (!input || !btn) return;

    // Click button triggers search
    btn.addEventListener('click', () => updateSearch(input.value));

    // Pressing Enter in input triggers search
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        btn.click();
      }
    });
  }

  // Wait until Plotly figure is ready, then init controls
  if (gd) {
    if (gd._fullLayout) {
      initControls();
    } else {
      gd.addEventListener('plotly_afterplot', initControls, { once: true });
    }
  }
})();
</script>
</body></html>